
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model NewsImage
 * 
 */
export type NewsImage = $Result.DefaultSelection<Prisma.$NewsImagePayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model JobListing
 * 
 */
export type JobListing = $Result.DefaultSelection<Prisma.$JobListingPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model FeaturedStudent
 * 
 */
export type FeaturedStudent = $Result.DefaultSelection<Prisma.$FeaturedStudentPayload>
/**
 * Model Training
 * 
 */
export type Training = $Result.DefaultSelection<Prisma.$TrainingPayload>
/**
 * Model StudentTrainingEnrollment
 * 
 */
export type StudentTrainingEnrollment = $Result.DefaultSelection<Prisma.$StudentTrainingEnrollmentPayload>
/**
 * Model StudentProfile
 * 
 */
export type StudentProfile = $Result.DefaultSelection<Prisma.$StudentProfilePayload>
/**
 * Model StudentSkill
 * 
 */
export type StudentSkill = $Result.DefaultSelection<Prisma.$StudentSkillPayload>
/**
 * Model StudentBadge
 * 
 */
export type StudentBadge = $Result.DefaultSelection<Prisma.$StudentBadgePayload>
/**
 * Model StudentTraining
 * 
 */
export type StudentTraining = $Result.DefaultSelection<Prisma.$StudentTrainingPayload>
/**
 * Model StudentTestimonial
 * 
 */
export type StudentTestimonial = $Result.DefaultSelection<Prisma.$StudentTestimonialPayload>
/**
 * Model StudentSubject
 * 
 */
export type StudentSubject = $Result.DefaultSelection<Prisma.$StudentSubjectPayload>
/**
 * Model TrainingReview
 * 
 */
export type TrainingReview = $Result.DefaultSelection<Prisma.$TrainingReviewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  CLIENT: 'CLIENT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TrainingType: {
  INFORMATION_SCIENCE: 'INFORMATION_SCIENCE',
  AGROBUSINESS: 'AGROBUSINESS',
  ACCOUNTING: 'ACCOUNTING',
  MARKETING: 'MARKETING'
};

export type TrainingType = (typeof TrainingType)[keyof typeof TrainingType]


export const JobType: {
  FULL_TIME: 'FULL_TIME',
  PART_TIME: 'PART_TIME',
  CONTRACT: 'CONTRACT',
  INTERNSHIP: 'INTERNSHIP'
};

export type JobType = (typeof JobType)[keyof typeof JobType]


export const TeamMemberRole: {
  EXECUTIVE_DIRECTOR: 'EXECUTIVE_DIRECTOR',
  MEETING_COORDINATOR: 'MEETING_COORDINATOR',
  BOARD_MEMBER: 'BOARD_MEMBER',
  PRESIDENT: 'PRESIDENT'
};

export type TeamMemberRole = (typeof TeamMemberRole)[keyof typeof TeamMemberRole]


export const CourseType: {
  INFORMATION_SCIENCE: 'INFORMATION_SCIENCE',
  AGROBUSINESS: 'AGROBUSINESS',
  ACCOUNTING: 'ACCOUNTING',
  MARKETING: 'MARKETING'
};

export type CourseType = (typeof CourseType)[keyof typeof CourseType]


export const TrainingStatus: {
  ENROLLED: 'ENROLLED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  DROPPED: 'DROPPED'
};

export type TrainingStatus = (typeof TrainingStatus)[keyof typeof TrainingStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TrainingType = $Enums.TrainingType

export const TrainingType: typeof $Enums.TrainingType

export type JobType = $Enums.JobType

export const JobType: typeof $Enums.JobType

export type TeamMemberRole = $Enums.TeamMemberRole

export const TeamMemberRole: typeof $Enums.TeamMemberRole

export type CourseType = $Enums.CourseType

export const CourseType: typeof $Enums.CourseType

export type TrainingStatus = $Enums.TrainingStatus

export const TrainingStatus: typeof $Enums.TrainingStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.newsImage`: Exposes CRUD operations for the **NewsImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsImages
    * const newsImages = await prisma.newsImage.findMany()
    * ```
    */
  get newsImage(): Prisma.NewsImageDelegate<ExtArgs>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs>;

  /**
   * `prisma.jobListing`: Exposes CRUD operations for the **JobListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobListings
    * const jobListings = await prisma.jobListing.findMany()
    * ```
    */
  get jobListing(): Prisma.JobListingDelegate<ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.featuredStudent`: Exposes CRUD operations for the **FeaturedStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedStudents
    * const featuredStudents = await prisma.featuredStudent.findMany()
    * ```
    */
  get featuredStudent(): Prisma.FeaturedStudentDelegate<ExtArgs>;

  /**
   * `prisma.training`: Exposes CRUD operations for the **Training** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings
    * const trainings = await prisma.training.findMany()
    * ```
    */
  get training(): Prisma.TrainingDelegate<ExtArgs>;

  /**
   * `prisma.studentTrainingEnrollment`: Exposes CRUD operations for the **StudentTrainingEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTrainingEnrollments
    * const studentTrainingEnrollments = await prisma.studentTrainingEnrollment.findMany()
    * ```
    */
  get studentTrainingEnrollment(): Prisma.StudentTrainingEnrollmentDelegate<ExtArgs>;

  /**
   * `prisma.studentProfile`: Exposes CRUD operations for the **StudentProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentProfiles
    * const studentProfiles = await prisma.studentProfile.findMany()
    * ```
    */
  get studentProfile(): Prisma.StudentProfileDelegate<ExtArgs>;

  /**
   * `prisma.studentSkill`: Exposes CRUD operations for the **StudentSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSkills
    * const studentSkills = await prisma.studentSkill.findMany()
    * ```
    */
  get studentSkill(): Prisma.StudentSkillDelegate<ExtArgs>;

  /**
   * `prisma.studentBadge`: Exposes CRUD operations for the **StudentBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentBadges
    * const studentBadges = await prisma.studentBadge.findMany()
    * ```
    */
  get studentBadge(): Prisma.StudentBadgeDelegate<ExtArgs>;

  /**
   * `prisma.studentTraining`: Exposes CRUD operations for the **StudentTraining** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTrainings
    * const studentTrainings = await prisma.studentTraining.findMany()
    * ```
    */
  get studentTraining(): Prisma.StudentTrainingDelegate<ExtArgs>;

  /**
   * `prisma.studentTestimonial`: Exposes CRUD operations for the **StudentTestimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTestimonials
    * const studentTestimonials = await prisma.studentTestimonial.findMany()
    * ```
    */
  get studentTestimonial(): Prisma.StudentTestimonialDelegate<ExtArgs>;

  /**
   * `prisma.studentSubject`: Exposes CRUD operations for the **StudentSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSubjects
    * const studentSubjects = await prisma.studentSubject.findMany()
    * ```
    */
  get studentSubject(): Prisma.StudentSubjectDelegate<ExtArgs>;

  /**
   * `prisma.trainingReview`: Exposes CRUD operations for the **TrainingReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingReviews
    * const trainingReviews = await prisma.trainingReview.findMany()
    * ```
    */
  get trainingReview(): Prisma.TrainingReviewDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    NewsImage: 'NewsImage',
    News: 'News',
    Application: 'Application',
    JobListing: 'JobListing',
    TeamMember: 'TeamMember',
    FeaturedStudent: 'FeaturedStudent',
    Training: 'Training',
    StudentTrainingEnrollment: 'StudentTrainingEnrollment',
    StudentProfile: 'StudentProfile',
    StudentSkill: 'StudentSkill',
    StudentBadge: 'StudentBadge',
    StudentTraining: 'StudentTraining',
    StudentTestimonial: 'StudentTestimonial',
    StudentSubject: 'StudentSubject',
    TrainingReview: 'TrainingReview'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "newsImage" | "news" | "application" | "jobListing" | "teamMember" | "featuredStudent" | "training" | "studentTrainingEnrollment" | "studentProfile" | "studentSkill" | "studentBadge" | "studentTraining" | "studentTestimonial" | "studentSubject" | "trainingReview"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      NewsImage: {
        payload: Prisma.$NewsImagePayload<ExtArgs>
        fields: Prisma.NewsImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload>
          }
          findFirst: {
            args: Prisma.NewsImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload>
          }
          findMany: {
            args: Prisma.NewsImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload>[]
          }
          create: {
            args: Prisma.NewsImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload>
          }
          createMany: {
            args: Prisma.NewsImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload>[]
          }
          delete: {
            args: Prisma.NewsImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload>
          }
          update: {
            args: Prisma.NewsImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload>
          }
          deleteMany: {
            args: Prisma.NewsImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsImagePayload>
          }
          aggregate: {
            args: Prisma.NewsImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsImage>
          }
          groupBy: {
            args: Prisma.NewsImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsImageCountArgs<ExtArgs>
            result: $Utils.Optional<NewsImageCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      JobListing: {
        payload: Prisma.$JobListingPayload<ExtArgs>
        fields: Prisma.JobListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          findFirst: {
            args: Prisma.JobListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          findMany: {
            args: Prisma.JobListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>[]
          }
          create: {
            args: Prisma.JobListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          createMany: {
            args: Prisma.JobListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>[]
          }
          delete: {
            args: Prisma.JobListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          update: {
            args: Prisma.JobListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          deleteMany: {
            args: Prisma.JobListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          aggregate: {
            args: Prisma.JobListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobListing>
          }
          groupBy: {
            args: Prisma.JobListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobListingCountArgs<ExtArgs>
            result: $Utils.Optional<JobListingCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      FeaturedStudent: {
        payload: Prisma.$FeaturedStudentPayload<ExtArgs>
        fields: Prisma.FeaturedStudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedStudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedStudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload>
          }
          findFirst: {
            args: Prisma.FeaturedStudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedStudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload>
          }
          findMany: {
            args: Prisma.FeaturedStudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload>[]
          }
          create: {
            args: Prisma.FeaturedStudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload>
          }
          createMany: {
            args: Prisma.FeaturedStudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedStudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload>[]
          }
          delete: {
            args: Prisma.FeaturedStudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload>
          }
          update: {
            args: Prisma.FeaturedStudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedStudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedStudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeaturedStudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedStudentPayload>
          }
          aggregate: {
            args: Prisma.FeaturedStudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedStudent>
          }
          groupBy: {
            args: Prisma.FeaturedStudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedStudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedStudentCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedStudentCountAggregateOutputType> | number
          }
        }
      }
      Training: {
        payload: Prisma.$TrainingPayload<ExtArgs>
        fields: Prisma.TrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findFirst: {
            args: Prisma.TrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findMany: {
            args: Prisma.TrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          create: {
            args: Prisma.TrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          createMany: {
            args: Prisma.TrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          delete: {
            args: Prisma.TrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          update: {
            args: Prisma.TrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          aggregate: {
            args: Prisma.TrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraining>
          }
          groupBy: {
            args: Prisma.TrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingCountAggregateOutputType> | number
          }
        }
      }
      StudentTrainingEnrollment: {
        payload: Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>
        fields: Prisma.StudentTrainingEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTrainingEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTrainingEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.StudentTrainingEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTrainingEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload>
          }
          findMany: {
            args: Prisma.StudentTrainingEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload>[]
          }
          create: {
            args: Prisma.StudentTrainingEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload>
          }
          createMany: {
            args: Prisma.StudentTrainingEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTrainingEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.StudentTrainingEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload>
          }
          update: {
            args: Prisma.StudentTrainingEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.StudentTrainingEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTrainingEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentTrainingEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.StudentTrainingEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTrainingEnrollment>
          }
          groupBy: {
            args: Prisma.StudentTrainingEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTrainingEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTrainingEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTrainingEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      StudentProfile: {
        payload: Prisma.$StudentProfilePayload<ExtArgs>
        fields: Prisma.StudentProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          findFirst: {
            args: Prisma.StudentProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          findMany: {
            args: Prisma.StudentProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          create: {
            args: Prisma.StudentProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          createMany: {
            args: Prisma.StudentProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          delete: {
            args: Prisma.StudentProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          update: {
            args: Prisma.StudentProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          deleteMany: {
            args: Prisma.StudentProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          aggregate: {
            args: Prisma.StudentProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentProfile>
          }
          groupBy: {
            args: Prisma.StudentProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentProfileCountArgs<ExtArgs>
            result: $Utils.Optional<StudentProfileCountAggregateOutputType> | number
          }
        }
      }
      StudentSkill: {
        payload: Prisma.$StudentSkillPayload<ExtArgs>
        fields: Prisma.StudentSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          findFirst: {
            args: Prisma.StudentSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          findMany: {
            args: Prisma.StudentSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>[]
          }
          create: {
            args: Prisma.StudentSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          createMany: {
            args: Prisma.StudentSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>[]
          }
          delete: {
            args: Prisma.StudentSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          update: {
            args: Prisma.StudentSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          deleteMany: {
            args: Prisma.StudentSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          aggregate: {
            args: Prisma.StudentSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSkill>
          }
          groupBy: {
            args: Prisma.StudentSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSkillCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSkillCountAggregateOutputType> | number
          }
        }
      }
      StudentBadge: {
        payload: Prisma.$StudentBadgePayload<ExtArgs>
        fields: Prisma.StudentBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload>
          }
          findFirst: {
            args: Prisma.StudentBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload>
          }
          findMany: {
            args: Prisma.StudentBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload>[]
          }
          create: {
            args: Prisma.StudentBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload>
          }
          createMany: {
            args: Prisma.StudentBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload>[]
          }
          delete: {
            args: Prisma.StudentBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload>
          }
          update: {
            args: Prisma.StudentBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload>
          }
          deleteMany: {
            args: Prisma.StudentBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentBadgePayload>
          }
          aggregate: {
            args: Prisma.StudentBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentBadge>
          }
          groupBy: {
            args: Prisma.StudentBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<StudentBadgeCountAggregateOutputType> | number
          }
        }
      }
      StudentTraining: {
        payload: Prisma.$StudentTrainingPayload<ExtArgs>
        fields: Prisma.StudentTrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload>
          }
          findFirst: {
            args: Prisma.StudentTrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload>
          }
          findMany: {
            args: Prisma.StudentTrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload>[]
          }
          create: {
            args: Prisma.StudentTrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload>
          }
          createMany: {
            args: Prisma.StudentTrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload>[]
          }
          delete: {
            args: Prisma.StudentTrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload>
          }
          update: {
            args: Prisma.StudentTrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload>
          }
          deleteMany: {
            args: Prisma.StudentTrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentTrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTrainingPayload>
          }
          aggregate: {
            args: Prisma.StudentTrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTraining>
          }
          groupBy: {
            args: Prisma.StudentTrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTrainingCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTrainingCountAggregateOutputType> | number
          }
        }
      }
      StudentTestimonial: {
        payload: Prisma.$StudentTestimonialPayload<ExtArgs>
        fields: Prisma.StudentTestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload>
          }
          findFirst: {
            args: Prisma.StudentTestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload>
          }
          findMany: {
            args: Prisma.StudentTestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload>[]
          }
          create: {
            args: Prisma.StudentTestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload>
          }
          createMany: {
            args: Prisma.StudentTestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload>[]
          }
          delete: {
            args: Prisma.StudentTestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload>
          }
          update: {
            args: Prisma.StudentTestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload>
          }
          deleteMany: {
            args: Prisma.StudentTestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentTestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestimonialPayload>
          }
          aggregate: {
            args: Prisma.StudentTestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTestimonial>
          }
          groupBy: {
            args: Prisma.StudentTestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTestimonialCountAggregateOutputType> | number
          }
        }
      }
      StudentSubject: {
        payload: Prisma.$StudentSubjectPayload<ExtArgs>
        fields: Prisma.StudentSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          findFirst: {
            args: Prisma.StudentSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          findMany: {
            args: Prisma.StudentSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>[]
          }
          create: {
            args: Prisma.StudentSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          createMany: {
            args: Prisma.StudentSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>[]
          }
          delete: {
            args: Prisma.StudentSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          update: {
            args: Prisma.StudentSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          deleteMany: {
            args: Prisma.StudentSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSubjectPayload>
          }
          aggregate: {
            args: Prisma.StudentSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSubject>
          }
          groupBy: {
            args: Prisma.StudentSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSubjectCountAggregateOutputType> | number
          }
        }
      }
      TrainingReview: {
        payload: Prisma.$TrainingReviewPayload<ExtArgs>
        fields: Prisma.TrainingReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload>
          }
          findFirst: {
            args: Prisma.TrainingReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload>
          }
          findMany: {
            args: Prisma.TrainingReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload>[]
          }
          create: {
            args: Prisma.TrainingReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload>
          }
          createMany: {
            args: Prisma.TrainingReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload>[]
          }
          delete: {
            args: Prisma.TrainingReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload>
          }
          update: {
            args: Prisma.TrainingReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload>
          }
          deleteMany: {
            args: Prisma.TrainingReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingReviewPayload>
          }
          aggregate: {
            args: Prisma.TrainingReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingReview>
          }
          groupBy: {
            args: Prisma.TrainingReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingReviewCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingReviewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    applications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | UserCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Count Type NewsCountOutputType
   */

  export type NewsCountOutputType = {
    images: number
  }

  export type NewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | NewsCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * NewsCountOutputType without action
   */
  export type NewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsCountOutputType
     */
    select?: NewsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsCountOutputType without action
   */
  export type NewsCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsImageWhereInput
  }


  /**
   * Count Type FeaturedStudentCountOutputType
   */

  export type FeaturedStudentCountOutputType = {
    trainingReviews: number
  }

  export type FeaturedStudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainingReviews?: boolean | FeaturedStudentCountOutputTypeCountTrainingReviewsArgs
  }

  // Custom InputTypes
  /**
   * FeaturedStudentCountOutputType without action
   */
  export type FeaturedStudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudentCountOutputType
     */
    select?: FeaturedStudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeaturedStudentCountOutputType without action
   */
  export type FeaturedStudentCountOutputTypeCountTrainingReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingReviewWhereInput
  }


  /**
   * Count Type TrainingCountOutputType
   */

  export type TrainingCountOutputType = {
    enrollments: number
    reviews: number
  }

  export type TrainingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | TrainingCountOutputTypeCountEnrollmentsArgs
    reviews?: boolean | TrainingCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCountOutputType
     */
    select?: TrainingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTrainingEnrollmentWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingReviewWhereInput
  }


  /**
   * Count Type StudentProfileCountOutputType
   */

  export type StudentProfileCountOutputType = {
    skills: number
    badges: number
    trainings: number
    testimonials: number
    academicSubjects: number
    trainingReviews: number
    StudentTraining: number
  }

  export type StudentProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | StudentProfileCountOutputTypeCountSkillsArgs
    badges?: boolean | StudentProfileCountOutputTypeCountBadgesArgs
    trainings?: boolean | StudentProfileCountOutputTypeCountTrainingsArgs
    testimonials?: boolean | StudentProfileCountOutputTypeCountTestimonialsArgs
    academicSubjects?: boolean | StudentProfileCountOutputTypeCountAcademicSubjectsArgs
    trainingReviews?: boolean | StudentProfileCountOutputTypeCountTrainingReviewsArgs
    StudentTraining?: boolean | StudentProfileCountOutputTypeCountStudentTrainingArgs
  }

  // Custom InputTypes
  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfileCountOutputType
     */
    select?: StudentProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSkillWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentBadgeWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTrainingEnrollmentWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTestimonialWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountAcademicSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountTrainingReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingReviewWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountStudentTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTrainingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    surname: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    isStudent: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    surname: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    isStudent: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    surname: number
    email: number
    password: number
    role: number
    isStudent: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    password?: true
    role?: true
    isStudent?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    password?: true
    role?: true
    isStudent?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    password?: true
    role?: true
    isStudent?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    surname: string
    email: string
    password: string
    role: $Enums.UserRole
    isStudent: boolean
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isStudent?: boolean
    createdAt?: boolean
    applications?: boolean | User$applicationsArgs<ExtArgs>
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isStudent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isStudent?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | User$applicationsArgs<ExtArgs>
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      surname: string
      email: string
      password: string
      role: $Enums.UserRole
      isStudent: boolean
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends User$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    studentProfile<T extends User$studentProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$studentProfileArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly surname: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isStudent: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.applications
   */
  export type User$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * User.studentProfile
   */
  export type User$studentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model NewsImage
   */

  export type AggregateNewsImage = {
    _count: NewsImageCountAggregateOutputType | null
    _avg: NewsImageAvgAggregateOutputType | null
    _sum: NewsImageSumAggregateOutputType | null
    _min: NewsImageMinAggregateOutputType | null
    _max: NewsImageMaxAggregateOutputType | null
  }

  export type NewsImageAvgAggregateOutputType = {
    id: number | null
    order: number | null
    newsId: number | null
  }

  export type NewsImageSumAggregateOutputType = {
    id: number | null
    order: number | null
    newsId: number | null
  }

  export type NewsImageMinAggregateOutputType = {
    id: number | null
    url: string | null
    socialUrl: string | null
    mobileSocialUrl: string | null
    desktopSocialUrl: string | null
    isMain: boolean | null
    order: number | null
    newsId: number | null
    createdAt: Date | null
  }

  export type NewsImageMaxAggregateOutputType = {
    id: number | null
    url: string | null
    socialUrl: string | null
    mobileSocialUrl: string | null
    desktopSocialUrl: string | null
    isMain: boolean | null
    order: number | null
    newsId: number | null
    createdAt: Date | null
  }

  export type NewsImageCountAggregateOutputType = {
    id: number
    url: number
    socialUrl: number
    mobileSocialUrl: number
    desktopSocialUrl: number
    isMain: number
    order: number
    newsId: number
    createdAt: number
    _all: number
  }


  export type NewsImageAvgAggregateInputType = {
    id?: true
    order?: true
    newsId?: true
  }

  export type NewsImageSumAggregateInputType = {
    id?: true
    order?: true
    newsId?: true
  }

  export type NewsImageMinAggregateInputType = {
    id?: true
    url?: true
    socialUrl?: true
    mobileSocialUrl?: true
    desktopSocialUrl?: true
    isMain?: true
    order?: true
    newsId?: true
    createdAt?: true
  }

  export type NewsImageMaxAggregateInputType = {
    id?: true
    url?: true
    socialUrl?: true
    mobileSocialUrl?: true
    desktopSocialUrl?: true
    isMain?: true
    order?: true
    newsId?: true
    createdAt?: true
  }

  export type NewsImageCountAggregateInputType = {
    id?: true
    url?: true
    socialUrl?: true
    mobileSocialUrl?: true
    desktopSocialUrl?: true
    isMain?: true
    order?: true
    newsId?: true
    createdAt?: true
    _all?: true
  }

  export type NewsImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsImage to aggregate.
     */
    where?: NewsImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsImages to fetch.
     */
    orderBy?: NewsImageOrderByWithRelationInput | NewsImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsImages
    **/
    _count?: true | NewsImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsImageMaxAggregateInputType
  }

  export type GetNewsImageAggregateType<T extends NewsImageAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsImage[P]>
      : GetScalarType<T[P], AggregateNewsImage[P]>
  }




  export type NewsImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsImageWhereInput
    orderBy?: NewsImageOrderByWithAggregationInput | NewsImageOrderByWithAggregationInput[]
    by: NewsImageScalarFieldEnum[] | NewsImageScalarFieldEnum
    having?: NewsImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsImageCountAggregateInputType | true
    _avg?: NewsImageAvgAggregateInputType
    _sum?: NewsImageSumAggregateInputType
    _min?: NewsImageMinAggregateInputType
    _max?: NewsImageMaxAggregateInputType
  }

  export type NewsImageGroupByOutputType = {
    id: number
    url: string
    socialUrl: string | null
    mobileSocialUrl: string | null
    desktopSocialUrl: string | null
    isMain: boolean
    order: number
    newsId: number
    createdAt: Date
    _count: NewsImageCountAggregateOutputType | null
    _avg: NewsImageAvgAggregateOutputType | null
    _sum: NewsImageSumAggregateOutputType | null
    _min: NewsImageMinAggregateOutputType | null
    _max: NewsImageMaxAggregateOutputType | null
  }

  type GetNewsImageGroupByPayload<T extends NewsImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsImageGroupByOutputType[P]>
            : GetScalarType<T[P], NewsImageGroupByOutputType[P]>
        }
      >
    >


  export type NewsImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    socialUrl?: boolean
    mobileSocialUrl?: boolean
    desktopSocialUrl?: boolean
    isMain?: boolean
    order?: boolean
    newsId?: boolean
    createdAt?: boolean
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsImage"]>

  export type NewsImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    socialUrl?: boolean
    mobileSocialUrl?: boolean
    desktopSocialUrl?: boolean
    isMain?: boolean
    order?: boolean
    newsId?: boolean
    createdAt?: boolean
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsImage"]>

  export type NewsImageSelectScalar = {
    id?: boolean
    url?: boolean
    socialUrl?: boolean
    mobileSocialUrl?: boolean
    desktopSocialUrl?: boolean
    isMain?: boolean
    order?: boolean
    newsId?: boolean
    createdAt?: boolean
  }

  export type NewsImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }
  export type NewsImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }

  export type $NewsImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsImage"
    objects: {
      news: Prisma.$NewsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      socialUrl: string | null
      mobileSocialUrl: string | null
      desktopSocialUrl: string | null
      isMain: boolean
      order: number
      newsId: number
      createdAt: Date
    }, ExtArgs["result"]["newsImage"]>
    composites: {}
  }

  type NewsImageGetPayload<S extends boolean | null | undefined | NewsImageDefaultArgs> = $Result.GetResult<Prisma.$NewsImagePayload, S>

  type NewsImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsImageCountAggregateInputType | true
    }

  export interface NewsImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsImage'], meta: { name: 'NewsImage' } }
    /**
     * Find zero or one NewsImage that matches the filter.
     * @param {NewsImageFindUniqueArgs} args - Arguments to find a NewsImage
     * @example
     * // Get one NewsImage
     * const newsImage = await prisma.newsImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsImageFindUniqueArgs>(args: SelectSubset<T, NewsImageFindUniqueArgs<ExtArgs>>): Prisma__NewsImageClient<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsImageFindUniqueOrThrowArgs} args - Arguments to find a NewsImage
     * @example
     * // Get one NewsImage
     * const newsImage = await prisma.newsImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsImageFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsImageClient<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsImageFindFirstArgs} args - Arguments to find a NewsImage
     * @example
     * // Get one NewsImage
     * const newsImage = await prisma.newsImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsImageFindFirstArgs>(args?: SelectSubset<T, NewsImageFindFirstArgs<ExtArgs>>): Prisma__NewsImageClient<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsImageFindFirstOrThrowArgs} args - Arguments to find a NewsImage
     * @example
     * // Get one NewsImage
     * const newsImage = await prisma.newsImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsImageFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsImageClient<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsImages
     * const newsImages = await prisma.newsImage.findMany()
     * 
     * // Get first 10 NewsImages
     * const newsImages = await prisma.newsImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsImageWithIdOnly = await prisma.newsImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsImageFindManyArgs>(args?: SelectSubset<T, NewsImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsImage.
     * @param {NewsImageCreateArgs} args - Arguments to create a NewsImage.
     * @example
     * // Create one NewsImage
     * const NewsImage = await prisma.newsImage.create({
     *   data: {
     *     // ... data to create a NewsImage
     *   }
     * })
     * 
     */
    create<T extends NewsImageCreateArgs>(args: SelectSubset<T, NewsImageCreateArgs<ExtArgs>>): Prisma__NewsImageClient<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsImages.
     * @param {NewsImageCreateManyArgs} args - Arguments to create many NewsImages.
     * @example
     * // Create many NewsImages
     * const newsImage = await prisma.newsImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsImageCreateManyArgs>(args?: SelectSubset<T, NewsImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsImages and returns the data saved in the database.
     * @param {NewsImageCreateManyAndReturnArgs} args - Arguments to create many NewsImages.
     * @example
     * // Create many NewsImages
     * const newsImage = await prisma.newsImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsImages and only return the `id`
     * const newsImageWithIdOnly = await prisma.newsImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsImageCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsImage.
     * @param {NewsImageDeleteArgs} args - Arguments to delete one NewsImage.
     * @example
     * // Delete one NewsImage
     * const NewsImage = await prisma.newsImage.delete({
     *   where: {
     *     // ... filter to delete one NewsImage
     *   }
     * })
     * 
     */
    delete<T extends NewsImageDeleteArgs>(args: SelectSubset<T, NewsImageDeleteArgs<ExtArgs>>): Prisma__NewsImageClient<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsImage.
     * @param {NewsImageUpdateArgs} args - Arguments to update one NewsImage.
     * @example
     * // Update one NewsImage
     * const newsImage = await prisma.newsImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsImageUpdateArgs>(args: SelectSubset<T, NewsImageUpdateArgs<ExtArgs>>): Prisma__NewsImageClient<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsImages.
     * @param {NewsImageDeleteManyArgs} args - Arguments to filter NewsImages to delete.
     * @example
     * // Delete a few NewsImages
     * const { count } = await prisma.newsImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsImageDeleteManyArgs>(args?: SelectSubset<T, NewsImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsImages
     * const newsImage = await prisma.newsImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsImageUpdateManyArgs>(args: SelectSubset<T, NewsImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsImage.
     * @param {NewsImageUpsertArgs} args - Arguments to update or create a NewsImage.
     * @example
     * // Update or create a NewsImage
     * const newsImage = await prisma.newsImage.upsert({
     *   create: {
     *     // ... data to create a NewsImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsImage we want to update
     *   }
     * })
     */
    upsert<T extends NewsImageUpsertArgs>(args: SelectSubset<T, NewsImageUpsertArgs<ExtArgs>>): Prisma__NewsImageClient<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsImageCountArgs} args - Arguments to filter NewsImages to count.
     * @example
     * // Count the number of NewsImages
     * const count = await prisma.newsImage.count({
     *   where: {
     *     // ... the filter for the NewsImages we want to count
     *   }
     * })
    **/
    count<T extends NewsImageCountArgs>(
      args?: Subset<T, NewsImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsImageAggregateArgs>(args: Subset<T, NewsImageAggregateArgs>): Prisma.PrismaPromise<GetNewsImageAggregateType<T>>

    /**
     * Group by NewsImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsImageGroupByArgs['orderBy'] }
        : { orderBy?: NewsImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsImage model
   */
  readonly fields: NewsImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    news<T extends NewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsDefaultArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsImage model
   */ 
  interface NewsImageFieldRefs {
    readonly id: FieldRef<"NewsImage", 'Int'>
    readonly url: FieldRef<"NewsImage", 'String'>
    readonly socialUrl: FieldRef<"NewsImage", 'String'>
    readonly mobileSocialUrl: FieldRef<"NewsImage", 'String'>
    readonly desktopSocialUrl: FieldRef<"NewsImage", 'String'>
    readonly isMain: FieldRef<"NewsImage", 'Boolean'>
    readonly order: FieldRef<"NewsImage", 'Int'>
    readonly newsId: FieldRef<"NewsImage", 'Int'>
    readonly createdAt: FieldRef<"NewsImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsImage findUnique
   */
  export type NewsImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * Filter, which NewsImage to fetch.
     */
    where: NewsImageWhereUniqueInput
  }

  /**
   * NewsImage findUniqueOrThrow
   */
  export type NewsImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * Filter, which NewsImage to fetch.
     */
    where: NewsImageWhereUniqueInput
  }

  /**
   * NewsImage findFirst
   */
  export type NewsImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * Filter, which NewsImage to fetch.
     */
    where?: NewsImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsImages to fetch.
     */
    orderBy?: NewsImageOrderByWithRelationInput | NewsImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsImages.
     */
    cursor?: NewsImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsImages.
     */
    distinct?: NewsImageScalarFieldEnum | NewsImageScalarFieldEnum[]
  }

  /**
   * NewsImage findFirstOrThrow
   */
  export type NewsImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * Filter, which NewsImage to fetch.
     */
    where?: NewsImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsImages to fetch.
     */
    orderBy?: NewsImageOrderByWithRelationInput | NewsImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsImages.
     */
    cursor?: NewsImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsImages.
     */
    distinct?: NewsImageScalarFieldEnum | NewsImageScalarFieldEnum[]
  }

  /**
   * NewsImage findMany
   */
  export type NewsImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * Filter, which NewsImages to fetch.
     */
    where?: NewsImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsImages to fetch.
     */
    orderBy?: NewsImageOrderByWithRelationInput | NewsImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsImages.
     */
    cursor?: NewsImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsImages.
     */
    skip?: number
    distinct?: NewsImageScalarFieldEnum | NewsImageScalarFieldEnum[]
  }

  /**
   * NewsImage create
   */
  export type NewsImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsImage.
     */
    data: XOR<NewsImageCreateInput, NewsImageUncheckedCreateInput>
  }

  /**
   * NewsImage createMany
   */
  export type NewsImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsImages.
     */
    data: NewsImageCreateManyInput | NewsImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsImage createManyAndReturn
   */
  export type NewsImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsImages.
     */
    data: NewsImageCreateManyInput | NewsImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsImage update
   */
  export type NewsImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsImage.
     */
    data: XOR<NewsImageUpdateInput, NewsImageUncheckedUpdateInput>
    /**
     * Choose, which NewsImage to update.
     */
    where: NewsImageWhereUniqueInput
  }

  /**
   * NewsImage updateMany
   */
  export type NewsImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsImages.
     */
    data: XOR<NewsImageUpdateManyMutationInput, NewsImageUncheckedUpdateManyInput>
    /**
     * Filter which NewsImages to update
     */
    where?: NewsImageWhereInput
  }

  /**
   * NewsImage upsert
   */
  export type NewsImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsImage to update in case it exists.
     */
    where: NewsImageWhereUniqueInput
    /**
     * In case the NewsImage found by the `where` argument doesn't exist, create a new NewsImage with this data.
     */
    create: XOR<NewsImageCreateInput, NewsImageUncheckedCreateInput>
    /**
     * In case the NewsImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsImageUpdateInput, NewsImageUncheckedUpdateInput>
  }

  /**
   * NewsImage delete
   */
  export type NewsImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    /**
     * Filter which NewsImage to delete.
     */
    where: NewsImageWhereUniqueInput
  }

  /**
   * NewsImage deleteMany
   */
  export type NewsImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsImages to delete
     */
    where?: NewsImageWhereInput
  }

  /**
   * NewsImage without action
   */
  export type NewsImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
  }


  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    id: number | null
  }

  export type NewsSumAggregateOutputType = {
    id: number | null
  }

  export type NewsMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    imageUrl: string | null
  }

  export type NewsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    imageUrl: string | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    createdAt: number
    imageUrl: number
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    id?: true
  }

  export type NewsSumAggregateInputType = {
    id?: true
  }

  export type NewsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    imageUrl?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    imageUrl?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    imageUrl?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _avg?: NewsAvgAggregateInputType
    _sum?: NewsSumAggregateInputType
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: number
    title: string
    content: string
    createdAt: Date
    imageUrl: string | null
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    imageUrl?: boolean
    images?: boolean | News$imagesArgs<ExtArgs>
    _count?: boolean | NewsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    imageUrl?: boolean
  }, ExtArgs["result"]["news"]>

  export type NewsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    imageUrl?: boolean
  }

  export type NewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | News$imagesArgs<ExtArgs>
    _count?: boolean | NewsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {
      images: Prisma.$NewsImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      createdAt: Date
      imageUrl: string | null
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsFindUniqueArgs>(args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsFindFirstArgs>(args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsFindManyArgs>(args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends NewsCreateArgs>(args: SelectSubset<T, NewsCreateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many News.
     * @param {NewsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsCreateManyArgs>(args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many News and returns the data saved in the database.
     * @param {NewsCreateManyAndReturnArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many News and only return the `id`
     * const newsWithIdOnly = await prisma.news.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends NewsDeleteArgs>(args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsUpdateArgs>(args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsDeleteManyArgs>(args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsUpdateManyArgs>(args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends NewsUpsertArgs>(args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends News$imagesArgs<ExtArgs> = {}>(args?: Subset<T, News$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the News model
   */ 
  interface NewsFieldRefs {
    readonly id: FieldRef<"News", 'Int'>
    readonly title: FieldRef<"News", 'String'>
    readonly content: FieldRef<"News", 'String'>
    readonly createdAt: FieldRef<"News", 'DateTime'>
    readonly imageUrl: FieldRef<"News", 'String'>
  }
    

  // Custom InputTypes
  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }

  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News createManyAndReturn
   */
  export type NewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
  }

  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }

  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
  }

  /**
   * News.images
   */
  export type News$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsImage
     */
    select?: NewsImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsImageInclude<ExtArgs> | null
    where?: NewsImageWhereInput
    orderBy?: NewsImageOrderByWithRelationInput | NewsImageOrderByWithRelationInput[]
    cursor?: NewsImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsImageScalarFieldEnum | NewsImageScalarFieldEnum[]
  }

  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ApplicationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    surname: string | null
    email: string | null
    phoneNumber: string | null
    createdAt: Date | null
    type: $Enums.TrainingType | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    surname: string | null
    email: string | null
    phoneNumber: string | null
    createdAt: Date | null
    type: $Enums.TrainingType | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    surname: number
    email: number
    phoneNumber: number
    createdAt: number
    type: number
    _all: number
  }


  export type ApplicationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ApplicationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    surname?: true
    email?: true
    phoneNumber?: true
    createdAt?: true
    type?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    surname?: true
    email?: true
    phoneNumber?: true
    createdAt?: true
    type?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    surname?: true
    email?: true
    phoneNumber?: true
    createdAt?: true
    type?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _avg?: ApplicationAvgAggregateInputType
    _sum?: ApplicationSumAggregateInputType
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: number
    userId: number | null
    name: string
    surname: string
    email: string
    phoneNumber: string | null
    createdAt: Date
    type: $Enums.TrainingType
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    type?: boolean
    user?: boolean | Application$userArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    type?: boolean
    user?: boolean | Application$userArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    type?: boolean
  }

  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Application$userArgs<ExtArgs>
  }
  export type ApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Application$userArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      name: string
      surname: string
      email: string
      phoneNumber: string | null
      createdAt: Date
      type: $Enums.TrainingType
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Application$userArgs<ExtArgs> = {}>(args?: Subset<T, Application$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */ 
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'Int'>
    readonly userId: FieldRef<"Application", 'Int'>
    readonly name: FieldRef<"Application", 'String'>
    readonly surname: FieldRef<"Application", 'String'>
    readonly email: FieldRef<"Application", 'String'>
    readonly phoneNumber: FieldRef<"Application", 'String'>
    readonly createdAt: FieldRef<"Application", 'DateTime'>
    readonly type: FieldRef<"Application", 'TrainingType'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application.user
   */
  export type Application$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model JobListing
   */

  export type AggregateJobListing = {
    _count: JobListingCountAggregateOutputType | null
    _avg: JobListingAvgAggregateOutputType | null
    _sum: JobListingSumAggregateOutputType | null
    _min: JobListingMinAggregateOutputType | null
    _max: JobListingMaxAggregateOutputType | null
  }

  export type JobListingAvgAggregateOutputType = {
    id: number | null
  }

  export type JobListingSumAggregateOutputType = {
    id: number | null
  }

  export type JobListingMinAggregateOutputType = {
    id: number | null
    title: string | null
    company: string | null
    location: string | null
    type: $Enums.JobType | null
    salary: string | null
    description: string | null
    posted: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type JobListingMaxAggregateOutputType = {
    id: number | null
    title: string | null
    company: string | null
    location: string | null
    type: $Enums.JobType | null
    salary: string | null
    description: string | null
    posted: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type JobListingCountAggregateOutputType = {
    id: number
    title: number
    company: number
    location: number
    type: number
    salary: number
    description: number
    requirements: number
    posted: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type JobListingAvgAggregateInputType = {
    id?: true
  }

  export type JobListingSumAggregateInputType = {
    id?: true
  }

  export type JobListingMinAggregateInputType = {
    id?: true
    title?: true
    company?: true
    location?: true
    type?: true
    salary?: true
    description?: true
    posted?: true
    updatedAt?: true
    isActive?: true
  }

  export type JobListingMaxAggregateInputType = {
    id?: true
    title?: true
    company?: true
    location?: true
    type?: true
    salary?: true
    description?: true
    posted?: true
    updatedAt?: true
    isActive?: true
  }

  export type JobListingCountAggregateInputType = {
    id?: true
    title?: true
    company?: true
    location?: true
    type?: true
    salary?: true
    description?: true
    requirements?: true
    posted?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type JobListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobListing to aggregate.
     */
    where?: JobListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobListings to fetch.
     */
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobListings
    **/
    _count?: true | JobListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobListingMaxAggregateInputType
  }

  export type GetJobListingAggregateType<T extends JobListingAggregateArgs> = {
        [P in keyof T & keyof AggregateJobListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobListing[P]>
      : GetScalarType<T[P], AggregateJobListing[P]>
  }




  export type JobListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobListingWhereInput
    orderBy?: JobListingOrderByWithAggregationInput | JobListingOrderByWithAggregationInput[]
    by: JobListingScalarFieldEnum[] | JobListingScalarFieldEnum
    having?: JobListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobListingCountAggregateInputType | true
    _avg?: JobListingAvgAggregateInputType
    _sum?: JobListingSumAggregateInputType
    _min?: JobListingMinAggregateInputType
    _max?: JobListingMaxAggregateInputType
  }

  export type JobListingGroupByOutputType = {
    id: number
    title: string
    company: string
    location: string
    type: $Enums.JobType
    salary: string
    description: string
    requirements: string[]
    posted: Date
    updatedAt: Date
    isActive: boolean
    _count: JobListingCountAggregateOutputType | null
    _avg: JobListingAvgAggregateOutputType | null
    _sum: JobListingSumAggregateOutputType | null
    _min: JobListingMinAggregateOutputType | null
    _max: JobListingMaxAggregateOutputType | null
  }

  type GetJobListingGroupByPayload<T extends JobListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobListingGroupByOutputType[P]>
            : GetScalarType<T[P], JobListingGroupByOutputType[P]>
        }
      >
    >


  export type JobListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    type?: boolean
    salary?: boolean
    description?: boolean
    requirements?: boolean
    posted?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["jobListing"]>

  export type JobListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    type?: boolean
    salary?: boolean
    description?: boolean
    requirements?: boolean
    posted?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["jobListing"]>

  export type JobListingSelectScalar = {
    id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    type?: boolean
    salary?: boolean
    description?: boolean
    requirements?: boolean
    posted?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }


  export type $JobListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobListing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      company: string
      location: string
      type: $Enums.JobType
      salary: string
      description: string
      requirements: string[]
      posted: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["jobListing"]>
    composites: {}
  }

  type JobListingGetPayload<S extends boolean | null | undefined | JobListingDefaultArgs> = $Result.GetResult<Prisma.$JobListingPayload, S>

  type JobListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobListingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobListingCountAggregateInputType | true
    }

  export interface JobListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobListing'], meta: { name: 'JobListing' } }
    /**
     * Find zero or one JobListing that matches the filter.
     * @param {JobListingFindUniqueArgs} args - Arguments to find a JobListing
     * @example
     * // Get one JobListing
     * const jobListing = await prisma.jobListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobListingFindUniqueArgs>(args: SelectSubset<T, JobListingFindUniqueArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobListing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobListingFindUniqueOrThrowArgs} args - Arguments to find a JobListing
     * @example
     * // Get one JobListing
     * const jobListing = await prisma.jobListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobListingFindUniqueOrThrowArgs>(args: SelectSubset<T, JobListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingFindFirstArgs} args - Arguments to find a JobListing
     * @example
     * // Get one JobListing
     * const jobListing = await prisma.jobListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobListingFindFirstArgs>(args?: SelectSubset<T, JobListingFindFirstArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingFindFirstOrThrowArgs} args - Arguments to find a JobListing
     * @example
     * // Get one JobListing
     * const jobListing = await prisma.jobListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobListingFindFirstOrThrowArgs>(args?: SelectSubset<T, JobListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobListings
     * const jobListings = await prisma.jobListing.findMany()
     * 
     * // Get first 10 JobListings
     * const jobListings = await prisma.jobListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobListingWithIdOnly = await prisma.jobListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobListingFindManyArgs>(args?: SelectSubset<T, JobListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobListing.
     * @param {JobListingCreateArgs} args - Arguments to create a JobListing.
     * @example
     * // Create one JobListing
     * const JobListing = await prisma.jobListing.create({
     *   data: {
     *     // ... data to create a JobListing
     *   }
     * })
     * 
     */
    create<T extends JobListingCreateArgs>(args: SelectSubset<T, JobListingCreateArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobListings.
     * @param {JobListingCreateManyArgs} args - Arguments to create many JobListings.
     * @example
     * // Create many JobListings
     * const jobListing = await prisma.jobListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobListingCreateManyArgs>(args?: SelectSubset<T, JobListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobListings and returns the data saved in the database.
     * @param {JobListingCreateManyAndReturnArgs} args - Arguments to create many JobListings.
     * @example
     * // Create many JobListings
     * const jobListing = await prisma.jobListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobListings and only return the `id`
     * const jobListingWithIdOnly = await prisma.jobListing.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobListingCreateManyAndReturnArgs>(args?: SelectSubset<T, JobListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobListing.
     * @param {JobListingDeleteArgs} args - Arguments to delete one JobListing.
     * @example
     * // Delete one JobListing
     * const JobListing = await prisma.jobListing.delete({
     *   where: {
     *     // ... filter to delete one JobListing
     *   }
     * })
     * 
     */
    delete<T extends JobListingDeleteArgs>(args: SelectSubset<T, JobListingDeleteArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobListing.
     * @param {JobListingUpdateArgs} args - Arguments to update one JobListing.
     * @example
     * // Update one JobListing
     * const jobListing = await prisma.jobListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobListingUpdateArgs>(args: SelectSubset<T, JobListingUpdateArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobListings.
     * @param {JobListingDeleteManyArgs} args - Arguments to filter JobListings to delete.
     * @example
     * // Delete a few JobListings
     * const { count } = await prisma.jobListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobListingDeleteManyArgs>(args?: SelectSubset<T, JobListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobListings
     * const jobListing = await prisma.jobListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobListingUpdateManyArgs>(args: SelectSubset<T, JobListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobListing.
     * @param {JobListingUpsertArgs} args - Arguments to update or create a JobListing.
     * @example
     * // Update or create a JobListing
     * const jobListing = await prisma.jobListing.upsert({
     *   create: {
     *     // ... data to create a JobListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobListing we want to update
     *   }
     * })
     */
    upsert<T extends JobListingUpsertArgs>(args: SelectSubset<T, JobListingUpsertArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingCountArgs} args - Arguments to filter JobListings to count.
     * @example
     * // Count the number of JobListings
     * const count = await prisma.jobListing.count({
     *   where: {
     *     // ... the filter for the JobListings we want to count
     *   }
     * })
    **/
    count<T extends JobListingCountArgs>(
      args?: Subset<T, JobListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobListingAggregateArgs>(args: Subset<T, JobListingAggregateArgs>): Prisma.PrismaPromise<GetJobListingAggregateType<T>>

    /**
     * Group by JobListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobListingGroupByArgs['orderBy'] }
        : { orderBy?: JobListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobListing model
   */
  readonly fields: JobListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobListing model
   */ 
  interface JobListingFieldRefs {
    readonly id: FieldRef<"JobListing", 'Int'>
    readonly title: FieldRef<"JobListing", 'String'>
    readonly company: FieldRef<"JobListing", 'String'>
    readonly location: FieldRef<"JobListing", 'String'>
    readonly type: FieldRef<"JobListing", 'JobType'>
    readonly salary: FieldRef<"JobListing", 'String'>
    readonly description: FieldRef<"JobListing", 'String'>
    readonly requirements: FieldRef<"JobListing", 'String[]'>
    readonly posted: FieldRef<"JobListing", 'DateTime'>
    readonly updatedAt: FieldRef<"JobListing", 'DateTime'>
    readonly isActive: FieldRef<"JobListing", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * JobListing findUnique
   */
  export type JobListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Filter, which JobListing to fetch.
     */
    where: JobListingWhereUniqueInput
  }

  /**
   * JobListing findUniqueOrThrow
   */
  export type JobListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Filter, which JobListing to fetch.
     */
    where: JobListingWhereUniqueInput
  }

  /**
   * JobListing findFirst
   */
  export type JobListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Filter, which JobListing to fetch.
     */
    where?: JobListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobListings to fetch.
     */
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobListings.
     */
    cursor?: JobListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobListings.
     */
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * JobListing findFirstOrThrow
   */
  export type JobListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Filter, which JobListing to fetch.
     */
    where?: JobListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobListings to fetch.
     */
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobListings.
     */
    cursor?: JobListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobListings.
     */
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * JobListing findMany
   */
  export type JobListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Filter, which JobListings to fetch.
     */
    where?: JobListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobListings to fetch.
     */
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobListings.
     */
    cursor?: JobListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobListings.
     */
    skip?: number
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * JobListing create
   */
  export type JobListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * The data needed to create a JobListing.
     */
    data: XOR<JobListingCreateInput, JobListingUncheckedCreateInput>
  }

  /**
   * JobListing createMany
   */
  export type JobListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobListings.
     */
    data: JobListingCreateManyInput | JobListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobListing createManyAndReturn
   */
  export type JobListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobListings.
     */
    data: JobListingCreateManyInput | JobListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobListing update
   */
  export type JobListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * The data needed to update a JobListing.
     */
    data: XOR<JobListingUpdateInput, JobListingUncheckedUpdateInput>
    /**
     * Choose, which JobListing to update.
     */
    where: JobListingWhereUniqueInput
  }

  /**
   * JobListing updateMany
   */
  export type JobListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobListings.
     */
    data: XOR<JobListingUpdateManyMutationInput, JobListingUncheckedUpdateManyInput>
    /**
     * Filter which JobListings to update
     */
    where?: JobListingWhereInput
  }

  /**
   * JobListing upsert
   */
  export type JobListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * The filter to search for the JobListing to update in case it exists.
     */
    where: JobListingWhereUniqueInput
    /**
     * In case the JobListing found by the `where` argument doesn't exist, create a new JobListing with this data.
     */
    create: XOR<JobListingCreateInput, JobListingUncheckedCreateInput>
    /**
     * In case the JobListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobListingUpdateInput, JobListingUncheckedUpdateInput>
  }

  /**
   * JobListing delete
   */
  export type JobListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Filter which JobListing to delete.
     */
    where: JobListingWhereUniqueInput
  }

  /**
   * JobListing deleteMany
   */
  export type JobListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobListings to delete
     */
    where?: JobListingWhereInput
  }

  /**
   * JobListing without action
   */
  export type JobListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    id: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    id: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    role: $Enums.TeamMemberRole | null
    description: string | null
    title: string | null
    imagePath: string | null
    email: string | null
    phoneNumber: string | null
    cvPath: string | null
    linkedinUrl: string | null
    twitterUrl: string | null
    facebookUrl: string | null
    createdAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    role: $Enums.TeamMemberRole | null
    description: string | null
    title: string | null
    imagePath: string | null
    email: string | null
    phoneNumber: string | null
    cvPath: string | null
    linkedinUrl: string | null
    twitterUrl: string | null
    facebookUrl: string | null
    createdAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    fullName: number
    role: number
    description: number
    title: number
    imagePath: number
    email: number
    phoneNumber: number
    cvPath: number
    linkedinUrl: number
    twitterUrl: number
    facebookUrl: number
    createdAt: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    id?: true
  }

  export type TeamMemberSumAggregateInputType = {
    id?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    fullName?: true
    role?: true
    description?: true
    title?: true
    imagePath?: true
    email?: true
    phoneNumber?: true
    cvPath?: true
    linkedinUrl?: true
    twitterUrl?: true
    facebookUrl?: true
    createdAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    fullName?: true
    role?: true
    description?: true
    title?: true
    imagePath?: true
    email?: true
    phoneNumber?: true
    cvPath?: true
    linkedinUrl?: true
    twitterUrl?: true
    facebookUrl?: true
    createdAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    fullName?: true
    role?: true
    description?: true
    title?: true
    imagePath?: true
    email?: true
    phoneNumber?: true
    cvPath?: true
    linkedinUrl?: true
    twitterUrl?: true
    facebookUrl?: true
    createdAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: number
    fullName: string
    role: $Enums.TeamMemberRole
    description: string
    title: string
    imagePath: string
    email: string | null
    phoneNumber: string | null
    cvPath: string | null
    linkedinUrl: string | null
    twitterUrl: string | null
    facebookUrl: string | null
    createdAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    role?: boolean
    description?: boolean
    title?: boolean
    imagePath?: boolean
    email?: boolean
    phoneNumber?: boolean
    cvPath?: boolean
    linkedinUrl?: boolean
    twitterUrl?: boolean
    facebookUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    role?: boolean
    description?: boolean
    title?: boolean
    imagePath?: boolean
    email?: boolean
    phoneNumber?: boolean
    cvPath?: boolean
    linkedinUrl?: boolean
    twitterUrl?: boolean
    facebookUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    fullName?: boolean
    role?: boolean
    description?: boolean
    title?: boolean
    imagePath?: boolean
    email?: boolean
    phoneNumber?: boolean
    cvPath?: boolean
    linkedinUrl?: boolean
    twitterUrl?: boolean
    facebookUrl?: boolean
    createdAt?: boolean
  }


  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      role: $Enums.TeamMemberRole
      description: string
      title: string
      imagePath: string
      email: string | null
      phoneNumber: string | null
      cvPath: string | null
      linkedinUrl: string | null
      twitterUrl: string | null
      facebookUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */ 
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'Int'>
    readonly fullName: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'TeamMemberRole'>
    readonly description: FieldRef<"TeamMember", 'String'>
    readonly title: FieldRef<"TeamMember", 'String'>
    readonly imagePath: FieldRef<"TeamMember", 'String'>
    readonly email: FieldRef<"TeamMember", 'String'>
    readonly phoneNumber: FieldRef<"TeamMember", 'String'>
    readonly cvPath: FieldRef<"TeamMember", 'String'>
    readonly linkedinUrl: FieldRef<"TeamMember", 'String'>
    readonly twitterUrl: FieldRef<"TeamMember", 'String'>
    readonly facebookUrl: FieldRef<"TeamMember", 'String'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
  }


  /**
   * Model FeaturedStudent
   */

  export type AggregateFeaturedStudent = {
    _count: FeaturedStudentCountAggregateOutputType | null
    _avg: FeaturedStudentAvgAggregateOutputType | null
    _sum: FeaturedStudentSumAggregateOutputType | null
    _min: FeaturedStudentMinAggregateOutputType | null
    _max: FeaturedStudentMaxAggregateOutputType | null
  }

  export type FeaturedStudentAvgAggregateOutputType = {
    id: number | null
    score: number | null
    studentProfileId: number | null
  }

  export type FeaturedStudentSumAggregateOutputType = {
    id: number | null
    score: number | null
    studentProfileId: number | null
  }

  export type FeaturedStudentMinAggregateOutputType = {
    id: number | null
    name: string | null
    surname: string | null
    email: string | null
    phoneNumber: string | null
    courseType: $Enums.CourseType | null
    score: number | null
    imagePath: string | null
    description: string | null
    graduationDate: Date | null
    isActive: boolean | null
    linkedinUrl: string | null
    testimonial: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentProfileId: number | null
  }

  export type FeaturedStudentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    surname: string | null
    email: string | null
    phoneNumber: string | null
    courseType: $Enums.CourseType | null
    score: number | null
    imagePath: string | null
    description: string | null
    graduationDate: Date | null
    isActive: boolean | null
    linkedinUrl: string | null
    testimonial: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentProfileId: number | null
  }

  export type FeaturedStudentCountAggregateOutputType = {
    id: number
    name: number
    surname: number
    email: number
    phoneNumber: number
    courseType: number
    score: number
    imagePath: number
    description: number
    achievements: number
    graduationDate: number
    isActive: number
    linkedinUrl: number
    testimonial: number
    createdAt: number
    updatedAt: number
    studentProfileId: number
    _all: number
  }


  export type FeaturedStudentAvgAggregateInputType = {
    id?: true
    score?: true
    studentProfileId?: true
  }

  export type FeaturedStudentSumAggregateInputType = {
    id?: true
    score?: true
    studentProfileId?: true
  }

  export type FeaturedStudentMinAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phoneNumber?: true
    courseType?: true
    score?: true
    imagePath?: true
    description?: true
    graduationDate?: true
    isActive?: true
    linkedinUrl?: true
    testimonial?: true
    createdAt?: true
    updatedAt?: true
    studentProfileId?: true
  }

  export type FeaturedStudentMaxAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phoneNumber?: true
    courseType?: true
    score?: true
    imagePath?: true
    description?: true
    graduationDate?: true
    isActive?: true
    linkedinUrl?: true
    testimonial?: true
    createdAt?: true
    updatedAt?: true
    studentProfileId?: true
  }

  export type FeaturedStudentCountAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phoneNumber?: true
    courseType?: true
    score?: true
    imagePath?: true
    description?: true
    achievements?: true
    graduationDate?: true
    isActive?: true
    linkedinUrl?: true
    testimonial?: true
    createdAt?: true
    updatedAt?: true
    studentProfileId?: true
    _all?: true
  }

  export type FeaturedStudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedStudent to aggregate.
     */
    where?: FeaturedStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedStudents to fetch.
     */
    orderBy?: FeaturedStudentOrderByWithRelationInput | FeaturedStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedStudents
    **/
    _count?: true | FeaturedStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeaturedStudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeaturedStudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedStudentMaxAggregateInputType
  }

  export type GetFeaturedStudentAggregateType<T extends FeaturedStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedStudent[P]>
      : GetScalarType<T[P], AggregateFeaturedStudent[P]>
  }




  export type FeaturedStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedStudentWhereInput
    orderBy?: FeaturedStudentOrderByWithAggregationInput | FeaturedStudentOrderByWithAggregationInput[]
    by: FeaturedStudentScalarFieldEnum[] | FeaturedStudentScalarFieldEnum
    having?: FeaturedStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedStudentCountAggregateInputType | true
    _avg?: FeaturedStudentAvgAggregateInputType
    _sum?: FeaturedStudentSumAggregateInputType
    _min?: FeaturedStudentMinAggregateInputType
    _max?: FeaturedStudentMaxAggregateInputType
  }

  export type FeaturedStudentGroupByOutputType = {
    id: number
    name: string
    surname: string
    email: string
    phoneNumber: string | null
    courseType: $Enums.CourseType
    score: number
    imagePath: string | null
    description: string
    achievements: string[]
    graduationDate: Date
    isActive: boolean
    linkedinUrl: string | null
    testimonial: string | null
    createdAt: Date
    updatedAt: Date
    studentProfileId: number | null
    _count: FeaturedStudentCountAggregateOutputType | null
    _avg: FeaturedStudentAvgAggregateOutputType | null
    _sum: FeaturedStudentSumAggregateOutputType | null
    _min: FeaturedStudentMinAggregateOutputType | null
    _max: FeaturedStudentMaxAggregateOutputType | null
  }

  type GetFeaturedStudentGroupByPayload<T extends FeaturedStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedStudentGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedStudentGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phoneNumber?: boolean
    courseType?: boolean
    score?: boolean
    imagePath?: boolean
    description?: boolean
    achievements?: boolean
    graduationDate?: boolean
    isActive?: boolean
    linkedinUrl?: boolean
    testimonial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfileId?: boolean
    studentProfile?: boolean | FeaturedStudent$studentProfileArgs<ExtArgs>
    trainingReviews?: boolean | FeaturedStudent$trainingReviewsArgs<ExtArgs>
    _count?: boolean | FeaturedStudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredStudent"]>

  export type FeaturedStudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phoneNumber?: boolean
    courseType?: boolean
    score?: boolean
    imagePath?: boolean
    description?: boolean
    achievements?: boolean
    graduationDate?: boolean
    isActive?: boolean
    linkedinUrl?: boolean
    testimonial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfileId?: boolean
    studentProfile?: boolean | FeaturedStudent$studentProfileArgs<ExtArgs>
  }, ExtArgs["result"]["featuredStudent"]>

  export type FeaturedStudentSelectScalar = {
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phoneNumber?: boolean
    courseType?: boolean
    score?: boolean
    imagePath?: boolean
    description?: boolean
    achievements?: boolean
    graduationDate?: boolean
    isActive?: boolean
    linkedinUrl?: boolean
    testimonial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfileId?: boolean
  }

  export type FeaturedStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | FeaturedStudent$studentProfileArgs<ExtArgs>
    trainingReviews?: boolean | FeaturedStudent$trainingReviewsArgs<ExtArgs>
    _count?: boolean | FeaturedStudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeaturedStudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | FeaturedStudent$studentProfileArgs<ExtArgs>
  }

  export type $FeaturedStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedStudent"
    objects: {
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs> | null
      trainingReviews: Prisma.$TrainingReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      surname: string
      email: string
      phoneNumber: string | null
      courseType: $Enums.CourseType
      score: number
      imagePath: string | null
      description: string
      achievements: string[]
      graduationDate: Date
      isActive: boolean
      linkedinUrl: string | null
      testimonial: string | null
      createdAt: Date
      updatedAt: Date
      studentProfileId: number | null
    }, ExtArgs["result"]["featuredStudent"]>
    composites: {}
  }

  type FeaturedStudentGetPayload<S extends boolean | null | undefined | FeaturedStudentDefaultArgs> = $Result.GetResult<Prisma.$FeaturedStudentPayload, S>

  type FeaturedStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeaturedStudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeaturedStudentCountAggregateInputType | true
    }

  export interface FeaturedStudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedStudent'], meta: { name: 'FeaturedStudent' } }
    /**
     * Find zero or one FeaturedStudent that matches the filter.
     * @param {FeaturedStudentFindUniqueArgs} args - Arguments to find a FeaturedStudent
     * @example
     * // Get one FeaturedStudent
     * const featuredStudent = await prisma.featuredStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedStudentFindUniqueArgs>(args: SelectSubset<T, FeaturedStudentFindUniqueArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeaturedStudent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeaturedStudentFindUniqueOrThrowArgs} args - Arguments to find a FeaturedStudent
     * @example
     * // Get one FeaturedStudent
     * const featuredStudent = await prisma.featuredStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedStudentFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedStudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeaturedStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedStudentFindFirstArgs} args - Arguments to find a FeaturedStudent
     * @example
     * // Get one FeaturedStudent
     * const featuredStudent = await prisma.featuredStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedStudentFindFirstArgs>(args?: SelectSubset<T, FeaturedStudentFindFirstArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeaturedStudent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedStudentFindFirstOrThrowArgs} args - Arguments to find a FeaturedStudent
     * @example
     * // Get one FeaturedStudent
     * const featuredStudent = await prisma.featuredStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedStudentFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedStudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeaturedStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedStudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedStudents
     * const featuredStudents = await prisma.featuredStudent.findMany()
     * 
     * // Get first 10 FeaturedStudents
     * const featuredStudents = await prisma.featuredStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredStudentWithIdOnly = await prisma.featuredStudent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedStudentFindManyArgs>(args?: SelectSubset<T, FeaturedStudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeaturedStudent.
     * @param {FeaturedStudentCreateArgs} args - Arguments to create a FeaturedStudent.
     * @example
     * // Create one FeaturedStudent
     * const FeaturedStudent = await prisma.featuredStudent.create({
     *   data: {
     *     // ... data to create a FeaturedStudent
     *   }
     * })
     * 
     */
    create<T extends FeaturedStudentCreateArgs>(args: SelectSubset<T, FeaturedStudentCreateArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeaturedStudents.
     * @param {FeaturedStudentCreateManyArgs} args - Arguments to create many FeaturedStudents.
     * @example
     * // Create many FeaturedStudents
     * const featuredStudent = await prisma.featuredStudent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedStudentCreateManyArgs>(args?: SelectSubset<T, FeaturedStudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedStudents and returns the data saved in the database.
     * @param {FeaturedStudentCreateManyAndReturnArgs} args - Arguments to create many FeaturedStudents.
     * @example
     * // Create many FeaturedStudents
     * const featuredStudent = await prisma.featuredStudent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedStudents and only return the `id`
     * const featuredStudentWithIdOnly = await prisma.featuredStudent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedStudentCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedStudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeaturedStudent.
     * @param {FeaturedStudentDeleteArgs} args - Arguments to delete one FeaturedStudent.
     * @example
     * // Delete one FeaturedStudent
     * const FeaturedStudent = await prisma.featuredStudent.delete({
     *   where: {
     *     // ... filter to delete one FeaturedStudent
     *   }
     * })
     * 
     */
    delete<T extends FeaturedStudentDeleteArgs>(args: SelectSubset<T, FeaturedStudentDeleteArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeaturedStudent.
     * @param {FeaturedStudentUpdateArgs} args - Arguments to update one FeaturedStudent.
     * @example
     * // Update one FeaturedStudent
     * const featuredStudent = await prisma.featuredStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedStudentUpdateArgs>(args: SelectSubset<T, FeaturedStudentUpdateArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeaturedStudents.
     * @param {FeaturedStudentDeleteManyArgs} args - Arguments to filter FeaturedStudents to delete.
     * @example
     * // Delete a few FeaturedStudents
     * const { count } = await prisma.featuredStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedStudentDeleteManyArgs>(args?: SelectSubset<T, FeaturedStudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedStudents
     * const featuredStudent = await prisma.featuredStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedStudentUpdateManyArgs>(args: SelectSubset<T, FeaturedStudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeaturedStudent.
     * @param {FeaturedStudentUpsertArgs} args - Arguments to update or create a FeaturedStudent.
     * @example
     * // Update or create a FeaturedStudent
     * const featuredStudent = await prisma.featuredStudent.upsert({
     *   create: {
     *     // ... data to create a FeaturedStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedStudent we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedStudentUpsertArgs>(args: SelectSubset<T, FeaturedStudentUpsertArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeaturedStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedStudentCountArgs} args - Arguments to filter FeaturedStudents to count.
     * @example
     * // Count the number of FeaturedStudents
     * const count = await prisma.featuredStudent.count({
     *   where: {
     *     // ... the filter for the FeaturedStudents we want to count
     *   }
     * })
    **/
    count<T extends FeaturedStudentCountArgs>(
      args?: Subset<T, FeaturedStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedStudentAggregateArgs>(args: Subset<T, FeaturedStudentAggregateArgs>): Prisma.PrismaPromise<GetFeaturedStudentAggregateType<T>>

    /**
     * Group by FeaturedStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedStudentGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedStudent model
   */
  readonly fields: FeaturedStudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedStudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentProfile<T extends FeaturedStudent$studentProfileArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedStudent$studentProfileArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    trainingReviews<T extends FeaturedStudent$trainingReviewsArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedStudent$trainingReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedStudent model
   */ 
  interface FeaturedStudentFieldRefs {
    readonly id: FieldRef<"FeaturedStudent", 'Int'>
    readonly name: FieldRef<"FeaturedStudent", 'String'>
    readonly surname: FieldRef<"FeaturedStudent", 'String'>
    readonly email: FieldRef<"FeaturedStudent", 'String'>
    readonly phoneNumber: FieldRef<"FeaturedStudent", 'String'>
    readonly courseType: FieldRef<"FeaturedStudent", 'CourseType'>
    readonly score: FieldRef<"FeaturedStudent", 'Int'>
    readonly imagePath: FieldRef<"FeaturedStudent", 'String'>
    readonly description: FieldRef<"FeaturedStudent", 'String'>
    readonly achievements: FieldRef<"FeaturedStudent", 'String[]'>
    readonly graduationDate: FieldRef<"FeaturedStudent", 'DateTime'>
    readonly isActive: FieldRef<"FeaturedStudent", 'Boolean'>
    readonly linkedinUrl: FieldRef<"FeaturedStudent", 'String'>
    readonly testimonial: FieldRef<"FeaturedStudent", 'String'>
    readonly createdAt: FieldRef<"FeaturedStudent", 'DateTime'>
    readonly updatedAt: FieldRef<"FeaturedStudent", 'DateTime'>
    readonly studentProfileId: FieldRef<"FeaturedStudent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedStudent findUnique
   */
  export type FeaturedStudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedStudent to fetch.
     */
    where: FeaturedStudentWhereUniqueInput
  }

  /**
   * FeaturedStudent findUniqueOrThrow
   */
  export type FeaturedStudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedStudent to fetch.
     */
    where: FeaturedStudentWhereUniqueInput
  }

  /**
   * FeaturedStudent findFirst
   */
  export type FeaturedStudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedStudent to fetch.
     */
    where?: FeaturedStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedStudents to fetch.
     */
    orderBy?: FeaturedStudentOrderByWithRelationInput | FeaturedStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedStudents.
     */
    cursor?: FeaturedStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedStudents.
     */
    distinct?: FeaturedStudentScalarFieldEnum | FeaturedStudentScalarFieldEnum[]
  }

  /**
   * FeaturedStudent findFirstOrThrow
   */
  export type FeaturedStudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedStudent to fetch.
     */
    where?: FeaturedStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedStudents to fetch.
     */
    orderBy?: FeaturedStudentOrderByWithRelationInput | FeaturedStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedStudents.
     */
    cursor?: FeaturedStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedStudents.
     */
    distinct?: FeaturedStudentScalarFieldEnum | FeaturedStudentScalarFieldEnum[]
  }

  /**
   * FeaturedStudent findMany
   */
  export type FeaturedStudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedStudents to fetch.
     */
    where?: FeaturedStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedStudents to fetch.
     */
    orderBy?: FeaturedStudentOrderByWithRelationInput | FeaturedStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedStudents.
     */
    cursor?: FeaturedStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedStudents.
     */
    skip?: number
    distinct?: FeaturedStudentScalarFieldEnum | FeaturedStudentScalarFieldEnum[]
  }

  /**
   * FeaturedStudent create
   */
  export type FeaturedStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedStudent.
     */
    data: XOR<FeaturedStudentCreateInput, FeaturedStudentUncheckedCreateInput>
  }

  /**
   * FeaturedStudent createMany
   */
  export type FeaturedStudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedStudents.
     */
    data: FeaturedStudentCreateManyInput | FeaturedStudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedStudent createManyAndReturn
   */
  export type FeaturedStudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeaturedStudents.
     */
    data: FeaturedStudentCreateManyInput | FeaturedStudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedStudent update
   */
  export type FeaturedStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedStudent.
     */
    data: XOR<FeaturedStudentUpdateInput, FeaturedStudentUncheckedUpdateInput>
    /**
     * Choose, which FeaturedStudent to update.
     */
    where: FeaturedStudentWhereUniqueInput
  }

  /**
   * FeaturedStudent updateMany
   */
  export type FeaturedStudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedStudents.
     */
    data: XOR<FeaturedStudentUpdateManyMutationInput, FeaturedStudentUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedStudents to update
     */
    where?: FeaturedStudentWhereInput
  }

  /**
   * FeaturedStudent upsert
   */
  export type FeaturedStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedStudent to update in case it exists.
     */
    where: FeaturedStudentWhereUniqueInput
    /**
     * In case the FeaturedStudent found by the `where` argument doesn't exist, create a new FeaturedStudent with this data.
     */
    create: XOR<FeaturedStudentCreateInput, FeaturedStudentUncheckedCreateInput>
    /**
     * In case the FeaturedStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedStudentUpdateInput, FeaturedStudentUncheckedUpdateInput>
  }

  /**
   * FeaturedStudent delete
   */
  export type FeaturedStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    /**
     * Filter which FeaturedStudent to delete.
     */
    where: FeaturedStudentWhereUniqueInput
  }

  /**
   * FeaturedStudent deleteMany
   */
  export type FeaturedStudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedStudents to delete
     */
    where?: FeaturedStudentWhereInput
  }

  /**
   * FeaturedStudent.studentProfile
   */
  export type FeaturedStudent$studentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
  }

  /**
   * FeaturedStudent.trainingReviews
   */
  export type FeaturedStudent$trainingReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    where?: TrainingReviewWhereInput
    orderBy?: TrainingReviewOrderByWithRelationInput | TrainingReviewOrderByWithRelationInput[]
    cursor?: TrainingReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingReviewScalarFieldEnum | TrainingReviewScalarFieldEnum[]
  }

  /**
   * FeaturedStudent without action
   */
  export type FeaturedStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
  }


  /**
   * Model Training
   */

  export type AggregateTraining = {
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  export type TrainingAvgAggregateOutputType = {
    id: number | null
    totalHours: number | null
    maxParticipants: number | null
  }

  export type TrainingSumAggregateOutputType = {
    id: number | null
    totalHours: number | null
    maxParticipants: number | null
  }

  export type TrainingMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    level: string | null
    instructor: string | null
    totalHours: number | null
    startDate: Date | null
    endDate: Date | null
    maxParticipants: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    category: string | null
    level: string | null
    instructor: string | null
    totalHours: number | null
    startDate: Date | null
    endDate: Date | null
    maxParticipants: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    level: number
    instructor: number
    totalHours: number
    startDate: number
    endDate: number
    maxParticipants: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingAvgAggregateInputType = {
    id?: true
    totalHours?: true
    maxParticipants?: true
  }

  export type TrainingSumAggregateInputType = {
    id?: true
    totalHours?: true
    maxParticipants?: true
  }

  export type TrainingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    level?: true
    instructor?: true
    totalHours?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    level?: true
    instructor?: true
    totalHours?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    level?: true
    instructor?: true
    totalHours?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Training to aggregate.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trainings
    **/
    _count?: true | TrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingMaxAggregateInputType
  }

  export type GetTrainingAggregateType<T extends TrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraining[P]>
      : GetScalarType<T[P], AggregateTraining[P]>
  }




  export type TrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithAggregationInput | TrainingOrderByWithAggregationInput[]
    by: TrainingScalarFieldEnum[] | TrainingScalarFieldEnum
    having?: TrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingCountAggregateInputType | true
    _avg?: TrainingAvgAggregateInputType
    _sum?: TrainingSumAggregateInputType
    _min?: TrainingMinAggregateInputType
    _max?: TrainingMaxAggregateInputType
  }

  export type TrainingGroupByOutputType = {
    id: number
    title: string
    description: string | null
    category: string
    level: string
    instructor: string
    totalHours: number
    startDate: Date
    endDate: Date
    maxParticipants: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  type GetTrainingGroupByPayload<T extends TrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    level?: boolean
    instructor?: boolean
    totalHours?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollments?: boolean | Training$enrollmentsArgs<ExtArgs>
    reviews?: boolean | Training$reviewsArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    level?: boolean
    instructor?: boolean
    totalHours?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    level?: boolean
    instructor?: boolean
    totalHours?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | Training$enrollmentsArgs<ExtArgs>
    reviews?: boolean | Training$reviewsArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Training"
    objects: {
      enrollments: Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>[]
      reviews: Prisma.$TrainingReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      category: string
      level: string
      instructor: string
      totalHours: number
      startDate: Date
      endDate: Date
      maxParticipants: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["training"]>
    composites: {}
  }

  type TrainingGetPayload<S extends boolean | null | undefined | TrainingDefaultArgs> = $Result.GetResult<Prisma.$TrainingPayload, S>

  type TrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingCountAggregateInputType | true
    }

  export interface TrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Training'], meta: { name: 'Training' } }
    /**
     * Find zero or one Training that matches the filter.
     * @param {TrainingFindUniqueArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingFindUniqueArgs>(args: SelectSubset<T, TrainingFindUniqueArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Training that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingFindUniqueOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Training that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingFindFirstArgs>(args?: SelectSubset<T, TrainingFindFirstArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Training that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings
     * const trainings = await prisma.training.findMany()
     * 
     * // Get first 10 Trainings
     * const trainings = await prisma.training.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingWithIdOnly = await prisma.training.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingFindManyArgs>(args?: SelectSubset<T, TrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Training.
     * @param {TrainingCreateArgs} args - Arguments to create a Training.
     * @example
     * // Create one Training
     * const Training = await prisma.training.create({
     *   data: {
     *     // ... data to create a Training
     *   }
     * })
     * 
     */
    create<T extends TrainingCreateArgs>(args: SelectSubset<T, TrainingCreateArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trainings.
     * @param {TrainingCreateManyArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const training = await prisma.training.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingCreateManyArgs>(args?: SelectSubset<T, TrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trainings and returns the data saved in the database.
     * @param {TrainingCreateManyAndReturnArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const training = await prisma.training.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trainings and only return the `id`
     * const trainingWithIdOnly = await prisma.training.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Training.
     * @param {TrainingDeleteArgs} args - Arguments to delete one Training.
     * @example
     * // Delete one Training
     * const Training = await prisma.training.delete({
     *   where: {
     *     // ... filter to delete one Training
     *   }
     * })
     * 
     */
    delete<T extends TrainingDeleteArgs>(args: SelectSubset<T, TrainingDeleteArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Training.
     * @param {TrainingUpdateArgs} args - Arguments to update one Training.
     * @example
     * // Update one Training
     * const training = await prisma.training.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingUpdateArgs>(args: SelectSubset<T, TrainingUpdateArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trainings.
     * @param {TrainingDeleteManyArgs} args - Arguments to filter Trainings to delete.
     * @example
     * // Delete a few Trainings
     * const { count } = await prisma.training.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDeleteManyArgs>(args?: SelectSubset<T, TrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings
     * const training = await prisma.training.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingUpdateManyArgs>(args: SelectSubset<T, TrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Training.
     * @param {TrainingUpsertArgs} args - Arguments to update or create a Training.
     * @example
     * // Update or create a Training
     * const training = await prisma.training.upsert({
     *   create: {
     *     // ... data to create a Training
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Training we want to update
     *   }
     * })
     */
    upsert<T extends TrainingUpsertArgs>(args: SelectSubset<T, TrainingUpsertArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCountArgs} args - Arguments to filter Trainings to count.
     * @example
     * // Count the number of Trainings
     * const count = await prisma.training.count({
     *   where: {
     *     // ... the filter for the Trainings we want to count
     *   }
     * })
    **/
    count<T extends TrainingCountArgs>(
      args?: Subset<T, TrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingAggregateArgs>(args: Subset<T, TrainingAggregateArgs>): Prisma.PrismaPromise<GetTrainingAggregateType<T>>

    /**
     * Group by Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingGroupByArgs['orderBy'] }
        : { orderBy?: TrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Training model
   */
  readonly fields: TrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollments<T extends Training$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Training$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Training$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Training$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Training model
   */ 
  interface TrainingFieldRefs {
    readonly id: FieldRef<"Training", 'Int'>
    readonly title: FieldRef<"Training", 'String'>
    readonly description: FieldRef<"Training", 'String'>
    readonly category: FieldRef<"Training", 'String'>
    readonly level: FieldRef<"Training", 'String'>
    readonly instructor: FieldRef<"Training", 'String'>
    readonly totalHours: FieldRef<"Training", 'Int'>
    readonly startDate: FieldRef<"Training", 'DateTime'>
    readonly endDate: FieldRef<"Training", 'DateTime'>
    readonly maxParticipants: FieldRef<"Training", 'Int'>
    readonly isActive: FieldRef<"Training", 'Boolean'>
    readonly createdAt: FieldRef<"Training", 'DateTime'>
    readonly updatedAt: FieldRef<"Training", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Training findUnique
   */
  export type TrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training findUniqueOrThrow
   */
  export type TrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training findFirst
   */
  export type TrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training findFirstOrThrow
   */
  export type TrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training findMany
   */
  export type TrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Trainings to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training create
   */
  export type TrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a Training.
     */
    data: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
  }

  /**
   * Training createMany
   */
  export type TrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Training createManyAndReturn
   */
  export type TrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Training update
   */
  export type TrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a Training.
     */
    data: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
    /**
     * Choose, which Training to update.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training updateMany
   */
  export type TrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trainings.
     */
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyInput>
    /**
     * Filter which Trainings to update
     */
    where?: TrainingWhereInput
  }

  /**
   * Training upsert
   */
  export type TrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the Training to update in case it exists.
     */
    where: TrainingWhereUniqueInput
    /**
     * In case the Training found by the `where` argument doesn't exist, create a new Training with this data.
     */
    create: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
    /**
     * In case the Training was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
  }

  /**
   * Training delete
   */
  export type TrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter which Training to delete.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training deleteMany
   */
  export type TrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trainings to delete
     */
    where?: TrainingWhereInput
  }

  /**
   * Training.enrollments
   */
  export type Training$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    where?: StudentTrainingEnrollmentWhereInput
    orderBy?: StudentTrainingEnrollmentOrderByWithRelationInput | StudentTrainingEnrollmentOrderByWithRelationInput[]
    cursor?: StudentTrainingEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTrainingEnrollmentScalarFieldEnum | StudentTrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * Training.reviews
   */
  export type Training$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    where?: TrainingReviewWhereInput
    orderBy?: TrainingReviewOrderByWithRelationInput | TrainingReviewOrderByWithRelationInput[]
    cursor?: TrainingReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingReviewScalarFieldEnum | TrainingReviewScalarFieldEnum[]
  }

  /**
   * Training without action
   */
  export type TrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
  }


  /**
   * Model StudentTrainingEnrollment
   */

  export type AggregateStudentTrainingEnrollment = {
    _count: StudentTrainingEnrollmentCountAggregateOutputType | null
    _avg: StudentTrainingEnrollmentAvgAggregateOutputType | null
    _sum: StudentTrainingEnrollmentSumAggregateOutputType | null
    _min: StudentTrainingEnrollmentMinAggregateOutputType | null
    _max: StudentTrainingEnrollmentMaxAggregateOutputType | null
  }

  export type StudentTrainingEnrollmentAvgAggregateOutputType = {
    id: number | null
    trainingId: number | null
    profileId: number | null
    progress: number | null
    attendance: number | null
    grade: number | null
  }

  export type StudentTrainingEnrollmentSumAggregateOutputType = {
    id: number | null
    trainingId: number | null
    profileId: number | null
    progress: number | null
    attendance: number | null
    grade: number | null
  }

  export type StudentTrainingEnrollmentMinAggregateOutputType = {
    id: number | null
    trainingId: number | null
    profileId: number | null
    enrollmentDate: Date | null
    status: $Enums.TrainingStatus | null
    progress: number | null
    completionDate: Date | null
    certificateUrl: string | null
    attendance: number | null
    grade: number | null
    feedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentTrainingEnrollmentMaxAggregateOutputType = {
    id: number | null
    trainingId: number | null
    profileId: number | null
    enrollmentDate: Date | null
    status: $Enums.TrainingStatus | null
    progress: number | null
    completionDate: Date | null
    certificateUrl: string | null
    attendance: number | null
    grade: number | null
    feedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentTrainingEnrollmentCountAggregateOutputType = {
    id: number
    trainingId: number
    profileId: number
    enrollmentDate: number
    status: number
    progress: number
    completionDate: number
    certificateUrl: number
    attendance: number
    grade: number
    feedback: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentTrainingEnrollmentAvgAggregateInputType = {
    id?: true
    trainingId?: true
    profileId?: true
    progress?: true
    attendance?: true
    grade?: true
  }

  export type StudentTrainingEnrollmentSumAggregateInputType = {
    id?: true
    trainingId?: true
    profileId?: true
    progress?: true
    attendance?: true
    grade?: true
  }

  export type StudentTrainingEnrollmentMinAggregateInputType = {
    id?: true
    trainingId?: true
    profileId?: true
    enrollmentDate?: true
    status?: true
    progress?: true
    completionDate?: true
    certificateUrl?: true
    attendance?: true
    grade?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentTrainingEnrollmentMaxAggregateInputType = {
    id?: true
    trainingId?: true
    profileId?: true
    enrollmentDate?: true
    status?: true
    progress?: true
    completionDate?: true
    certificateUrl?: true
    attendance?: true
    grade?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentTrainingEnrollmentCountAggregateInputType = {
    id?: true
    trainingId?: true
    profileId?: true
    enrollmentDate?: true
    status?: true
    progress?: true
    completionDate?: true
    certificateUrl?: true
    attendance?: true
    grade?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentTrainingEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTrainingEnrollment to aggregate.
     */
    where?: StudentTrainingEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTrainingEnrollments to fetch.
     */
    orderBy?: StudentTrainingEnrollmentOrderByWithRelationInput | StudentTrainingEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTrainingEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTrainingEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTrainingEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTrainingEnrollments
    **/
    _count?: true | StudentTrainingEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTrainingEnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTrainingEnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTrainingEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTrainingEnrollmentMaxAggregateInputType
  }

  export type GetStudentTrainingEnrollmentAggregateType<T extends StudentTrainingEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTrainingEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTrainingEnrollment[P]>
      : GetScalarType<T[P], AggregateStudentTrainingEnrollment[P]>
  }




  export type StudentTrainingEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTrainingEnrollmentWhereInput
    orderBy?: StudentTrainingEnrollmentOrderByWithAggregationInput | StudentTrainingEnrollmentOrderByWithAggregationInput[]
    by: StudentTrainingEnrollmentScalarFieldEnum[] | StudentTrainingEnrollmentScalarFieldEnum
    having?: StudentTrainingEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTrainingEnrollmentCountAggregateInputType | true
    _avg?: StudentTrainingEnrollmentAvgAggregateInputType
    _sum?: StudentTrainingEnrollmentSumAggregateInputType
    _min?: StudentTrainingEnrollmentMinAggregateInputType
    _max?: StudentTrainingEnrollmentMaxAggregateInputType
  }

  export type StudentTrainingEnrollmentGroupByOutputType = {
    id: number
    trainingId: number
    profileId: number
    enrollmentDate: Date
    status: $Enums.TrainingStatus
    progress: number
    completionDate: Date | null
    certificateUrl: string | null
    attendance: number
    grade: number | null
    feedback: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentTrainingEnrollmentCountAggregateOutputType | null
    _avg: StudentTrainingEnrollmentAvgAggregateOutputType | null
    _sum: StudentTrainingEnrollmentSumAggregateOutputType | null
    _min: StudentTrainingEnrollmentMinAggregateOutputType | null
    _max: StudentTrainingEnrollmentMaxAggregateOutputType | null
  }

  type GetStudentTrainingEnrollmentGroupByPayload<T extends StudentTrainingEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTrainingEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTrainingEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTrainingEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTrainingEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type StudentTrainingEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    profileId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    progress?: boolean
    completionDate?: boolean
    certificateUrl?: boolean
    attendance?: boolean
    grade?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTrainingEnrollment"]>

  export type StudentTrainingEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    profileId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    progress?: boolean
    completionDate?: boolean
    certificateUrl?: boolean
    attendance?: boolean
    grade?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTrainingEnrollment"]>

  export type StudentTrainingEnrollmentSelectScalar = {
    id?: boolean
    trainingId?: boolean
    profileId?: boolean
    enrollmentDate?: boolean
    status?: boolean
    progress?: boolean
    completionDate?: boolean
    certificateUrl?: boolean
    attendance?: boolean
    grade?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentTrainingEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type StudentTrainingEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $StudentTrainingEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTrainingEnrollment"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      profile: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      trainingId: number
      profileId: number
      enrollmentDate: Date
      status: $Enums.TrainingStatus
      progress: number
      completionDate: Date | null
      certificateUrl: string | null
      attendance: number
      grade: number | null
      feedback: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentTrainingEnrollment"]>
    composites: {}
  }

  type StudentTrainingEnrollmentGetPayload<S extends boolean | null | undefined | StudentTrainingEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload, S>

  type StudentTrainingEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentTrainingEnrollmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentTrainingEnrollmentCountAggregateInputType | true
    }

  export interface StudentTrainingEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTrainingEnrollment'], meta: { name: 'StudentTrainingEnrollment' } }
    /**
     * Find zero or one StudentTrainingEnrollment that matches the filter.
     * @param {StudentTrainingEnrollmentFindUniqueArgs} args - Arguments to find a StudentTrainingEnrollment
     * @example
     * // Get one StudentTrainingEnrollment
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTrainingEnrollmentFindUniqueArgs>(args: SelectSubset<T, StudentTrainingEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__StudentTrainingEnrollmentClient<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentTrainingEnrollment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentTrainingEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a StudentTrainingEnrollment
     * @example
     * // Get one StudentTrainingEnrollment
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTrainingEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTrainingEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTrainingEnrollmentClient<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentTrainingEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingEnrollmentFindFirstArgs} args - Arguments to find a StudentTrainingEnrollment
     * @example
     * // Get one StudentTrainingEnrollment
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTrainingEnrollmentFindFirstArgs>(args?: SelectSubset<T, StudentTrainingEnrollmentFindFirstArgs<ExtArgs>>): Prisma__StudentTrainingEnrollmentClient<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentTrainingEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingEnrollmentFindFirstOrThrowArgs} args - Arguments to find a StudentTrainingEnrollment
     * @example
     * // Get one StudentTrainingEnrollment
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTrainingEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTrainingEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTrainingEnrollmentClient<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentTrainingEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTrainingEnrollments
     * const studentTrainingEnrollments = await prisma.studentTrainingEnrollment.findMany()
     * 
     * // Get first 10 StudentTrainingEnrollments
     * const studentTrainingEnrollments = await prisma.studentTrainingEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTrainingEnrollmentWithIdOnly = await prisma.studentTrainingEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTrainingEnrollmentFindManyArgs>(args?: SelectSubset<T, StudentTrainingEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentTrainingEnrollment.
     * @param {StudentTrainingEnrollmentCreateArgs} args - Arguments to create a StudentTrainingEnrollment.
     * @example
     * // Create one StudentTrainingEnrollment
     * const StudentTrainingEnrollment = await prisma.studentTrainingEnrollment.create({
     *   data: {
     *     // ... data to create a StudentTrainingEnrollment
     *   }
     * })
     * 
     */
    create<T extends StudentTrainingEnrollmentCreateArgs>(args: SelectSubset<T, StudentTrainingEnrollmentCreateArgs<ExtArgs>>): Prisma__StudentTrainingEnrollmentClient<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentTrainingEnrollments.
     * @param {StudentTrainingEnrollmentCreateManyArgs} args - Arguments to create many StudentTrainingEnrollments.
     * @example
     * // Create many StudentTrainingEnrollments
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTrainingEnrollmentCreateManyArgs>(args?: SelectSubset<T, StudentTrainingEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTrainingEnrollments and returns the data saved in the database.
     * @param {StudentTrainingEnrollmentCreateManyAndReturnArgs} args - Arguments to create many StudentTrainingEnrollments.
     * @example
     * // Create many StudentTrainingEnrollments
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTrainingEnrollments and only return the `id`
     * const studentTrainingEnrollmentWithIdOnly = await prisma.studentTrainingEnrollment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTrainingEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTrainingEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentTrainingEnrollment.
     * @param {StudentTrainingEnrollmentDeleteArgs} args - Arguments to delete one StudentTrainingEnrollment.
     * @example
     * // Delete one StudentTrainingEnrollment
     * const StudentTrainingEnrollment = await prisma.studentTrainingEnrollment.delete({
     *   where: {
     *     // ... filter to delete one StudentTrainingEnrollment
     *   }
     * })
     * 
     */
    delete<T extends StudentTrainingEnrollmentDeleteArgs>(args: SelectSubset<T, StudentTrainingEnrollmentDeleteArgs<ExtArgs>>): Prisma__StudentTrainingEnrollmentClient<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentTrainingEnrollment.
     * @param {StudentTrainingEnrollmentUpdateArgs} args - Arguments to update one StudentTrainingEnrollment.
     * @example
     * // Update one StudentTrainingEnrollment
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTrainingEnrollmentUpdateArgs>(args: SelectSubset<T, StudentTrainingEnrollmentUpdateArgs<ExtArgs>>): Prisma__StudentTrainingEnrollmentClient<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentTrainingEnrollments.
     * @param {StudentTrainingEnrollmentDeleteManyArgs} args - Arguments to filter StudentTrainingEnrollments to delete.
     * @example
     * // Delete a few StudentTrainingEnrollments
     * const { count } = await prisma.studentTrainingEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTrainingEnrollmentDeleteManyArgs>(args?: SelectSubset<T, StudentTrainingEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTrainingEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTrainingEnrollments
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTrainingEnrollmentUpdateManyArgs>(args: SelectSubset<T, StudentTrainingEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentTrainingEnrollment.
     * @param {StudentTrainingEnrollmentUpsertArgs} args - Arguments to update or create a StudentTrainingEnrollment.
     * @example
     * // Update or create a StudentTrainingEnrollment
     * const studentTrainingEnrollment = await prisma.studentTrainingEnrollment.upsert({
     *   create: {
     *     // ... data to create a StudentTrainingEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTrainingEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends StudentTrainingEnrollmentUpsertArgs>(args: SelectSubset<T, StudentTrainingEnrollmentUpsertArgs<ExtArgs>>): Prisma__StudentTrainingEnrollmentClient<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentTrainingEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingEnrollmentCountArgs} args - Arguments to filter StudentTrainingEnrollments to count.
     * @example
     * // Count the number of StudentTrainingEnrollments
     * const count = await prisma.studentTrainingEnrollment.count({
     *   where: {
     *     // ... the filter for the StudentTrainingEnrollments we want to count
     *   }
     * })
    **/
    count<T extends StudentTrainingEnrollmentCountArgs>(
      args?: Subset<T, StudentTrainingEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTrainingEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTrainingEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTrainingEnrollmentAggregateArgs>(args: Subset<T, StudentTrainingEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetStudentTrainingEnrollmentAggregateType<T>>

    /**
     * Group by StudentTrainingEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTrainingEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTrainingEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: StudentTrainingEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTrainingEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTrainingEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTrainingEnrollment model
   */
  readonly fields: StudentTrainingEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTrainingEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTrainingEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTrainingEnrollment model
   */ 
  interface StudentTrainingEnrollmentFieldRefs {
    readonly id: FieldRef<"StudentTrainingEnrollment", 'Int'>
    readonly trainingId: FieldRef<"StudentTrainingEnrollment", 'Int'>
    readonly profileId: FieldRef<"StudentTrainingEnrollment", 'Int'>
    readonly enrollmentDate: FieldRef<"StudentTrainingEnrollment", 'DateTime'>
    readonly status: FieldRef<"StudentTrainingEnrollment", 'TrainingStatus'>
    readonly progress: FieldRef<"StudentTrainingEnrollment", 'Int'>
    readonly completionDate: FieldRef<"StudentTrainingEnrollment", 'DateTime'>
    readonly certificateUrl: FieldRef<"StudentTrainingEnrollment", 'String'>
    readonly attendance: FieldRef<"StudentTrainingEnrollment", 'Int'>
    readonly grade: FieldRef<"StudentTrainingEnrollment", 'Float'>
    readonly feedback: FieldRef<"StudentTrainingEnrollment", 'String'>
    readonly createdAt: FieldRef<"StudentTrainingEnrollment", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentTrainingEnrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentTrainingEnrollment findUnique
   */
  export type StudentTrainingEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentTrainingEnrollment to fetch.
     */
    where: StudentTrainingEnrollmentWhereUniqueInput
  }

  /**
   * StudentTrainingEnrollment findUniqueOrThrow
   */
  export type StudentTrainingEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentTrainingEnrollment to fetch.
     */
    where: StudentTrainingEnrollmentWhereUniqueInput
  }

  /**
   * StudentTrainingEnrollment findFirst
   */
  export type StudentTrainingEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentTrainingEnrollment to fetch.
     */
    where?: StudentTrainingEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTrainingEnrollments to fetch.
     */
    orderBy?: StudentTrainingEnrollmentOrderByWithRelationInput | StudentTrainingEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTrainingEnrollments.
     */
    cursor?: StudentTrainingEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTrainingEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTrainingEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTrainingEnrollments.
     */
    distinct?: StudentTrainingEnrollmentScalarFieldEnum | StudentTrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentTrainingEnrollment findFirstOrThrow
   */
  export type StudentTrainingEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentTrainingEnrollment to fetch.
     */
    where?: StudentTrainingEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTrainingEnrollments to fetch.
     */
    orderBy?: StudentTrainingEnrollmentOrderByWithRelationInput | StudentTrainingEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTrainingEnrollments.
     */
    cursor?: StudentTrainingEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTrainingEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTrainingEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTrainingEnrollments.
     */
    distinct?: StudentTrainingEnrollmentScalarFieldEnum | StudentTrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentTrainingEnrollment findMany
   */
  export type StudentTrainingEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentTrainingEnrollments to fetch.
     */
    where?: StudentTrainingEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTrainingEnrollments to fetch.
     */
    orderBy?: StudentTrainingEnrollmentOrderByWithRelationInput | StudentTrainingEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTrainingEnrollments.
     */
    cursor?: StudentTrainingEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTrainingEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTrainingEnrollments.
     */
    skip?: number
    distinct?: StudentTrainingEnrollmentScalarFieldEnum | StudentTrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentTrainingEnrollment create
   */
  export type StudentTrainingEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTrainingEnrollment.
     */
    data: XOR<StudentTrainingEnrollmentCreateInput, StudentTrainingEnrollmentUncheckedCreateInput>
  }

  /**
   * StudentTrainingEnrollment createMany
   */
  export type StudentTrainingEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTrainingEnrollments.
     */
    data: StudentTrainingEnrollmentCreateManyInput | StudentTrainingEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTrainingEnrollment createManyAndReturn
   */
  export type StudentTrainingEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentTrainingEnrollments.
     */
    data: StudentTrainingEnrollmentCreateManyInput | StudentTrainingEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTrainingEnrollment update
   */
  export type StudentTrainingEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTrainingEnrollment.
     */
    data: XOR<StudentTrainingEnrollmentUpdateInput, StudentTrainingEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which StudentTrainingEnrollment to update.
     */
    where: StudentTrainingEnrollmentWhereUniqueInput
  }

  /**
   * StudentTrainingEnrollment updateMany
   */
  export type StudentTrainingEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTrainingEnrollments.
     */
    data: XOR<StudentTrainingEnrollmentUpdateManyMutationInput, StudentTrainingEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which StudentTrainingEnrollments to update
     */
    where?: StudentTrainingEnrollmentWhereInput
  }

  /**
   * StudentTrainingEnrollment upsert
   */
  export type StudentTrainingEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTrainingEnrollment to update in case it exists.
     */
    where: StudentTrainingEnrollmentWhereUniqueInput
    /**
     * In case the StudentTrainingEnrollment found by the `where` argument doesn't exist, create a new StudentTrainingEnrollment with this data.
     */
    create: XOR<StudentTrainingEnrollmentCreateInput, StudentTrainingEnrollmentUncheckedCreateInput>
    /**
     * In case the StudentTrainingEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTrainingEnrollmentUpdateInput, StudentTrainingEnrollmentUncheckedUpdateInput>
  }

  /**
   * StudentTrainingEnrollment delete
   */
  export type StudentTrainingEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which StudentTrainingEnrollment to delete.
     */
    where: StudentTrainingEnrollmentWhereUniqueInput
  }

  /**
   * StudentTrainingEnrollment deleteMany
   */
  export type StudentTrainingEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTrainingEnrollments to delete
     */
    where?: StudentTrainingEnrollmentWhereInput
  }

  /**
   * StudentTrainingEnrollment without action
   */
  export type StudentTrainingEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model StudentProfile
   */

  export type AggregateStudentProfile = {
    _count: StudentProfileCountAggregateOutputType | null
    _avg: StudentProfileAvgAggregateOutputType | null
    _sum: StudentProfileSumAggregateOutputType | null
    _min: StudentProfileMinAggregateOutputType | null
    _max: StudentProfileMaxAggregateOutputType | null
  }

  export type StudentProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    gpa: number | null
    attendance: number | null
    totalCredits: number | null
  }

  export type StudentProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
    gpa: number | null
    attendance: number | null
    totalCredits: number | null
  }

  export type StudentProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    university: string | null
    faculty: string | null
    year: string | null
    gpa: number | null
    bio: string | null
    location: string | null
    phoneNumber: string | null
    linkedinUrl: string | null
    facebookUrl: string | null
    githubUrl: string | null
    portfolioUrl: string | null
    profileImage: string | null
    cvPath: string | null
    attendance: number | null
    totalCredits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    university: string | null
    faculty: string | null
    year: string | null
    gpa: number | null
    bio: string | null
    location: string | null
    phoneNumber: string | null
    linkedinUrl: string | null
    facebookUrl: string | null
    githubUrl: string | null
    portfolioUrl: string | null
    profileImage: string | null
    cvPath: string | null
    attendance: number | null
    totalCredits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProfileCountAggregateOutputType = {
    id: number
    userId: number
    university: number
    faculty: number
    year: number
    gpa: number
    bio: number
    location: number
    phoneNumber: number
    linkedinUrl: number
    facebookUrl: number
    githubUrl: number
    portfolioUrl: number
    profileImage: number
    cvPath: number
    attendance: number
    totalCredits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentProfileAvgAggregateInputType = {
    id?: true
    userId?: true
    gpa?: true
    attendance?: true
    totalCredits?: true
  }

  export type StudentProfileSumAggregateInputType = {
    id?: true
    userId?: true
    gpa?: true
    attendance?: true
    totalCredits?: true
  }

  export type StudentProfileMinAggregateInputType = {
    id?: true
    userId?: true
    university?: true
    faculty?: true
    year?: true
    gpa?: true
    bio?: true
    location?: true
    phoneNumber?: true
    linkedinUrl?: true
    facebookUrl?: true
    githubUrl?: true
    portfolioUrl?: true
    profileImage?: true
    cvPath?: true
    attendance?: true
    totalCredits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    university?: true
    faculty?: true
    year?: true
    gpa?: true
    bio?: true
    location?: true
    phoneNumber?: true
    linkedinUrl?: true
    facebookUrl?: true
    githubUrl?: true
    portfolioUrl?: true
    profileImage?: true
    cvPath?: true
    attendance?: true
    totalCredits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProfileCountAggregateInputType = {
    id?: true
    userId?: true
    university?: true
    faculty?: true
    year?: true
    gpa?: true
    bio?: true
    location?: true
    phoneNumber?: true
    linkedinUrl?: true
    facebookUrl?: true
    githubUrl?: true
    portfolioUrl?: true
    profileImage?: true
    cvPath?: true
    attendance?: true
    totalCredits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProfile to aggregate.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentProfiles
    **/
    _count?: true | StudentProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentProfileMaxAggregateInputType
  }

  export type GetStudentProfileAggregateType<T extends StudentProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentProfile[P]>
      : GetScalarType<T[P], AggregateStudentProfile[P]>
  }




  export type StudentProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProfileWhereInput
    orderBy?: StudentProfileOrderByWithAggregationInput | StudentProfileOrderByWithAggregationInput[]
    by: StudentProfileScalarFieldEnum[] | StudentProfileScalarFieldEnum
    having?: StudentProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentProfileCountAggregateInputType | true
    _avg?: StudentProfileAvgAggregateInputType
    _sum?: StudentProfileSumAggregateInputType
    _min?: StudentProfileMinAggregateInputType
    _max?: StudentProfileMaxAggregateInputType
  }

  export type StudentProfileGroupByOutputType = {
    id: number
    userId: number
    university: string | null
    faculty: string | null
    year: string | null
    gpa: number | null
    bio: string | null
    location: string | null
    phoneNumber: string | null
    linkedinUrl: string | null
    facebookUrl: string | null
    githubUrl: string | null
    portfolioUrl: string | null
    profileImage: string | null
    cvPath: string | null
    attendance: number | null
    totalCredits: number | null
    createdAt: Date
    updatedAt: Date
    _count: StudentProfileCountAggregateOutputType | null
    _avg: StudentProfileAvgAggregateOutputType | null
    _sum: StudentProfileSumAggregateOutputType | null
    _min: StudentProfileMinAggregateOutputType | null
    _max: StudentProfileMaxAggregateOutputType | null
  }

  type GetStudentProfileGroupByPayload<T extends StudentProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentProfileGroupByOutputType[P]>
            : GetScalarType<T[P], StudentProfileGroupByOutputType[P]>
        }
      >
    >


  export type StudentProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    university?: boolean
    faculty?: boolean
    year?: boolean
    gpa?: boolean
    bio?: boolean
    location?: boolean
    phoneNumber?: boolean
    linkedinUrl?: boolean
    facebookUrl?: boolean
    githubUrl?: boolean
    portfolioUrl?: boolean
    profileImage?: boolean
    cvPath?: boolean
    attendance?: boolean
    totalCredits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | StudentProfile$skillsArgs<ExtArgs>
    badges?: boolean | StudentProfile$badgesArgs<ExtArgs>
    trainings?: boolean | StudentProfile$trainingsArgs<ExtArgs>
    testimonials?: boolean | StudentProfile$testimonialsArgs<ExtArgs>
    academicSubjects?: boolean | StudentProfile$academicSubjectsArgs<ExtArgs>
    featuredStudent?: boolean | StudentProfile$featuredStudentArgs<ExtArgs>
    trainingReviews?: boolean | StudentProfile$trainingReviewsArgs<ExtArgs>
    StudentTraining?: boolean | StudentProfile$StudentTrainingArgs<ExtArgs>
    _count?: boolean | StudentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    university?: boolean
    faculty?: boolean
    year?: boolean
    gpa?: boolean
    bio?: boolean
    location?: boolean
    phoneNumber?: boolean
    linkedinUrl?: boolean
    facebookUrl?: boolean
    githubUrl?: boolean
    portfolioUrl?: boolean
    profileImage?: boolean
    cvPath?: boolean
    attendance?: boolean
    totalCredits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    university?: boolean
    faculty?: boolean
    year?: boolean
    gpa?: boolean
    bio?: boolean
    location?: boolean
    phoneNumber?: boolean
    linkedinUrl?: boolean
    facebookUrl?: boolean
    githubUrl?: boolean
    portfolioUrl?: boolean
    profileImage?: boolean
    cvPath?: boolean
    attendance?: boolean
    totalCredits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | StudentProfile$skillsArgs<ExtArgs>
    badges?: boolean | StudentProfile$badgesArgs<ExtArgs>
    trainings?: boolean | StudentProfile$trainingsArgs<ExtArgs>
    testimonials?: boolean | StudentProfile$testimonialsArgs<ExtArgs>
    academicSubjects?: boolean | StudentProfile$academicSubjectsArgs<ExtArgs>
    featuredStudent?: boolean | StudentProfile$featuredStudentArgs<ExtArgs>
    trainingReviews?: boolean | StudentProfile$trainingReviewsArgs<ExtArgs>
    StudentTraining?: boolean | StudentProfile$StudentTrainingArgs<ExtArgs>
    _count?: boolean | StudentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skills: Prisma.$StudentSkillPayload<ExtArgs>[]
      badges: Prisma.$StudentBadgePayload<ExtArgs>[]
      trainings: Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>[]
      testimonials: Prisma.$StudentTestimonialPayload<ExtArgs>[]
      academicSubjects: Prisma.$StudentSubjectPayload<ExtArgs>[]
      featuredStudent: Prisma.$FeaturedStudentPayload<ExtArgs> | null
      trainingReviews: Prisma.$TrainingReviewPayload<ExtArgs>[]
      StudentTraining: Prisma.$StudentTrainingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      university: string | null
      faculty: string | null
      year: string | null
      gpa: number | null
      bio: string | null
      location: string | null
      phoneNumber: string | null
      linkedinUrl: string | null
      facebookUrl: string | null
      githubUrl: string | null
      portfolioUrl: string | null
      profileImage: string | null
      cvPath: string | null
      attendance: number | null
      totalCredits: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentProfile"]>
    composites: {}
  }

  type StudentProfileGetPayload<S extends boolean | null | undefined | StudentProfileDefaultArgs> = $Result.GetResult<Prisma.$StudentProfilePayload, S>

  type StudentProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentProfileCountAggregateInputType | true
    }

  export interface StudentProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentProfile'], meta: { name: 'StudentProfile' } }
    /**
     * Find zero or one StudentProfile that matches the filter.
     * @param {StudentProfileFindUniqueArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentProfileFindUniqueArgs>(args: SelectSubset<T, StudentProfileFindUniqueArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentProfileFindUniqueOrThrowArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindFirstArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentProfileFindFirstArgs>(args?: SelectSubset<T, StudentProfileFindFirstArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindFirstOrThrowArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentProfiles
     * const studentProfiles = await prisma.studentProfile.findMany()
     * 
     * // Get first 10 StudentProfiles
     * const studentProfiles = await prisma.studentProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentProfileFindManyArgs>(args?: SelectSubset<T, StudentProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentProfile.
     * @param {StudentProfileCreateArgs} args - Arguments to create a StudentProfile.
     * @example
     * // Create one StudentProfile
     * const StudentProfile = await prisma.studentProfile.create({
     *   data: {
     *     // ... data to create a StudentProfile
     *   }
     * })
     * 
     */
    create<T extends StudentProfileCreateArgs>(args: SelectSubset<T, StudentProfileCreateArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentProfiles.
     * @param {StudentProfileCreateManyArgs} args - Arguments to create many StudentProfiles.
     * @example
     * // Create many StudentProfiles
     * const studentProfile = await prisma.studentProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentProfileCreateManyArgs>(args?: SelectSubset<T, StudentProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentProfiles and returns the data saved in the database.
     * @param {StudentProfileCreateManyAndReturnArgs} args - Arguments to create many StudentProfiles.
     * @example
     * // Create many StudentProfiles
     * const studentProfile = await prisma.studentProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentProfiles and only return the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentProfile.
     * @param {StudentProfileDeleteArgs} args - Arguments to delete one StudentProfile.
     * @example
     * // Delete one StudentProfile
     * const StudentProfile = await prisma.studentProfile.delete({
     *   where: {
     *     // ... filter to delete one StudentProfile
     *   }
     * })
     * 
     */
    delete<T extends StudentProfileDeleteArgs>(args: SelectSubset<T, StudentProfileDeleteArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentProfile.
     * @param {StudentProfileUpdateArgs} args - Arguments to update one StudentProfile.
     * @example
     * // Update one StudentProfile
     * const studentProfile = await prisma.studentProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentProfileUpdateArgs>(args: SelectSubset<T, StudentProfileUpdateArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentProfiles.
     * @param {StudentProfileDeleteManyArgs} args - Arguments to filter StudentProfiles to delete.
     * @example
     * // Delete a few StudentProfiles
     * const { count } = await prisma.studentProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentProfileDeleteManyArgs>(args?: SelectSubset<T, StudentProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentProfiles
     * const studentProfile = await prisma.studentProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentProfileUpdateManyArgs>(args: SelectSubset<T, StudentProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentProfile.
     * @param {StudentProfileUpsertArgs} args - Arguments to update or create a StudentProfile.
     * @example
     * // Update or create a StudentProfile
     * const studentProfile = await prisma.studentProfile.upsert({
     *   create: {
     *     // ... data to create a StudentProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentProfile we want to update
     *   }
     * })
     */
    upsert<T extends StudentProfileUpsertArgs>(args: SelectSubset<T, StudentProfileUpsertArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileCountArgs} args - Arguments to filter StudentProfiles to count.
     * @example
     * // Count the number of StudentProfiles
     * const count = await prisma.studentProfile.count({
     *   where: {
     *     // ... the filter for the StudentProfiles we want to count
     *   }
     * })
    **/
    count<T extends StudentProfileCountArgs>(
      args?: Subset<T, StudentProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentProfileAggregateArgs>(args: Subset<T, StudentProfileAggregateArgs>): Prisma.PrismaPromise<GetStudentProfileAggregateType<T>>

    /**
     * Group by StudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentProfileGroupByArgs['orderBy'] }
        : { orderBy?: StudentProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentProfile model
   */
  readonly fields: StudentProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skills<T extends StudentProfile$skillsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findMany"> | Null>
    badges<T extends StudentProfile$badgesArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "findMany"> | Null>
    trainings<T extends StudentProfile$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTrainingEnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    testimonials<T extends StudentProfile$testimonialsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$testimonialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "findMany"> | Null>
    academicSubjects<T extends StudentProfile$academicSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$academicSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    featuredStudent<T extends StudentProfile$featuredStudentArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$featuredStudentArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    trainingReviews<T extends StudentProfile$trainingReviewsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$trainingReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "findMany"> | Null>
    StudentTraining<T extends StudentProfile$StudentTrainingArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$StudentTrainingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentProfile model
   */ 
  interface StudentProfileFieldRefs {
    readonly id: FieldRef<"StudentProfile", 'Int'>
    readonly userId: FieldRef<"StudentProfile", 'Int'>
    readonly university: FieldRef<"StudentProfile", 'String'>
    readonly faculty: FieldRef<"StudentProfile", 'String'>
    readonly year: FieldRef<"StudentProfile", 'String'>
    readonly gpa: FieldRef<"StudentProfile", 'Float'>
    readonly bio: FieldRef<"StudentProfile", 'String'>
    readonly location: FieldRef<"StudentProfile", 'String'>
    readonly phoneNumber: FieldRef<"StudentProfile", 'String'>
    readonly linkedinUrl: FieldRef<"StudentProfile", 'String'>
    readonly facebookUrl: FieldRef<"StudentProfile", 'String'>
    readonly githubUrl: FieldRef<"StudentProfile", 'String'>
    readonly portfolioUrl: FieldRef<"StudentProfile", 'String'>
    readonly profileImage: FieldRef<"StudentProfile", 'String'>
    readonly cvPath: FieldRef<"StudentProfile", 'String'>
    readonly attendance: FieldRef<"StudentProfile", 'Float'>
    readonly totalCredits: FieldRef<"StudentProfile", 'Int'>
    readonly createdAt: FieldRef<"StudentProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentProfile findUnique
   */
  export type StudentProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile findUniqueOrThrow
   */
  export type StudentProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile findFirst
   */
  export type StudentProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProfiles.
     */
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile findFirstOrThrow
   */
  export type StudentProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProfiles.
     */
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile findMany
   */
  export type StudentProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfiles to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile create
   */
  export type StudentProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentProfile.
     */
    data: XOR<StudentProfileCreateInput, StudentProfileUncheckedCreateInput>
  }

  /**
   * StudentProfile createMany
   */
  export type StudentProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentProfiles.
     */
    data: StudentProfileCreateManyInput | StudentProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentProfile createManyAndReturn
   */
  export type StudentProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentProfiles.
     */
    data: StudentProfileCreateManyInput | StudentProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProfile update
   */
  export type StudentProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentProfile.
     */
    data: XOR<StudentProfileUpdateInput, StudentProfileUncheckedUpdateInput>
    /**
     * Choose, which StudentProfile to update.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile updateMany
   */
  export type StudentProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentProfiles.
     */
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which StudentProfiles to update
     */
    where?: StudentProfileWhereInput
  }

  /**
   * StudentProfile upsert
   */
  export type StudentProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentProfile to update in case it exists.
     */
    where: StudentProfileWhereUniqueInput
    /**
     * In case the StudentProfile found by the `where` argument doesn't exist, create a new StudentProfile with this data.
     */
    create: XOR<StudentProfileCreateInput, StudentProfileUncheckedCreateInput>
    /**
     * In case the StudentProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentProfileUpdateInput, StudentProfileUncheckedUpdateInput>
  }

  /**
   * StudentProfile delete
   */
  export type StudentProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter which StudentProfile to delete.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile deleteMany
   */
  export type StudentProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProfiles to delete
     */
    where?: StudentProfileWhereInput
  }

  /**
   * StudentProfile.skills
   */
  export type StudentProfile$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    where?: StudentSkillWhereInput
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    cursor?: StudentSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * StudentProfile.badges
   */
  export type StudentProfile$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    where?: StudentBadgeWhereInput
    orderBy?: StudentBadgeOrderByWithRelationInput | StudentBadgeOrderByWithRelationInput[]
    cursor?: StudentBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentBadgeScalarFieldEnum | StudentBadgeScalarFieldEnum[]
  }

  /**
   * StudentProfile.trainings
   */
  export type StudentProfile$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTrainingEnrollment
     */
    select?: StudentTrainingEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingEnrollmentInclude<ExtArgs> | null
    where?: StudentTrainingEnrollmentWhereInput
    orderBy?: StudentTrainingEnrollmentOrderByWithRelationInput | StudentTrainingEnrollmentOrderByWithRelationInput[]
    cursor?: StudentTrainingEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTrainingEnrollmentScalarFieldEnum | StudentTrainingEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentProfile.testimonials
   */
  export type StudentProfile$testimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    where?: StudentTestimonialWhereInput
    orderBy?: StudentTestimonialOrderByWithRelationInput | StudentTestimonialOrderByWithRelationInput[]
    cursor?: StudentTestimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTestimonialScalarFieldEnum | StudentTestimonialScalarFieldEnum[]
  }

  /**
   * StudentProfile.academicSubjects
   */
  export type StudentProfile$academicSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    cursor?: StudentSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentProfile.featuredStudent
   */
  export type StudentProfile$featuredStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    where?: FeaturedStudentWhereInput
  }

  /**
   * StudentProfile.trainingReviews
   */
  export type StudentProfile$trainingReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    where?: TrainingReviewWhereInput
    orderBy?: TrainingReviewOrderByWithRelationInput | TrainingReviewOrderByWithRelationInput[]
    cursor?: TrainingReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingReviewScalarFieldEnum | TrainingReviewScalarFieldEnum[]
  }

  /**
   * StudentProfile.StudentTraining
   */
  export type StudentProfile$StudentTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    where?: StudentTrainingWhereInput
    orderBy?: StudentTrainingOrderByWithRelationInput | StudentTrainingOrderByWithRelationInput[]
    cursor?: StudentTrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTrainingScalarFieldEnum | StudentTrainingScalarFieldEnum[]
  }

  /**
   * StudentProfile without action
   */
  export type StudentProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
  }


  /**
   * Model StudentSkill
   */

  export type AggregateStudentSkill = {
    _count: StudentSkillCountAggregateOutputType | null
    _avg: StudentSkillAvgAggregateOutputType | null
    _sum: StudentSkillSumAggregateOutputType | null
    _min: StudentSkillMinAggregateOutputType | null
    _max: StudentSkillMaxAggregateOutputType | null
  }

  export type StudentSkillAvgAggregateOutputType = {
    id: number | null
    level: number | null
    profileId: number | null
  }

  export type StudentSkillSumAggregateOutputType = {
    id: number | null
    level: number | null
    profileId: number | null
  }

  export type StudentSkillMinAggregateOutputType = {
    id: number | null
    name: string | null
    level: number | null
    profileId: number | null
  }

  export type StudentSkillMaxAggregateOutputType = {
    id: number | null
    name: string | null
    level: number | null
    profileId: number | null
  }

  export type StudentSkillCountAggregateOutputType = {
    id: number
    name: number
    level: number
    profileId: number
    _all: number
  }


  export type StudentSkillAvgAggregateInputType = {
    id?: true
    level?: true
    profileId?: true
  }

  export type StudentSkillSumAggregateInputType = {
    id?: true
    level?: true
    profileId?: true
  }

  export type StudentSkillMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    profileId?: true
  }

  export type StudentSkillMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    profileId?: true
  }

  export type StudentSkillCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    profileId?: true
    _all?: true
  }

  export type StudentSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSkill to aggregate.
     */
    where?: StudentSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSkills to fetch.
     */
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSkills
    **/
    _count?: true | StudentSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSkillMaxAggregateInputType
  }

  export type GetStudentSkillAggregateType<T extends StudentSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSkill[P]>
      : GetScalarType<T[P], AggregateStudentSkill[P]>
  }




  export type StudentSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSkillWhereInput
    orderBy?: StudentSkillOrderByWithAggregationInput | StudentSkillOrderByWithAggregationInput[]
    by: StudentSkillScalarFieldEnum[] | StudentSkillScalarFieldEnum
    having?: StudentSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSkillCountAggregateInputType | true
    _avg?: StudentSkillAvgAggregateInputType
    _sum?: StudentSkillSumAggregateInputType
    _min?: StudentSkillMinAggregateInputType
    _max?: StudentSkillMaxAggregateInputType
  }

  export type StudentSkillGroupByOutputType = {
    id: number
    name: string
    level: number
    profileId: number
    _count: StudentSkillCountAggregateOutputType | null
    _avg: StudentSkillAvgAggregateOutputType | null
    _sum: StudentSkillSumAggregateOutputType | null
    _min: StudentSkillMinAggregateOutputType | null
    _max: StudentSkillMaxAggregateOutputType | null
  }

  type GetStudentSkillGroupByPayload<T extends StudentSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSkillGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSkillGroupByOutputType[P]>
        }
      >
    >


  export type StudentSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSkill"]>

  export type StudentSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSkill"]>

  export type StudentSkillSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    profileId?: boolean
  }

  export type StudentSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type StudentSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $StudentSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSkill"
    objects: {
      profile: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      level: number
      profileId: number
    }, ExtArgs["result"]["studentSkill"]>
    composites: {}
  }

  type StudentSkillGetPayload<S extends boolean | null | undefined | StudentSkillDefaultArgs> = $Result.GetResult<Prisma.$StudentSkillPayload, S>

  type StudentSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentSkillCountAggregateInputType | true
    }

  export interface StudentSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSkill'], meta: { name: 'StudentSkill' } }
    /**
     * Find zero or one StudentSkill that matches the filter.
     * @param {StudentSkillFindUniqueArgs} args - Arguments to find a StudentSkill
     * @example
     * // Get one StudentSkill
     * const studentSkill = await prisma.studentSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSkillFindUniqueArgs>(args: SelectSubset<T, StudentSkillFindUniqueArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentSkillFindUniqueOrThrowArgs} args - Arguments to find a StudentSkill
     * @example
     * // Get one StudentSkill
     * const studentSkill = await prisma.studentSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillFindFirstArgs} args - Arguments to find a StudentSkill
     * @example
     * // Get one StudentSkill
     * const studentSkill = await prisma.studentSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSkillFindFirstArgs>(args?: SelectSubset<T, StudentSkillFindFirstArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillFindFirstOrThrowArgs} args - Arguments to find a StudentSkill
     * @example
     * // Get one StudentSkill
     * const studentSkill = await prisma.studentSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSkills
     * const studentSkills = await prisma.studentSkill.findMany()
     * 
     * // Get first 10 StudentSkills
     * const studentSkills = await prisma.studentSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSkillWithIdOnly = await prisma.studentSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSkillFindManyArgs>(args?: SelectSubset<T, StudentSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentSkill.
     * @param {StudentSkillCreateArgs} args - Arguments to create a StudentSkill.
     * @example
     * // Create one StudentSkill
     * const StudentSkill = await prisma.studentSkill.create({
     *   data: {
     *     // ... data to create a StudentSkill
     *   }
     * })
     * 
     */
    create<T extends StudentSkillCreateArgs>(args: SelectSubset<T, StudentSkillCreateArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentSkills.
     * @param {StudentSkillCreateManyArgs} args - Arguments to create many StudentSkills.
     * @example
     * // Create many StudentSkills
     * const studentSkill = await prisma.studentSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSkillCreateManyArgs>(args?: SelectSubset<T, StudentSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSkills and returns the data saved in the database.
     * @param {StudentSkillCreateManyAndReturnArgs} args - Arguments to create many StudentSkills.
     * @example
     * // Create many StudentSkills
     * const studentSkill = await prisma.studentSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSkills and only return the `id`
     * const studentSkillWithIdOnly = await prisma.studentSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentSkill.
     * @param {StudentSkillDeleteArgs} args - Arguments to delete one StudentSkill.
     * @example
     * // Delete one StudentSkill
     * const StudentSkill = await prisma.studentSkill.delete({
     *   where: {
     *     // ... filter to delete one StudentSkill
     *   }
     * })
     * 
     */
    delete<T extends StudentSkillDeleteArgs>(args: SelectSubset<T, StudentSkillDeleteArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentSkill.
     * @param {StudentSkillUpdateArgs} args - Arguments to update one StudentSkill.
     * @example
     * // Update one StudentSkill
     * const studentSkill = await prisma.studentSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSkillUpdateArgs>(args: SelectSubset<T, StudentSkillUpdateArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentSkills.
     * @param {StudentSkillDeleteManyArgs} args - Arguments to filter StudentSkills to delete.
     * @example
     * // Delete a few StudentSkills
     * const { count } = await prisma.studentSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSkillDeleteManyArgs>(args?: SelectSubset<T, StudentSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSkills
     * const studentSkill = await prisma.studentSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSkillUpdateManyArgs>(args: SelectSubset<T, StudentSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSkill.
     * @param {StudentSkillUpsertArgs} args - Arguments to update or create a StudentSkill.
     * @example
     * // Update or create a StudentSkill
     * const studentSkill = await prisma.studentSkill.upsert({
     *   create: {
     *     // ... data to create a StudentSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSkill we want to update
     *   }
     * })
     */
    upsert<T extends StudentSkillUpsertArgs>(args: SelectSubset<T, StudentSkillUpsertArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillCountArgs} args - Arguments to filter StudentSkills to count.
     * @example
     * // Count the number of StudentSkills
     * const count = await prisma.studentSkill.count({
     *   where: {
     *     // ... the filter for the StudentSkills we want to count
     *   }
     * })
    **/
    count<T extends StudentSkillCountArgs>(
      args?: Subset<T, StudentSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSkillAggregateArgs>(args: Subset<T, StudentSkillAggregateArgs>): Prisma.PrismaPromise<GetStudentSkillAggregateType<T>>

    /**
     * Group by StudentSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSkillGroupByArgs['orderBy'] }
        : { orderBy?: StudentSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSkill model
   */
  readonly fields: StudentSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSkill model
   */ 
  interface StudentSkillFieldRefs {
    readonly id: FieldRef<"StudentSkill", 'Int'>
    readonly name: FieldRef<"StudentSkill", 'String'>
    readonly level: FieldRef<"StudentSkill", 'Int'>
    readonly profileId: FieldRef<"StudentSkill", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StudentSkill findUnique
   */
  export type StudentSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkill to fetch.
     */
    where: StudentSkillWhereUniqueInput
  }

  /**
   * StudentSkill findUniqueOrThrow
   */
  export type StudentSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkill to fetch.
     */
    where: StudentSkillWhereUniqueInput
  }

  /**
   * StudentSkill findFirst
   */
  export type StudentSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkill to fetch.
     */
    where?: StudentSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSkills to fetch.
     */
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSkills.
     */
    cursor?: StudentSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSkills.
     */
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * StudentSkill findFirstOrThrow
   */
  export type StudentSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkill to fetch.
     */
    where?: StudentSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSkills to fetch.
     */
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSkills.
     */
    cursor?: StudentSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSkills.
     */
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * StudentSkill findMany
   */
  export type StudentSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkills to fetch.
     */
    where?: StudentSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSkills to fetch.
     */
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSkills.
     */
    cursor?: StudentSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSkills.
     */
    skip?: number
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * StudentSkill create
   */
  export type StudentSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSkill.
     */
    data: XOR<StudentSkillCreateInput, StudentSkillUncheckedCreateInput>
  }

  /**
   * StudentSkill createMany
   */
  export type StudentSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSkills.
     */
    data: StudentSkillCreateManyInput | StudentSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSkill createManyAndReturn
   */
  export type StudentSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentSkills.
     */
    data: StudentSkillCreateManyInput | StudentSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSkill update
   */
  export type StudentSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSkill.
     */
    data: XOR<StudentSkillUpdateInput, StudentSkillUncheckedUpdateInput>
    /**
     * Choose, which StudentSkill to update.
     */
    where: StudentSkillWhereUniqueInput
  }

  /**
   * StudentSkill updateMany
   */
  export type StudentSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSkills.
     */
    data: XOR<StudentSkillUpdateManyMutationInput, StudentSkillUncheckedUpdateManyInput>
    /**
     * Filter which StudentSkills to update
     */
    where?: StudentSkillWhereInput
  }

  /**
   * StudentSkill upsert
   */
  export type StudentSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSkill to update in case it exists.
     */
    where: StudentSkillWhereUniqueInput
    /**
     * In case the StudentSkill found by the `where` argument doesn't exist, create a new StudentSkill with this data.
     */
    create: XOR<StudentSkillCreateInput, StudentSkillUncheckedCreateInput>
    /**
     * In case the StudentSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSkillUpdateInput, StudentSkillUncheckedUpdateInput>
  }

  /**
   * StudentSkill delete
   */
  export type StudentSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter which StudentSkill to delete.
     */
    where: StudentSkillWhereUniqueInput
  }

  /**
   * StudentSkill deleteMany
   */
  export type StudentSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSkills to delete
     */
    where?: StudentSkillWhereInput
  }

  /**
   * StudentSkill without action
   */
  export type StudentSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
  }


  /**
   * Model StudentBadge
   */

  export type AggregateStudentBadge = {
    _count: StudentBadgeCountAggregateOutputType | null
    _avg: StudentBadgeAvgAggregateOutputType | null
    _sum: StudentBadgeSumAggregateOutputType | null
    _min: StudentBadgeMinAggregateOutputType | null
    _max: StudentBadgeMaxAggregateOutputType | null
  }

  export type StudentBadgeAvgAggregateOutputType = {
    id: number | null
    profileId: number | null
  }

  export type StudentBadgeSumAggregateOutputType = {
    id: number | null
    profileId: number | null
  }

  export type StudentBadgeMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    date: Date | null
    profileId: number | null
  }

  export type StudentBadgeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    date: Date | null
    profileId: number | null
  }

  export type StudentBadgeCountAggregateOutputType = {
    id: number
    name: number
    type: number
    date: number
    profileId: number
    _all: number
  }


  export type StudentBadgeAvgAggregateInputType = {
    id?: true
    profileId?: true
  }

  export type StudentBadgeSumAggregateInputType = {
    id?: true
    profileId?: true
  }

  export type StudentBadgeMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    date?: true
    profileId?: true
  }

  export type StudentBadgeMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    date?: true
    profileId?: true
  }

  export type StudentBadgeCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    date?: true
    profileId?: true
    _all?: true
  }

  export type StudentBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentBadge to aggregate.
     */
    where?: StudentBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentBadges to fetch.
     */
    orderBy?: StudentBadgeOrderByWithRelationInput | StudentBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentBadges
    **/
    _count?: true | StudentBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentBadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentBadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentBadgeMaxAggregateInputType
  }

  export type GetStudentBadgeAggregateType<T extends StudentBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentBadge[P]>
      : GetScalarType<T[P], AggregateStudentBadge[P]>
  }




  export type StudentBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentBadgeWhereInput
    orderBy?: StudentBadgeOrderByWithAggregationInput | StudentBadgeOrderByWithAggregationInput[]
    by: StudentBadgeScalarFieldEnum[] | StudentBadgeScalarFieldEnum
    having?: StudentBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentBadgeCountAggregateInputType | true
    _avg?: StudentBadgeAvgAggregateInputType
    _sum?: StudentBadgeSumAggregateInputType
    _min?: StudentBadgeMinAggregateInputType
    _max?: StudentBadgeMaxAggregateInputType
  }

  export type StudentBadgeGroupByOutputType = {
    id: number
    name: string
    type: string
    date: Date
    profileId: number
    _count: StudentBadgeCountAggregateOutputType | null
    _avg: StudentBadgeAvgAggregateOutputType | null
    _sum: StudentBadgeSumAggregateOutputType | null
    _min: StudentBadgeMinAggregateOutputType | null
    _max: StudentBadgeMaxAggregateOutputType | null
  }

  type GetStudentBadgeGroupByPayload<T extends StudentBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], StudentBadgeGroupByOutputType[P]>
        }
      >
    >


  export type StudentBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    date?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentBadge"]>

  export type StudentBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    date?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentBadge"]>

  export type StudentBadgeSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    date?: boolean
    profileId?: boolean
  }

  export type StudentBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type StudentBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $StudentBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentBadge"
    objects: {
      profile: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      date: Date
      profileId: number
    }, ExtArgs["result"]["studentBadge"]>
    composites: {}
  }

  type StudentBadgeGetPayload<S extends boolean | null | undefined | StudentBadgeDefaultArgs> = $Result.GetResult<Prisma.$StudentBadgePayload, S>

  type StudentBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentBadgeCountAggregateInputType | true
    }

  export interface StudentBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentBadge'], meta: { name: 'StudentBadge' } }
    /**
     * Find zero or one StudentBadge that matches the filter.
     * @param {StudentBadgeFindUniqueArgs} args - Arguments to find a StudentBadge
     * @example
     * // Get one StudentBadge
     * const studentBadge = await prisma.studentBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentBadgeFindUniqueArgs>(args: SelectSubset<T, StudentBadgeFindUniqueArgs<ExtArgs>>): Prisma__StudentBadgeClient<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentBadge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentBadgeFindUniqueOrThrowArgs} args - Arguments to find a StudentBadge
     * @example
     * // Get one StudentBadge
     * const studentBadge = await prisma.studentBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentBadgeClient<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentBadgeFindFirstArgs} args - Arguments to find a StudentBadge
     * @example
     * // Get one StudentBadge
     * const studentBadge = await prisma.studentBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentBadgeFindFirstArgs>(args?: SelectSubset<T, StudentBadgeFindFirstArgs<ExtArgs>>): Prisma__StudentBadgeClient<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentBadgeFindFirstOrThrowArgs} args - Arguments to find a StudentBadge
     * @example
     * // Get one StudentBadge
     * const studentBadge = await prisma.studentBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentBadgeClient<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentBadges
     * const studentBadges = await prisma.studentBadge.findMany()
     * 
     * // Get first 10 StudentBadges
     * const studentBadges = await prisma.studentBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentBadgeWithIdOnly = await prisma.studentBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentBadgeFindManyArgs>(args?: SelectSubset<T, StudentBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentBadge.
     * @param {StudentBadgeCreateArgs} args - Arguments to create a StudentBadge.
     * @example
     * // Create one StudentBadge
     * const StudentBadge = await prisma.studentBadge.create({
     *   data: {
     *     // ... data to create a StudentBadge
     *   }
     * })
     * 
     */
    create<T extends StudentBadgeCreateArgs>(args: SelectSubset<T, StudentBadgeCreateArgs<ExtArgs>>): Prisma__StudentBadgeClient<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentBadges.
     * @param {StudentBadgeCreateManyArgs} args - Arguments to create many StudentBadges.
     * @example
     * // Create many StudentBadges
     * const studentBadge = await prisma.studentBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentBadgeCreateManyArgs>(args?: SelectSubset<T, StudentBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentBadges and returns the data saved in the database.
     * @param {StudentBadgeCreateManyAndReturnArgs} args - Arguments to create many StudentBadges.
     * @example
     * // Create many StudentBadges
     * const studentBadge = await prisma.studentBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentBadges and only return the `id`
     * const studentBadgeWithIdOnly = await prisma.studentBadge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentBadge.
     * @param {StudentBadgeDeleteArgs} args - Arguments to delete one StudentBadge.
     * @example
     * // Delete one StudentBadge
     * const StudentBadge = await prisma.studentBadge.delete({
     *   where: {
     *     // ... filter to delete one StudentBadge
     *   }
     * })
     * 
     */
    delete<T extends StudentBadgeDeleteArgs>(args: SelectSubset<T, StudentBadgeDeleteArgs<ExtArgs>>): Prisma__StudentBadgeClient<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentBadge.
     * @param {StudentBadgeUpdateArgs} args - Arguments to update one StudentBadge.
     * @example
     * // Update one StudentBadge
     * const studentBadge = await prisma.studentBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentBadgeUpdateArgs>(args: SelectSubset<T, StudentBadgeUpdateArgs<ExtArgs>>): Prisma__StudentBadgeClient<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentBadges.
     * @param {StudentBadgeDeleteManyArgs} args - Arguments to filter StudentBadges to delete.
     * @example
     * // Delete a few StudentBadges
     * const { count } = await prisma.studentBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentBadgeDeleteManyArgs>(args?: SelectSubset<T, StudentBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentBadges
     * const studentBadge = await prisma.studentBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentBadgeUpdateManyArgs>(args: SelectSubset<T, StudentBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentBadge.
     * @param {StudentBadgeUpsertArgs} args - Arguments to update or create a StudentBadge.
     * @example
     * // Update or create a StudentBadge
     * const studentBadge = await prisma.studentBadge.upsert({
     *   create: {
     *     // ... data to create a StudentBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentBadge we want to update
     *   }
     * })
     */
    upsert<T extends StudentBadgeUpsertArgs>(args: SelectSubset<T, StudentBadgeUpsertArgs<ExtArgs>>): Prisma__StudentBadgeClient<$Result.GetResult<Prisma.$StudentBadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentBadgeCountArgs} args - Arguments to filter StudentBadges to count.
     * @example
     * // Count the number of StudentBadges
     * const count = await prisma.studentBadge.count({
     *   where: {
     *     // ... the filter for the StudentBadges we want to count
     *   }
     * })
    **/
    count<T extends StudentBadgeCountArgs>(
      args?: Subset<T, StudentBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentBadgeAggregateArgs>(args: Subset<T, StudentBadgeAggregateArgs>): Prisma.PrismaPromise<GetStudentBadgeAggregateType<T>>

    /**
     * Group by StudentBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentBadgeGroupByArgs['orderBy'] }
        : { orderBy?: StudentBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentBadge model
   */
  readonly fields: StudentBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentBadge model
   */ 
  interface StudentBadgeFieldRefs {
    readonly id: FieldRef<"StudentBadge", 'Int'>
    readonly name: FieldRef<"StudentBadge", 'String'>
    readonly type: FieldRef<"StudentBadge", 'String'>
    readonly date: FieldRef<"StudentBadge", 'DateTime'>
    readonly profileId: FieldRef<"StudentBadge", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StudentBadge findUnique
   */
  export type StudentBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StudentBadge to fetch.
     */
    where: StudentBadgeWhereUniqueInput
  }

  /**
   * StudentBadge findUniqueOrThrow
   */
  export type StudentBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StudentBadge to fetch.
     */
    where: StudentBadgeWhereUniqueInput
  }

  /**
   * StudentBadge findFirst
   */
  export type StudentBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StudentBadge to fetch.
     */
    where?: StudentBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentBadges to fetch.
     */
    orderBy?: StudentBadgeOrderByWithRelationInput | StudentBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentBadges.
     */
    cursor?: StudentBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentBadges.
     */
    distinct?: StudentBadgeScalarFieldEnum | StudentBadgeScalarFieldEnum[]
  }

  /**
   * StudentBadge findFirstOrThrow
   */
  export type StudentBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StudentBadge to fetch.
     */
    where?: StudentBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentBadges to fetch.
     */
    orderBy?: StudentBadgeOrderByWithRelationInput | StudentBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentBadges.
     */
    cursor?: StudentBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentBadges.
     */
    distinct?: StudentBadgeScalarFieldEnum | StudentBadgeScalarFieldEnum[]
  }

  /**
   * StudentBadge findMany
   */
  export type StudentBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StudentBadges to fetch.
     */
    where?: StudentBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentBadges to fetch.
     */
    orderBy?: StudentBadgeOrderByWithRelationInput | StudentBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentBadges.
     */
    cursor?: StudentBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentBadges.
     */
    skip?: number
    distinct?: StudentBadgeScalarFieldEnum | StudentBadgeScalarFieldEnum[]
  }

  /**
   * StudentBadge create
   */
  export type StudentBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentBadge.
     */
    data: XOR<StudentBadgeCreateInput, StudentBadgeUncheckedCreateInput>
  }

  /**
   * StudentBadge createMany
   */
  export type StudentBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentBadges.
     */
    data: StudentBadgeCreateManyInput | StudentBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentBadge createManyAndReturn
   */
  export type StudentBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentBadges.
     */
    data: StudentBadgeCreateManyInput | StudentBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentBadge update
   */
  export type StudentBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentBadge.
     */
    data: XOR<StudentBadgeUpdateInput, StudentBadgeUncheckedUpdateInput>
    /**
     * Choose, which StudentBadge to update.
     */
    where: StudentBadgeWhereUniqueInput
  }

  /**
   * StudentBadge updateMany
   */
  export type StudentBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentBadges.
     */
    data: XOR<StudentBadgeUpdateManyMutationInput, StudentBadgeUncheckedUpdateManyInput>
    /**
     * Filter which StudentBadges to update
     */
    where?: StudentBadgeWhereInput
  }

  /**
   * StudentBadge upsert
   */
  export type StudentBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentBadge to update in case it exists.
     */
    where: StudentBadgeWhereUniqueInput
    /**
     * In case the StudentBadge found by the `where` argument doesn't exist, create a new StudentBadge with this data.
     */
    create: XOR<StudentBadgeCreateInput, StudentBadgeUncheckedCreateInput>
    /**
     * In case the StudentBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentBadgeUpdateInput, StudentBadgeUncheckedUpdateInput>
  }

  /**
   * StudentBadge delete
   */
  export type StudentBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
    /**
     * Filter which StudentBadge to delete.
     */
    where: StudentBadgeWhereUniqueInput
  }

  /**
   * StudentBadge deleteMany
   */
  export type StudentBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentBadges to delete
     */
    where?: StudentBadgeWhereInput
  }

  /**
   * StudentBadge without action
   */
  export type StudentBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentBadge
     */
    select?: StudentBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentBadgeInclude<ExtArgs> | null
  }


  /**
   * Model StudentTraining
   */

  export type AggregateStudentTraining = {
    _count: StudentTrainingCountAggregateOutputType | null
    _avg: StudentTrainingAvgAggregateOutputType | null
    _sum: StudentTrainingSumAggregateOutputType | null
    _min: StudentTrainingMinAggregateOutputType | null
    _max: StudentTrainingMaxAggregateOutputType | null
  }

  export type StudentTrainingAvgAggregateOutputType = {
    id: number | null
    hours: number | null
    progress: number | null
    profileId: number | null
  }

  export type StudentTrainingSumAggregateOutputType = {
    id: number | null
    hours: number | null
    progress: number | null
    profileId: number | null
  }

  export type StudentTrainingMinAggregateOutputType = {
    id: number | null
    title: string | null
    category: string | null
    level: string | null
    instructor: string | null
    hours: number | null
    completionDate: Date | null
    startDate: Date | null
    status: string | null
    progress: number | null
    certificate: boolean | null
    profileId: number | null
  }

  export type StudentTrainingMaxAggregateOutputType = {
    id: number | null
    title: string | null
    category: string | null
    level: string | null
    instructor: string | null
    hours: number | null
    completionDate: Date | null
    startDate: Date | null
    status: string | null
    progress: number | null
    certificate: boolean | null
    profileId: number | null
  }

  export type StudentTrainingCountAggregateOutputType = {
    id: number
    title: number
    category: number
    level: number
    instructor: number
    hours: number
    completionDate: number
    startDate: number
    status: number
    progress: number
    certificate: number
    profileId: number
    _all: number
  }


  export type StudentTrainingAvgAggregateInputType = {
    id?: true
    hours?: true
    progress?: true
    profileId?: true
  }

  export type StudentTrainingSumAggregateInputType = {
    id?: true
    hours?: true
    progress?: true
    profileId?: true
  }

  export type StudentTrainingMinAggregateInputType = {
    id?: true
    title?: true
    category?: true
    level?: true
    instructor?: true
    hours?: true
    completionDate?: true
    startDate?: true
    status?: true
    progress?: true
    certificate?: true
    profileId?: true
  }

  export type StudentTrainingMaxAggregateInputType = {
    id?: true
    title?: true
    category?: true
    level?: true
    instructor?: true
    hours?: true
    completionDate?: true
    startDate?: true
    status?: true
    progress?: true
    certificate?: true
    profileId?: true
  }

  export type StudentTrainingCountAggregateInputType = {
    id?: true
    title?: true
    category?: true
    level?: true
    instructor?: true
    hours?: true
    completionDate?: true
    startDate?: true
    status?: true
    progress?: true
    certificate?: true
    profileId?: true
    _all?: true
  }

  export type StudentTrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTraining to aggregate.
     */
    where?: StudentTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTrainings to fetch.
     */
    orderBy?: StudentTrainingOrderByWithRelationInput | StudentTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTrainings
    **/
    _count?: true | StudentTrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTrainingMaxAggregateInputType
  }

  export type GetStudentTrainingAggregateType<T extends StudentTrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTraining[P]>
      : GetScalarType<T[P], AggregateStudentTraining[P]>
  }




  export type StudentTrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTrainingWhereInput
    orderBy?: StudentTrainingOrderByWithAggregationInput | StudentTrainingOrderByWithAggregationInput[]
    by: StudentTrainingScalarFieldEnum[] | StudentTrainingScalarFieldEnum
    having?: StudentTrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTrainingCountAggregateInputType | true
    _avg?: StudentTrainingAvgAggregateInputType
    _sum?: StudentTrainingSumAggregateInputType
    _min?: StudentTrainingMinAggregateInputType
    _max?: StudentTrainingMaxAggregateInputType
  }

  export type StudentTrainingGroupByOutputType = {
    id: number
    title: string
    category: string
    level: string
    instructor: string
    hours: number | null
    completionDate: Date | null
    startDate: Date | null
    status: string
    progress: number | null
    certificate: boolean
    profileId: number
    _count: StudentTrainingCountAggregateOutputType | null
    _avg: StudentTrainingAvgAggregateOutputType | null
    _sum: StudentTrainingSumAggregateOutputType | null
    _min: StudentTrainingMinAggregateOutputType | null
    _max: StudentTrainingMaxAggregateOutputType | null
  }

  type GetStudentTrainingGroupByPayload<T extends StudentTrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTrainingGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTrainingGroupByOutputType[P]>
        }
      >
    >


  export type StudentTrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    category?: boolean
    level?: boolean
    instructor?: boolean
    hours?: boolean
    completionDate?: boolean
    startDate?: boolean
    status?: boolean
    progress?: boolean
    certificate?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTraining"]>

  export type StudentTrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    category?: boolean
    level?: boolean
    instructor?: boolean
    hours?: boolean
    completionDate?: boolean
    startDate?: boolean
    status?: boolean
    progress?: boolean
    certificate?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTraining"]>

  export type StudentTrainingSelectScalar = {
    id?: boolean
    title?: boolean
    category?: boolean
    level?: boolean
    instructor?: boolean
    hours?: boolean
    completionDate?: boolean
    startDate?: boolean
    status?: boolean
    progress?: boolean
    certificate?: boolean
    profileId?: boolean
  }

  export type StudentTrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type StudentTrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $StudentTrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTraining"
    objects: {
      profile: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      category: string
      level: string
      instructor: string
      hours: number | null
      completionDate: Date | null
      startDate: Date | null
      status: string
      progress: number | null
      certificate: boolean
      profileId: number
    }, ExtArgs["result"]["studentTraining"]>
    composites: {}
  }

  type StudentTrainingGetPayload<S extends boolean | null | undefined | StudentTrainingDefaultArgs> = $Result.GetResult<Prisma.$StudentTrainingPayload, S>

  type StudentTrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentTrainingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentTrainingCountAggregateInputType | true
    }

  export interface StudentTrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTraining'], meta: { name: 'StudentTraining' } }
    /**
     * Find zero or one StudentTraining that matches the filter.
     * @param {StudentTrainingFindUniqueArgs} args - Arguments to find a StudentTraining
     * @example
     * // Get one StudentTraining
     * const studentTraining = await prisma.studentTraining.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTrainingFindUniqueArgs>(args: SelectSubset<T, StudentTrainingFindUniqueArgs<ExtArgs>>): Prisma__StudentTrainingClient<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentTraining that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentTrainingFindUniqueOrThrowArgs} args - Arguments to find a StudentTraining
     * @example
     * // Get one StudentTraining
     * const studentTraining = await prisma.studentTraining.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTrainingClient<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentTraining that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingFindFirstArgs} args - Arguments to find a StudentTraining
     * @example
     * // Get one StudentTraining
     * const studentTraining = await prisma.studentTraining.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTrainingFindFirstArgs>(args?: SelectSubset<T, StudentTrainingFindFirstArgs<ExtArgs>>): Prisma__StudentTrainingClient<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentTraining that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingFindFirstOrThrowArgs} args - Arguments to find a StudentTraining
     * @example
     * // Get one StudentTraining
     * const studentTraining = await prisma.studentTraining.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTrainingClient<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentTrainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTrainings
     * const studentTrainings = await prisma.studentTraining.findMany()
     * 
     * // Get first 10 StudentTrainings
     * const studentTrainings = await prisma.studentTraining.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTrainingWithIdOnly = await prisma.studentTraining.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTrainingFindManyArgs>(args?: SelectSubset<T, StudentTrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentTraining.
     * @param {StudentTrainingCreateArgs} args - Arguments to create a StudentTraining.
     * @example
     * // Create one StudentTraining
     * const StudentTraining = await prisma.studentTraining.create({
     *   data: {
     *     // ... data to create a StudentTraining
     *   }
     * })
     * 
     */
    create<T extends StudentTrainingCreateArgs>(args: SelectSubset<T, StudentTrainingCreateArgs<ExtArgs>>): Prisma__StudentTrainingClient<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentTrainings.
     * @param {StudentTrainingCreateManyArgs} args - Arguments to create many StudentTrainings.
     * @example
     * // Create many StudentTrainings
     * const studentTraining = await prisma.studentTraining.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTrainingCreateManyArgs>(args?: SelectSubset<T, StudentTrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTrainings and returns the data saved in the database.
     * @param {StudentTrainingCreateManyAndReturnArgs} args - Arguments to create many StudentTrainings.
     * @example
     * // Create many StudentTrainings
     * const studentTraining = await prisma.studentTraining.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTrainings and only return the `id`
     * const studentTrainingWithIdOnly = await prisma.studentTraining.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentTraining.
     * @param {StudentTrainingDeleteArgs} args - Arguments to delete one StudentTraining.
     * @example
     * // Delete one StudentTraining
     * const StudentTraining = await prisma.studentTraining.delete({
     *   where: {
     *     // ... filter to delete one StudentTraining
     *   }
     * })
     * 
     */
    delete<T extends StudentTrainingDeleteArgs>(args: SelectSubset<T, StudentTrainingDeleteArgs<ExtArgs>>): Prisma__StudentTrainingClient<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentTraining.
     * @param {StudentTrainingUpdateArgs} args - Arguments to update one StudentTraining.
     * @example
     * // Update one StudentTraining
     * const studentTraining = await prisma.studentTraining.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTrainingUpdateArgs>(args: SelectSubset<T, StudentTrainingUpdateArgs<ExtArgs>>): Prisma__StudentTrainingClient<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentTrainings.
     * @param {StudentTrainingDeleteManyArgs} args - Arguments to filter StudentTrainings to delete.
     * @example
     * // Delete a few StudentTrainings
     * const { count } = await prisma.studentTraining.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTrainingDeleteManyArgs>(args?: SelectSubset<T, StudentTrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTrainings
     * const studentTraining = await prisma.studentTraining.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTrainingUpdateManyArgs>(args: SelectSubset<T, StudentTrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentTraining.
     * @param {StudentTrainingUpsertArgs} args - Arguments to update or create a StudentTraining.
     * @example
     * // Update or create a StudentTraining
     * const studentTraining = await prisma.studentTraining.upsert({
     *   create: {
     *     // ... data to create a StudentTraining
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTraining we want to update
     *   }
     * })
     */
    upsert<T extends StudentTrainingUpsertArgs>(args: SelectSubset<T, StudentTrainingUpsertArgs<ExtArgs>>): Prisma__StudentTrainingClient<$Result.GetResult<Prisma.$StudentTrainingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingCountArgs} args - Arguments to filter StudentTrainings to count.
     * @example
     * // Count the number of StudentTrainings
     * const count = await prisma.studentTraining.count({
     *   where: {
     *     // ... the filter for the StudentTrainings we want to count
     *   }
     * })
    **/
    count<T extends StudentTrainingCountArgs>(
      args?: Subset<T, StudentTrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTrainingAggregateArgs>(args: Subset<T, StudentTrainingAggregateArgs>): Prisma.PrismaPromise<GetStudentTrainingAggregateType<T>>

    /**
     * Group by StudentTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTrainingGroupByArgs['orderBy'] }
        : { orderBy?: StudentTrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTraining model
   */
  readonly fields: StudentTrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTraining.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTraining model
   */ 
  interface StudentTrainingFieldRefs {
    readonly id: FieldRef<"StudentTraining", 'Int'>
    readonly title: FieldRef<"StudentTraining", 'String'>
    readonly category: FieldRef<"StudentTraining", 'String'>
    readonly level: FieldRef<"StudentTraining", 'String'>
    readonly instructor: FieldRef<"StudentTraining", 'String'>
    readonly hours: FieldRef<"StudentTraining", 'Int'>
    readonly completionDate: FieldRef<"StudentTraining", 'DateTime'>
    readonly startDate: FieldRef<"StudentTraining", 'DateTime'>
    readonly status: FieldRef<"StudentTraining", 'String'>
    readonly progress: FieldRef<"StudentTraining", 'Int'>
    readonly certificate: FieldRef<"StudentTraining", 'Boolean'>
    readonly profileId: FieldRef<"StudentTraining", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StudentTraining findUnique
   */
  export type StudentTrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * Filter, which StudentTraining to fetch.
     */
    where: StudentTrainingWhereUniqueInput
  }

  /**
   * StudentTraining findUniqueOrThrow
   */
  export type StudentTrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * Filter, which StudentTraining to fetch.
     */
    where: StudentTrainingWhereUniqueInput
  }

  /**
   * StudentTraining findFirst
   */
  export type StudentTrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * Filter, which StudentTraining to fetch.
     */
    where?: StudentTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTrainings to fetch.
     */
    orderBy?: StudentTrainingOrderByWithRelationInput | StudentTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTrainings.
     */
    cursor?: StudentTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTrainings.
     */
    distinct?: StudentTrainingScalarFieldEnum | StudentTrainingScalarFieldEnum[]
  }

  /**
   * StudentTraining findFirstOrThrow
   */
  export type StudentTrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * Filter, which StudentTraining to fetch.
     */
    where?: StudentTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTrainings to fetch.
     */
    orderBy?: StudentTrainingOrderByWithRelationInput | StudentTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTrainings.
     */
    cursor?: StudentTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTrainings.
     */
    distinct?: StudentTrainingScalarFieldEnum | StudentTrainingScalarFieldEnum[]
  }

  /**
   * StudentTraining findMany
   */
  export type StudentTrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * Filter, which StudentTrainings to fetch.
     */
    where?: StudentTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTrainings to fetch.
     */
    orderBy?: StudentTrainingOrderByWithRelationInput | StudentTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTrainings.
     */
    cursor?: StudentTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTrainings.
     */
    skip?: number
    distinct?: StudentTrainingScalarFieldEnum | StudentTrainingScalarFieldEnum[]
  }

  /**
   * StudentTraining create
   */
  export type StudentTrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTraining.
     */
    data: XOR<StudentTrainingCreateInput, StudentTrainingUncheckedCreateInput>
  }

  /**
   * StudentTraining createMany
   */
  export type StudentTrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTrainings.
     */
    data: StudentTrainingCreateManyInput | StudentTrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTraining createManyAndReturn
   */
  export type StudentTrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentTrainings.
     */
    data: StudentTrainingCreateManyInput | StudentTrainingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTraining update
   */
  export type StudentTrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTraining.
     */
    data: XOR<StudentTrainingUpdateInput, StudentTrainingUncheckedUpdateInput>
    /**
     * Choose, which StudentTraining to update.
     */
    where: StudentTrainingWhereUniqueInput
  }

  /**
   * StudentTraining updateMany
   */
  export type StudentTrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTrainings.
     */
    data: XOR<StudentTrainingUpdateManyMutationInput, StudentTrainingUncheckedUpdateManyInput>
    /**
     * Filter which StudentTrainings to update
     */
    where?: StudentTrainingWhereInput
  }

  /**
   * StudentTraining upsert
   */
  export type StudentTrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTraining to update in case it exists.
     */
    where: StudentTrainingWhereUniqueInput
    /**
     * In case the StudentTraining found by the `where` argument doesn't exist, create a new StudentTraining with this data.
     */
    create: XOR<StudentTrainingCreateInput, StudentTrainingUncheckedCreateInput>
    /**
     * In case the StudentTraining was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTrainingUpdateInput, StudentTrainingUncheckedUpdateInput>
  }

  /**
   * StudentTraining delete
   */
  export type StudentTrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
    /**
     * Filter which StudentTraining to delete.
     */
    where: StudentTrainingWhereUniqueInput
  }

  /**
   * StudentTraining deleteMany
   */
  export type StudentTrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTrainings to delete
     */
    where?: StudentTrainingWhereInput
  }

  /**
   * StudentTraining without action
   */
  export type StudentTrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTraining
     */
    select?: StudentTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTrainingInclude<ExtArgs> | null
  }


  /**
   * Model StudentTestimonial
   */

  export type AggregateStudentTestimonial = {
    _count: StudentTestimonialCountAggregateOutputType | null
    _avg: StudentTestimonialAvgAggregateOutputType | null
    _sum: StudentTestimonialSumAggregateOutputType | null
    _min: StudentTestimonialMinAggregateOutputType | null
    _max: StudentTestimonialMaxAggregateOutputType | null
  }

  export type StudentTestimonialAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    profileId: number | null
  }

  export type StudentTestimonialSumAggregateOutputType = {
    id: number | null
    rating: number | null
    profileId: number | null
  }

  export type StudentTestimonialMinAggregateOutputType = {
    id: number | null
    author: string | null
    role: string | null
    content: string | null
    rating: number | null
    date: Date | null
    profileId: number | null
  }

  export type StudentTestimonialMaxAggregateOutputType = {
    id: number | null
    author: string | null
    role: string | null
    content: string | null
    rating: number | null
    date: Date | null
    profileId: number | null
  }

  export type StudentTestimonialCountAggregateOutputType = {
    id: number
    author: number
    role: number
    content: number
    rating: number
    date: number
    profileId: number
    _all: number
  }


  export type StudentTestimonialAvgAggregateInputType = {
    id?: true
    rating?: true
    profileId?: true
  }

  export type StudentTestimonialSumAggregateInputType = {
    id?: true
    rating?: true
    profileId?: true
  }

  export type StudentTestimonialMinAggregateInputType = {
    id?: true
    author?: true
    role?: true
    content?: true
    rating?: true
    date?: true
    profileId?: true
  }

  export type StudentTestimonialMaxAggregateInputType = {
    id?: true
    author?: true
    role?: true
    content?: true
    rating?: true
    date?: true
    profileId?: true
  }

  export type StudentTestimonialCountAggregateInputType = {
    id?: true
    author?: true
    role?: true
    content?: true
    rating?: true
    date?: true
    profileId?: true
    _all?: true
  }

  export type StudentTestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTestimonial to aggregate.
     */
    where?: StudentTestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTestimonials to fetch.
     */
    orderBy?: StudentTestimonialOrderByWithRelationInput | StudentTestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTestimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTestimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTestimonials
    **/
    _count?: true | StudentTestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTestimonialMaxAggregateInputType
  }

  export type GetStudentTestimonialAggregateType<T extends StudentTestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTestimonial[P]>
      : GetScalarType<T[P], AggregateStudentTestimonial[P]>
  }




  export type StudentTestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTestimonialWhereInput
    orderBy?: StudentTestimonialOrderByWithAggregationInput | StudentTestimonialOrderByWithAggregationInput[]
    by: StudentTestimonialScalarFieldEnum[] | StudentTestimonialScalarFieldEnum
    having?: StudentTestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTestimonialCountAggregateInputType | true
    _avg?: StudentTestimonialAvgAggregateInputType
    _sum?: StudentTestimonialSumAggregateInputType
    _min?: StudentTestimonialMinAggregateInputType
    _max?: StudentTestimonialMaxAggregateInputType
  }

  export type StudentTestimonialGroupByOutputType = {
    id: number
    author: string
    role: string
    content: string
    rating: number
    date: Date
    profileId: number
    _count: StudentTestimonialCountAggregateOutputType | null
    _avg: StudentTestimonialAvgAggregateOutputType | null
    _sum: StudentTestimonialSumAggregateOutputType | null
    _min: StudentTestimonialMinAggregateOutputType | null
    _max: StudentTestimonialMaxAggregateOutputType | null
  }

  type GetStudentTestimonialGroupByPayload<T extends StudentTestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTestimonialGroupByOutputType[P]>
        }
      >
    >


  export type StudentTestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    author?: boolean
    role?: boolean
    content?: boolean
    rating?: boolean
    date?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTestimonial"]>

  export type StudentTestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    author?: boolean
    role?: boolean
    content?: boolean
    rating?: boolean
    date?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTestimonial"]>

  export type StudentTestimonialSelectScalar = {
    id?: boolean
    author?: boolean
    role?: boolean
    content?: boolean
    rating?: boolean
    date?: boolean
    profileId?: boolean
  }

  export type StudentTestimonialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type StudentTestimonialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $StudentTestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTestimonial"
    objects: {
      profile: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      author: string
      role: string
      content: string
      rating: number
      date: Date
      profileId: number
    }, ExtArgs["result"]["studentTestimonial"]>
    composites: {}
  }

  type StudentTestimonialGetPayload<S extends boolean | null | undefined | StudentTestimonialDefaultArgs> = $Result.GetResult<Prisma.$StudentTestimonialPayload, S>

  type StudentTestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentTestimonialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentTestimonialCountAggregateInputType | true
    }

  export interface StudentTestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTestimonial'], meta: { name: 'StudentTestimonial' } }
    /**
     * Find zero or one StudentTestimonial that matches the filter.
     * @param {StudentTestimonialFindUniqueArgs} args - Arguments to find a StudentTestimonial
     * @example
     * // Get one StudentTestimonial
     * const studentTestimonial = await prisma.studentTestimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTestimonialFindUniqueArgs>(args: SelectSubset<T, StudentTestimonialFindUniqueArgs<ExtArgs>>): Prisma__StudentTestimonialClient<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentTestimonial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentTestimonialFindUniqueOrThrowArgs} args - Arguments to find a StudentTestimonial
     * @example
     * // Get one StudentTestimonial
     * const studentTestimonial = await prisma.studentTestimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTestimonialClient<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentTestimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestimonialFindFirstArgs} args - Arguments to find a StudentTestimonial
     * @example
     * // Get one StudentTestimonial
     * const studentTestimonial = await prisma.studentTestimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTestimonialFindFirstArgs>(args?: SelectSubset<T, StudentTestimonialFindFirstArgs<ExtArgs>>): Prisma__StudentTestimonialClient<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentTestimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestimonialFindFirstOrThrowArgs} args - Arguments to find a StudentTestimonial
     * @example
     * // Get one StudentTestimonial
     * const studentTestimonial = await prisma.studentTestimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTestimonialClient<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentTestimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTestimonials
     * const studentTestimonials = await prisma.studentTestimonial.findMany()
     * 
     * // Get first 10 StudentTestimonials
     * const studentTestimonials = await prisma.studentTestimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTestimonialWithIdOnly = await prisma.studentTestimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTestimonialFindManyArgs>(args?: SelectSubset<T, StudentTestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentTestimonial.
     * @param {StudentTestimonialCreateArgs} args - Arguments to create a StudentTestimonial.
     * @example
     * // Create one StudentTestimonial
     * const StudentTestimonial = await prisma.studentTestimonial.create({
     *   data: {
     *     // ... data to create a StudentTestimonial
     *   }
     * })
     * 
     */
    create<T extends StudentTestimonialCreateArgs>(args: SelectSubset<T, StudentTestimonialCreateArgs<ExtArgs>>): Prisma__StudentTestimonialClient<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentTestimonials.
     * @param {StudentTestimonialCreateManyArgs} args - Arguments to create many StudentTestimonials.
     * @example
     * // Create many StudentTestimonials
     * const studentTestimonial = await prisma.studentTestimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTestimonialCreateManyArgs>(args?: SelectSubset<T, StudentTestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTestimonials and returns the data saved in the database.
     * @param {StudentTestimonialCreateManyAndReturnArgs} args - Arguments to create many StudentTestimonials.
     * @example
     * // Create many StudentTestimonials
     * const studentTestimonial = await prisma.studentTestimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTestimonials and only return the `id`
     * const studentTestimonialWithIdOnly = await prisma.studentTestimonial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentTestimonial.
     * @param {StudentTestimonialDeleteArgs} args - Arguments to delete one StudentTestimonial.
     * @example
     * // Delete one StudentTestimonial
     * const StudentTestimonial = await prisma.studentTestimonial.delete({
     *   where: {
     *     // ... filter to delete one StudentTestimonial
     *   }
     * })
     * 
     */
    delete<T extends StudentTestimonialDeleteArgs>(args: SelectSubset<T, StudentTestimonialDeleteArgs<ExtArgs>>): Prisma__StudentTestimonialClient<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentTestimonial.
     * @param {StudentTestimonialUpdateArgs} args - Arguments to update one StudentTestimonial.
     * @example
     * // Update one StudentTestimonial
     * const studentTestimonial = await prisma.studentTestimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTestimonialUpdateArgs>(args: SelectSubset<T, StudentTestimonialUpdateArgs<ExtArgs>>): Prisma__StudentTestimonialClient<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentTestimonials.
     * @param {StudentTestimonialDeleteManyArgs} args - Arguments to filter StudentTestimonials to delete.
     * @example
     * // Delete a few StudentTestimonials
     * const { count } = await prisma.studentTestimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTestimonialDeleteManyArgs>(args?: SelectSubset<T, StudentTestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTestimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTestimonials
     * const studentTestimonial = await prisma.studentTestimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTestimonialUpdateManyArgs>(args: SelectSubset<T, StudentTestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentTestimonial.
     * @param {StudentTestimonialUpsertArgs} args - Arguments to update or create a StudentTestimonial.
     * @example
     * // Update or create a StudentTestimonial
     * const studentTestimonial = await prisma.studentTestimonial.upsert({
     *   create: {
     *     // ... data to create a StudentTestimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTestimonial we want to update
     *   }
     * })
     */
    upsert<T extends StudentTestimonialUpsertArgs>(args: SelectSubset<T, StudentTestimonialUpsertArgs<ExtArgs>>): Prisma__StudentTestimonialClient<$Result.GetResult<Prisma.$StudentTestimonialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentTestimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestimonialCountArgs} args - Arguments to filter StudentTestimonials to count.
     * @example
     * // Count the number of StudentTestimonials
     * const count = await prisma.studentTestimonial.count({
     *   where: {
     *     // ... the filter for the StudentTestimonials we want to count
     *   }
     * })
    **/
    count<T extends StudentTestimonialCountArgs>(
      args?: Subset<T, StudentTestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTestimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTestimonialAggregateArgs>(args: Subset<T, StudentTestimonialAggregateArgs>): Prisma.PrismaPromise<GetStudentTestimonialAggregateType<T>>

    /**
     * Group by StudentTestimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTestimonialGroupByArgs['orderBy'] }
        : { orderBy?: StudentTestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTestimonial model
   */
  readonly fields: StudentTestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTestimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTestimonial model
   */ 
  interface StudentTestimonialFieldRefs {
    readonly id: FieldRef<"StudentTestimonial", 'Int'>
    readonly author: FieldRef<"StudentTestimonial", 'String'>
    readonly role: FieldRef<"StudentTestimonial", 'String'>
    readonly content: FieldRef<"StudentTestimonial", 'String'>
    readonly rating: FieldRef<"StudentTestimonial", 'Int'>
    readonly date: FieldRef<"StudentTestimonial", 'DateTime'>
    readonly profileId: FieldRef<"StudentTestimonial", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StudentTestimonial findUnique
   */
  export type StudentTestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which StudentTestimonial to fetch.
     */
    where: StudentTestimonialWhereUniqueInput
  }

  /**
   * StudentTestimonial findUniqueOrThrow
   */
  export type StudentTestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which StudentTestimonial to fetch.
     */
    where: StudentTestimonialWhereUniqueInput
  }

  /**
   * StudentTestimonial findFirst
   */
  export type StudentTestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which StudentTestimonial to fetch.
     */
    where?: StudentTestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTestimonials to fetch.
     */
    orderBy?: StudentTestimonialOrderByWithRelationInput | StudentTestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTestimonials.
     */
    cursor?: StudentTestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTestimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTestimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTestimonials.
     */
    distinct?: StudentTestimonialScalarFieldEnum | StudentTestimonialScalarFieldEnum[]
  }

  /**
   * StudentTestimonial findFirstOrThrow
   */
  export type StudentTestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which StudentTestimonial to fetch.
     */
    where?: StudentTestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTestimonials to fetch.
     */
    orderBy?: StudentTestimonialOrderByWithRelationInput | StudentTestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTestimonials.
     */
    cursor?: StudentTestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTestimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTestimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTestimonials.
     */
    distinct?: StudentTestimonialScalarFieldEnum | StudentTestimonialScalarFieldEnum[]
  }

  /**
   * StudentTestimonial findMany
   */
  export type StudentTestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * Filter, which StudentTestimonials to fetch.
     */
    where?: StudentTestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTestimonials to fetch.
     */
    orderBy?: StudentTestimonialOrderByWithRelationInput | StudentTestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTestimonials.
     */
    cursor?: StudentTestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTestimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTestimonials.
     */
    skip?: number
    distinct?: StudentTestimonialScalarFieldEnum | StudentTestimonialScalarFieldEnum[]
  }

  /**
   * StudentTestimonial create
   */
  export type StudentTestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTestimonial.
     */
    data: XOR<StudentTestimonialCreateInput, StudentTestimonialUncheckedCreateInput>
  }

  /**
   * StudentTestimonial createMany
   */
  export type StudentTestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTestimonials.
     */
    data: StudentTestimonialCreateManyInput | StudentTestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTestimonial createManyAndReturn
   */
  export type StudentTestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentTestimonials.
     */
    data: StudentTestimonialCreateManyInput | StudentTestimonialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTestimonial update
   */
  export type StudentTestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTestimonial.
     */
    data: XOR<StudentTestimonialUpdateInput, StudentTestimonialUncheckedUpdateInput>
    /**
     * Choose, which StudentTestimonial to update.
     */
    where: StudentTestimonialWhereUniqueInput
  }

  /**
   * StudentTestimonial updateMany
   */
  export type StudentTestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTestimonials.
     */
    data: XOR<StudentTestimonialUpdateManyMutationInput, StudentTestimonialUncheckedUpdateManyInput>
    /**
     * Filter which StudentTestimonials to update
     */
    where?: StudentTestimonialWhereInput
  }

  /**
   * StudentTestimonial upsert
   */
  export type StudentTestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTestimonial to update in case it exists.
     */
    where: StudentTestimonialWhereUniqueInput
    /**
     * In case the StudentTestimonial found by the `where` argument doesn't exist, create a new StudentTestimonial with this data.
     */
    create: XOR<StudentTestimonialCreateInput, StudentTestimonialUncheckedCreateInput>
    /**
     * In case the StudentTestimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTestimonialUpdateInput, StudentTestimonialUncheckedUpdateInput>
  }

  /**
   * StudentTestimonial delete
   */
  export type StudentTestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
    /**
     * Filter which StudentTestimonial to delete.
     */
    where: StudentTestimonialWhereUniqueInput
  }

  /**
   * StudentTestimonial deleteMany
   */
  export type StudentTestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTestimonials to delete
     */
    where?: StudentTestimonialWhereInput
  }

  /**
   * StudentTestimonial without action
   */
  export type StudentTestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTestimonial
     */
    select?: StudentTestimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestimonialInclude<ExtArgs> | null
  }


  /**
   * Model StudentSubject
   */

  export type AggregateStudentSubject = {
    _count: StudentSubjectCountAggregateOutputType | null
    _avg: StudentSubjectAvgAggregateOutputType | null
    _sum: StudentSubjectSumAggregateOutputType | null
    _min: StudentSubjectMinAggregateOutputType | null
    _max: StudentSubjectMaxAggregateOutputType | null
  }

  export type StudentSubjectAvgAggregateOutputType = {
    id: number | null
    credits: number | null
    profileId: number | null
  }

  export type StudentSubjectSumAggregateOutputType = {
    id: number | null
    credits: number | null
    profileId: number | null
  }

  export type StudentSubjectMinAggregateOutputType = {
    id: number | null
    name: string | null
    grade: string | null
    credits: number | null
    semester: string | null
    profileId: number | null
  }

  export type StudentSubjectMaxAggregateOutputType = {
    id: number | null
    name: string | null
    grade: string | null
    credits: number | null
    semester: string | null
    profileId: number | null
  }

  export type StudentSubjectCountAggregateOutputType = {
    id: number
    name: number
    grade: number
    credits: number
    semester: number
    profileId: number
    _all: number
  }


  export type StudentSubjectAvgAggregateInputType = {
    id?: true
    credits?: true
    profileId?: true
  }

  export type StudentSubjectSumAggregateInputType = {
    id?: true
    credits?: true
    profileId?: true
  }

  export type StudentSubjectMinAggregateInputType = {
    id?: true
    name?: true
    grade?: true
    credits?: true
    semester?: true
    profileId?: true
  }

  export type StudentSubjectMaxAggregateInputType = {
    id?: true
    name?: true
    grade?: true
    credits?: true
    semester?: true
    profileId?: true
  }

  export type StudentSubjectCountAggregateInputType = {
    id?: true
    name?: true
    grade?: true
    credits?: true
    semester?: true
    profileId?: true
    _all?: true
  }

  export type StudentSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSubject to aggregate.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSubjects
    **/
    _count?: true | StudentSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSubjectMaxAggregateInputType
  }

  export type GetStudentSubjectAggregateType<T extends StudentSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSubject[P]>
      : GetScalarType<T[P], AggregateStudentSubject[P]>
  }




  export type StudentSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSubjectWhereInput
    orderBy?: StudentSubjectOrderByWithAggregationInput | StudentSubjectOrderByWithAggregationInput[]
    by: StudentSubjectScalarFieldEnum[] | StudentSubjectScalarFieldEnum
    having?: StudentSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSubjectCountAggregateInputType | true
    _avg?: StudentSubjectAvgAggregateInputType
    _sum?: StudentSubjectSumAggregateInputType
    _min?: StudentSubjectMinAggregateInputType
    _max?: StudentSubjectMaxAggregateInputType
  }

  export type StudentSubjectGroupByOutputType = {
    id: number
    name: string
    grade: string
    credits: number
    semester: string
    profileId: number
    _count: StudentSubjectCountAggregateOutputType | null
    _avg: StudentSubjectAvgAggregateOutputType | null
    _sum: StudentSubjectSumAggregateOutputType | null
    _min: StudentSubjectMinAggregateOutputType | null
    _max: StudentSubjectMaxAggregateOutputType | null
  }

  type GetStudentSubjectGroupByPayload<T extends StudentSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSubjectGroupByOutputType[P]>
        }
      >
    >


  export type StudentSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    grade?: boolean
    credits?: boolean
    semester?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSubject"]>

  export type StudentSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    grade?: boolean
    credits?: boolean
    semester?: boolean
    profileId?: boolean
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSubject"]>

  export type StudentSubjectSelectScalar = {
    id?: boolean
    name?: boolean
    grade?: boolean
    credits?: boolean
    semester?: boolean
    profileId?: boolean
  }

  export type StudentSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type StudentSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $StudentSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSubject"
    objects: {
      profile: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      grade: string
      credits: number
      semester: string
      profileId: number
    }, ExtArgs["result"]["studentSubject"]>
    composites: {}
  }

  type StudentSubjectGetPayload<S extends boolean | null | undefined | StudentSubjectDefaultArgs> = $Result.GetResult<Prisma.$StudentSubjectPayload, S>

  type StudentSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentSubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentSubjectCountAggregateInputType | true
    }

  export interface StudentSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSubject'], meta: { name: 'StudentSubject' } }
    /**
     * Find zero or one StudentSubject that matches the filter.
     * @param {StudentSubjectFindUniqueArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSubjectFindUniqueArgs>(args: SelectSubset<T, StudentSubjectFindUniqueArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentSubject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentSubjectFindUniqueOrThrowArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindFirstArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSubjectFindFirstArgs>(args?: SelectSubset<T, StudentSubjectFindFirstArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindFirstOrThrowArgs} args - Arguments to find a StudentSubject
     * @example
     * // Get one StudentSubject
     * const studentSubject = await prisma.studentSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSubjects
     * const studentSubjects = await prisma.studentSubject.findMany()
     * 
     * // Get first 10 StudentSubjects
     * const studentSubjects = await prisma.studentSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSubjectWithIdOnly = await prisma.studentSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSubjectFindManyArgs>(args?: SelectSubset<T, StudentSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentSubject.
     * @param {StudentSubjectCreateArgs} args - Arguments to create a StudentSubject.
     * @example
     * // Create one StudentSubject
     * const StudentSubject = await prisma.studentSubject.create({
     *   data: {
     *     // ... data to create a StudentSubject
     *   }
     * })
     * 
     */
    create<T extends StudentSubjectCreateArgs>(args: SelectSubset<T, StudentSubjectCreateArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentSubjects.
     * @param {StudentSubjectCreateManyArgs} args - Arguments to create many StudentSubjects.
     * @example
     * // Create many StudentSubjects
     * const studentSubject = await prisma.studentSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSubjectCreateManyArgs>(args?: SelectSubset<T, StudentSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSubjects and returns the data saved in the database.
     * @param {StudentSubjectCreateManyAndReturnArgs} args - Arguments to create many StudentSubjects.
     * @example
     * // Create many StudentSubjects
     * const studentSubject = await prisma.studentSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSubjects and only return the `id`
     * const studentSubjectWithIdOnly = await prisma.studentSubject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentSubject.
     * @param {StudentSubjectDeleteArgs} args - Arguments to delete one StudentSubject.
     * @example
     * // Delete one StudentSubject
     * const StudentSubject = await prisma.studentSubject.delete({
     *   where: {
     *     // ... filter to delete one StudentSubject
     *   }
     * })
     * 
     */
    delete<T extends StudentSubjectDeleteArgs>(args: SelectSubset<T, StudentSubjectDeleteArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentSubject.
     * @param {StudentSubjectUpdateArgs} args - Arguments to update one StudentSubject.
     * @example
     * // Update one StudentSubject
     * const studentSubject = await prisma.studentSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSubjectUpdateArgs>(args: SelectSubset<T, StudentSubjectUpdateArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentSubjects.
     * @param {StudentSubjectDeleteManyArgs} args - Arguments to filter StudentSubjects to delete.
     * @example
     * // Delete a few StudentSubjects
     * const { count } = await prisma.studentSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSubjectDeleteManyArgs>(args?: SelectSubset<T, StudentSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSubjects
     * const studentSubject = await prisma.studentSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSubjectUpdateManyArgs>(args: SelectSubset<T, StudentSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSubject.
     * @param {StudentSubjectUpsertArgs} args - Arguments to update or create a StudentSubject.
     * @example
     * // Update or create a StudentSubject
     * const studentSubject = await prisma.studentSubject.upsert({
     *   create: {
     *     // ... data to create a StudentSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSubject we want to update
     *   }
     * })
     */
    upsert<T extends StudentSubjectUpsertArgs>(args: SelectSubset<T, StudentSubjectUpsertArgs<ExtArgs>>): Prisma__StudentSubjectClient<$Result.GetResult<Prisma.$StudentSubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectCountArgs} args - Arguments to filter StudentSubjects to count.
     * @example
     * // Count the number of StudentSubjects
     * const count = await prisma.studentSubject.count({
     *   where: {
     *     // ... the filter for the StudentSubjects we want to count
     *   }
     * })
    **/
    count<T extends StudentSubjectCountArgs>(
      args?: Subset<T, StudentSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSubjectAggregateArgs>(args: Subset<T, StudentSubjectAggregateArgs>): Prisma.PrismaPromise<GetStudentSubjectAggregateType<T>>

    /**
     * Group by StudentSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSubjectGroupByArgs['orderBy'] }
        : { orderBy?: StudentSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSubject model
   */
  readonly fields: StudentSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSubject model
   */ 
  interface StudentSubjectFieldRefs {
    readonly id: FieldRef<"StudentSubject", 'Int'>
    readonly name: FieldRef<"StudentSubject", 'String'>
    readonly grade: FieldRef<"StudentSubject", 'String'>
    readonly credits: FieldRef<"StudentSubject", 'Int'>
    readonly semester: FieldRef<"StudentSubject", 'String'>
    readonly profileId: FieldRef<"StudentSubject", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StudentSubject findUnique
   */
  export type StudentSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject findUniqueOrThrow
   */
  export type StudentSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject findFirst
   */
  export type StudentSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSubjects.
     */
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject findFirstOrThrow
   */
  export type StudentSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubject to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSubjects.
     */
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject findMany
   */
  export type StudentSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter, which StudentSubjects to fetch.
     */
    where?: StudentSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSubjects to fetch.
     */
    orderBy?: StudentSubjectOrderByWithRelationInput | StudentSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSubjects.
     */
    cursor?: StudentSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSubjects.
     */
    skip?: number
    distinct?: StudentSubjectScalarFieldEnum | StudentSubjectScalarFieldEnum[]
  }

  /**
   * StudentSubject create
   */
  export type StudentSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSubject.
     */
    data: XOR<StudentSubjectCreateInput, StudentSubjectUncheckedCreateInput>
  }

  /**
   * StudentSubject createMany
   */
  export type StudentSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSubjects.
     */
    data: StudentSubjectCreateManyInput | StudentSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSubject createManyAndReturn
   */
  export type StudentSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentSubjects.
     */
    data: StudentSubjectCreateManyInput | StudentSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSubject update
   */
  export type StudentSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSubject.
     */
    data: XOR<StudentSubjectUpdateInput, StudentSubjectUncheckedUpdateInput>
    /**
     * Choose, which StudentSubject to update.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject updateMany
   */
  export type StudentSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSubjects.
     */
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyInput>
    /**
     * Filter which StudentSubjects to update
     */
    where?: StudentSubjectWhereInput
  }

  /**
   * StudentSubject upsert
   */
  export type StudentSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSubject to update in case it exists.
     */
    where: StudentSubjectWhereUniqueInput
    /**
     * In case the StudentSubject found by the `where` argument doesn't exist, create a new StudentSubject with this data.
     */
    create: XOR<StudentSubjectCreateInput, StudentSubjectUncheckedCreateInput>
    /**
     * In case the StudentSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSubjectUpdateInput, StudentSubjectUncheckedUpdateInput>
  }

  /**
   * StudentSubject delete
   */
  export type StudentSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
    /**
     * Filter which StudentSubject to delete.
     */
    where: StudentSubjectWhereUniqueInput
  }

  /**
   * StudentSubject deleteMany
   */
  export type StudentSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSubjects to delete
     */
    where?: StudentSubjectWhereInput
  }

  /**
   * StudentSubject without action
   */
  export type StudentSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSubject
     */
    select?: StudentSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSubjectInclude<ExtArgs> | null
  }


  /**
   * Model TrainingReview
   */

  export type AggregateTrainingReview = {
    _count: TrainingReviewCountAggregateOutputType | null
    _avg: TrainingReviewAvgAggregateOutputType | null
    _sum: TrainingReviewSumAggregateOutputType | null
    _min: TrainingReviewMinAggregateOutputType | null
    _max: TrainingReviewMaxAggregateOutputType | null
  }

  export type TrainingReviewAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    trainingId: number | null
    studentProfileId: number | null
    featuredStudentId: number | null
  }

  export type TrainingReviewSumAggregateOutputType = {
    id: number | null
    rating: number | null
    trainingId: number | null
    studentProfileId: number | null
    featuredStudentId: number | null
  }

  export type TrainingReviewMinAggregateOutputType = {
    id: number | null
    content: string | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
    trainingId: number | null
    studentProfileId: number | null
    featuredStudentId: number | null
  }

  export type TrainingReviewMaxAggregateOutputType = {
    id: number | null
    content: string | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
    trainingId: number | null
    studentProfileId: number | null
    featuredStudentId: number | null
  }

  export type TrainingReviewCountAggregateOutputType = {
    id: number
    content: number
    rating: number
    createdAt: number
    updatedAt: number
    trainingId: number
    studentProfileId: number
    featuredStudentId: number
    _all: number
  }


  export type TrainingReviewAvgAggregateInputType = {
    id?: true
    rating?: true
    trainingId?: true
    studentProfileId?: true
    featuredStudentId?: true
  }

  export type TrainingReviewSumAggregateInputType = {
    id?: true
    rating?: true
    trainingId?: true
    studentProfileId?: true
    featuredStudentId?: true
  }

  export type TrainingReviewMinAggregateInputType = {
    id?: true
    content?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    trainingId?: true
    studentProfileId?: true
    featuredStudentId?: true
  }

  export type TrainingReviewMaxAggregateInputType = {
    id?: true
    content?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    trainingId?: true
    studentProfileId?: true
    featuredStudentId?: true
  }

  export type TrainingReviewCountAggregateInputType = {
    id?: true
    content?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    trainingId?: true
    studentProfileId?: true
    featuredStudentId?: true
    _all?: true
  }

  export type TrainingReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingReview to aggregate.
     */
    where?: TrainingReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingReviews to fetch.
     */
    orderBy?: TrainingReviewOrderByWithRelationInput | TrainingReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingReviews
    **/
    _count?: true | TrainingReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingReviewMaxAggregateInputType
  }

  export type GetTrainingReviewAggregateType<T extends TrainingReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingReview[P]>
      : GetScalarType<T[P], AggregateTrainingReview[P]>
  }




  export type TrainingReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingReviewWhereInput
    orderBy?: TrainingReviewOrderByWithAggregationInput | TrainingReviewOrderByWithAggregationInput[]
    by: TrainingReviewScalarFieldEnum[] | TrainingReviewScalarFieldEnum
    having?: TrainingReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingReviewCountAggregateInputType | true
    _avg?: TrainingReviewAvgAggregateInputType
    _sum?: TrainingReviewSumAggregateInputType
    _min?: TrainingReviewMinAggregateInputType
    _max?: TrainingReviewMaxAggregateInputType
  }

  export type TrainingReviewGroupByOutputType = {
    id: number
    content: string
    rating: number
    createdAt: Date
    updatedAt: Date
    trainingId: number
    studentProfileId: number
    featuredStudentId: number | null
    _count: TrainingReviewCountAggregateOutputType | null
    _avg: TrainingReviewAvgAggregateOutputType | null
    _sum: TrainingReviewSumAggregateOutputType | null
    _min: TrainingReviewMinAggregateOutputType | null
    _max: TrainingReviewMaxAggregateOutputType | null
  }

  type GetTrainingReviewGroupByPayload<T extends TrainingReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingReviewGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingReviewGroupByOutputType[P]>
        }
      >
    >


  export type TrainingReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingId?: boolean
    studentProfileId?: boolean
    featuredStudentId?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    featuredStudent?: boolean | TrainingReview$featuredStudentArgs<ExtArgs>
  }, ExtArgs["result"]["trainingReview"]>

  export type TrainingReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingId?: boolean
    studentProfileId?: boolean
    featuredStudentId?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    featuredStudent?: boolean | TrainingReview$featuredStudentArgs<ExtArgs>
  }, ExtArgs["result"]["trainingReview"]>

  export type TrainingReviewSelectScalar = {
    id?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingId?: boolean
    studentProfileId?: boolean
    featuredStudentId?: boolean
  }

  export type TrainingReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    featuredStudent?: boolean | TrainingReview$featuredStudentArgs<ExtArgs>
  }
  export type TrainingReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    studentProfile?: boolean | StudentProfileDefaultArgs<ExtArgs>
    featuredStudent?: boolean | TrainingReview$featuredStudentArgs<ExtArgs>
  }

  export type $TrainingReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingReview"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs>
      featuredStudent: Prisma.$FeaturedStudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      rating: number
      createdAt: Date
      updatedAt: Date
      trainingId: number
      studentProfileId: number
      featuredStudentId: number | null
    }, ExtArgs["result"]["trainingReview"]>
    composites: {}
  }

  type TrainingReviewGetPayload<S extends boolean | null | undefined | TrainingReviewDefaultArgs> = $Result.GetResult<Prisma.$TrainingReviewPayload, S>

  type TrainingReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingReviewCountAggregateInputType | true
    }

  export interface TrainingReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingReview'], meta: { name: 'TrainingReview' } }
    /**
     * Find zero or one TrainingReview that matches the filter.
     * @param {TrainingReviewFindUniqueArgs} args - Arguments to find a TrainingReview
     * @example
     * // Get one TrainingReview
     * const trainingReview = await prisma.trainingReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingReviewFindUniqueArgs>(args: SelectSubset<T, TrainingReviewFindUniqueArgs<ExtArgs>>): Prisma__TrainingReviewClient<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingReviewFindUniqueOrThrowArgs} args - Arguments to find a TrainingReview
     * @example
     * // Get one TrainingReview
     * const trainingReview = await prisma.trainingReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingReviewClient<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingReviewFindFirstArgs} args - Arguments to find a TrainingReview
     * @example
     * // Get one TrainingReview
     * const trainingReview = await prisma.trainingReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingReviewFindFirstArgs>(args?: SelectSubset<T, TrainingReviewFindFirstArgs<ExtArgs>>): Prisma__TrainingReviewClient<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingReviewFindFirstOrThrowArgs} args - Arguments to find a TrainingReview
     * @example
     * // Get one TrainingReview
     * const trainingReview = await prisma.trainingReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingReviewClient<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingReviews
     * const trainingReviews = await prisma.trainingReview.findMany()
     * 
     * // Get first 10 TrainingReviews
     * const trainingReviews = await prisma.trainingReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingReviewWithIdOnly = await prisma.trainingReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingReviewFindManyArgs>(args?: SelectSubset<T, TrainingReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingReview.
     * @param {TrainingReviewCreateArgs} args - Arguments to create a TrainingReview.
     * @example
     * // Create one TrainingReview
     * const TrainingReview = await prisma.trainingReview.create({
     *   data: {
     *     // ... data to create a TrainingReview
     *   }
     * })
     * 
     */
    create<T extends TrainingReviewCreateArgs>(args: SelectSubset<T, TrainingReviewCreateArgs<ExtArgs>>): Prisma__TrainingReviewClient<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingReviews.
     * @param {TrainingReviewCreateManyArgs} args - Arguments to create many TrainingReviews.
     * @example
     * // Create many TrainingReviews
     * const trainingReview = await prisma.trainingReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingReviewCreateManyArgs>(args?: SelectSubset<T, TrainingReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingReviews and returns the data saved in the database.
     * @param {TrainingReviewCreateManyAndReturnArgs} args - Arguments to create many TrainingReviews.
     * @example
     * // Create many TrainingReviews
     * const trainingReview = await prisma.trainingReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingReviews and only return the `id`
     * const trainingReviewWithIdOnly = await prisma.trainingReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainingReview.
     * @param {TrainingReviewDeleteArgs} args - Arguments to delete one TrainingReview.
     * @example
     * // Delete one TrainingReview
     * const TrainingReview = await prisma.trainingReview.delete({
     *   where: {
     *     // ... filter to delete one TrainingReview
     *   }
     * })
     * 
     */
    delete<T extends TrainingReviewDeleteArgs>(args: SelectSubset<T, TrainingReviewDeleteArgs<ExtArgs>>): Prisma__TrainingReviewClient<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingReview.
     * @param {TrainingReviewUpdateArgs} args - Arguments to update one TrainingReview.
     * @example
     * // Update one TrainingReview
     * const trainingReview = await prisma.trainingReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingReviewUpdateArgs>(args: SelectSubset<T, TrainingReviewUpdateArgs<ExtArgs>>): Prisma__TrainingReviewClient<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingReviews.
     * @param {TrainingReviewDeleteManyArgs} args - Arguments to filter TrainingReviews to delete.
     * @example
     * // Delete a few TrainingReviews
     * const { count } = await prisma.trainingReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingReviewDeleteManyArgs>(args?: SelectSubset<T, TrainingReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingReviews
     * const trainingReview = await prisma.trainingReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingReviewUpdateManyArgs>(args: SelectSubset<T, TrainingReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingReview.
     * @param {TrainingReviewUpsertArgs} args - Arguments to update or create a TrainingReview.
     * @example
     * // Update or create a TrainingReview
     * const trainingReview = await prisma.trainingReview.upsert({
     *   create: {
     *     // ... data to create a TrainingReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingReview we want to update
     *   }
     * })
     */
    upsert<T extends TrainingReviewUpsertArgs>(args: SelectSubset<T, TrainingReviewUpsertArgs<ExtArgs>>): Prisma__TrainingReviewClient<$Result.GetResult<Prisma.$TrainingReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainingReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingReviewCountArgs} args - Arguments to filter TrainingReviews to count.
     * @example
     * // Count the number of TrainingReviews
     * const count = await prisma.trainingReview.count({
     *   where: {
     *     // ... the filter for the TrainingReviews we want to count
     *   }
     * })
    **/
    count<T extends TrainingReviewCountArgs>(
      args?: Subset<T, TrainingReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingReviewAggregateArgs>(args: Subset<T, TrainingReviewAggregateArgs>): Prisma.PrismaPromise<GetTrainingReviewAggregateType<T>>

    /**
     * Group by TrainingReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingReviewGroupByArgs['orderBy'] }
        : { orderBy?: TrainingReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingReview model
   */
  readonly fields: TrainingReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    studentProfile<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    featuredStudent<T extends TrainingReview$featuredStudentArgs<ExtArgs> = {}>(args?: Subset<T, TrainingReview$featuredStudentArgs<ExtArgs>>): Prisma__FeaturedStudentClient<$Result.GetResult<Prisma.$FeaturedStudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingReview model
   */ 
  interface TrainingReviewFieldRefs {
    readonly id: FieldRef<"TrainingReview", 'Int'>
    readonly content: FieldRef<"TrainingReview", 'String'>
    readonly rating: FieldRef<"TrainingReview", 'Int'>
    readonly createdAt: FieldRef<"TrainingReview", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingReview", 'DateTime'>
    readonly trainingId: FieldRef<"TrainingReview", 'Int'>
    readonly studentProfileId: FieldRef<"TrainingReview", 'Int'>
    readonly featuredStudentId: FieldRef<"TrainingReview", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TrainingReview findUnique
   */
  export type TrainingReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * Filter, which TrainingReview to fetch.
     */
    where: TrainingReviewWhereUniqueInput
  }

  /**
   * TrainingReview findUniqueOrThrow
   */
  export type TrainingReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * Filter, which TrainingReview to fetch.
     */
    where: TrainingReviewWhereUniqueInput
  }

  /**
   * TrainingReview findFirst
   */
  export type TrainingReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * Filter, which TrainingReview to fetch.
     */
    where?: TrainingReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingReviews to fetch.
     */
    orderBy?: TrainingReviewOrderByWithRelationInput | TrainingReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingReviews.
     */
    cursor?: TrainingReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingReviews.
     */
    distinct?: TrainingReviewScalarFieldEnum | TrainingReviewScalarFieldEnum[]
  }

  /**
   * TrainingReview findFirstOrThrow
   */
  export type TrainingReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * Filter, which TrainingReview to fetch.
     */
    where?: TrainingReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingReviews to fetch.
     */
    orderBy?: TrainingReviewOrderByWithRelationInput | TrainingReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingReviews.
     */
    cursor?: TrainingReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingReviews.
     */
    distinct?: TrainingReviewScalarFieldEnum | TrainingReviewScalarFieldEnum[]
  }

  /**
   * TrainingReview findMany
   */
  export type TrainingReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * Filter, which TrainingReviews to fetch.
     */
    where?: TrainingReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingReviews to fetch.
     */
    orderBy?: TrainingReviewOrderByWithRelationInput | TrainingReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingReviews.
     */
    cursor?: TrainingReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingReviews.
     */
    skip?: number
    distinct?: TrainingReviewScalarFieldEnum | TrainingReviewScalarFieldEnum[]
  }

  /**
   * TrainingReview create
   */
  export type TrainingReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingReview.
     */
    data: XOR<TrainingReviewCreateInput, TrainingReviewUncheckedCreateInput>
  }

  /**
   * TrainingReview createMany
   */
  export type TrainingReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingReviews.
     */
    data: TrainingReviewCreateManyInput | TrainingReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingReview createManyAndReturn
   */
  export type TrainingReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainingReviews.
     */
    data: TrainingReviewCreateManyInput | TrainingReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingReview update
   */
  export type TrainingReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingReview.
     */
    data: XOR<TrainingReviewUpdateInput, TrainingReviewUncheckedUpdateInput>
    /**
     * Choose, which TrainingReview to update.
     */
    where: TrainingReviewWhereUniqueInput
  }

  /**
   * TrainingReview updateMany
   */
  export type TrainingReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingReviews.
     */
    data: XOR<TrainingReviewUpdateManyMutationInput, TrainingReviewUncheckedUpdateManyInput>
    /**
     * Filter which TrainingReviews to update
     */
    where?: TrainingReviewWhereInput
  }

  /**
   * TrainingReview upsert
   */
  export type TrainingReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingReview to update in case it exists.
     */
    where: TrainingReviewWhereUniqueInput
    /**
     * In case the TrainingReview found by the `where` argument doesn't exist, create a new TrainingReview with this data.
     */
    create: XOR<TrainingReviewCreateInput, TrainingReviewUncheckedCreateInput>
    /**
     * In case the TrainingReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingReviewUpdateInput, TrainingReviewUncheckedUpdateInput>
  }

  /**
   * TrainingReview delete
   */
  export type TrainingReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
    /**
     * Filter which TrainingReview to delete.
     */
    where: TrainingReviewWhereUniqueInput
  }

  /**
   * TrainingReview deleteMany
   */
  export type TrainingReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingReviews to delete
     */
    where?: TrainingReviewWhereInput
  }

  /**
   * TrainingReview.featuredStudent
   */
  export type TrainingReview$featuredStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedStudent
     */
    select?: FeaturedStudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedStudentInclude<ExtArgs> | null
    where?: FeaturedStudentWhereInput
  }

  /**
   * TrainingReview without action
   */
  export type TrainingReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingReview
     */
    select?: TrainingReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingReviewInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    surname: 'surname',
    email: 'email',
    password: 'password',
    role: 'role',
    isStudent: 'isStudent',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NewsImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    socialUrl: 'socialUrl',
    mobileSocialUrl: 'mobileSocialUrl',
    desktopSocialUrl: 'desktopSocialUrl',
    isMain: 'isMain',
    order: 'order',
    newsId: 'newsId',
    createdAt: 'createdAt'
  };

  export type NewsImageScalarFieldEnum = (typeof NewsImageScalarFieldEnum)[keyof typeof NewsImageScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    imageUrl: 'imageUrl'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    surname: 'surname',
    email: 'email',
    phoneNumber: 'phoneNumber',
    createdAt: 'createdAt',
    type: 'type'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const JobListingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    company: 'company',
    location: 'location',
    type: 'type',
    salary: 'salary',
    description: 'description',
    requirements: 'requirements',
    posted: 'posted',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type JobListingScalarFieldEnum = (typeof JobListingScalarFieldEnum)[keyof typeof JobListingScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    role: 'role',
    description: 'description',
    title: 'title',
    imagePath: 'imagePath',
    email: 'email',
    phoneNumber: 'phoneNumber',
    cvPath: 'cvPath',
    linkedinUrl: 'linkedinUrl',
    twitterUrl: 'twitterUrl',
    facebookUrl: 'facebookUrl',
    createdAt: 'createdAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const FeaturedStudentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    surname: 'surname',
    email: 'email',
    phoneNumber: 'phoneNumber',
    courseType: 'courseType',
    score: 'score',
    imagePath: 'imagePath',
    description: 'description',
    achievements: 'achievements',
    graduationDate: 'graduationDate',
    isActive: 'isActive',
    linkedinUrl: 'linkedinUrl',
    testimonial: 'testimonial',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentProfileId: 'studentProfileId'
  };

  export type FeaturedStudentScalarFieldEnum = (typeof FeaturedStudentScalarFieldEnum)[keyof typeof FeaturedStudentScalarFieldEnum]


  export const TrainingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    level: 'level',
    instructor: 'instructor',
    totalHours: 'totalHours',
    startDate: 'startDate',
    endDate: 'endDate',
    maxParticipants: 'maxParticipants',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingScalarFieldEnum = (typeof TrainingScalarFieldEnum)[keyof typeof TrainingScalarFieldEnum]


  export const StudentTrainingEnrollmentScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    profileId: 'profileId',
    enrollmentDate: 'enrollmentDate',
    status: 'status',
    progress: 'progress',
    completionDate: 'completionDate',
    certificateUrl: 'certificateUrl',
    attendance: 'attendance',
    grade: 'grade',
    feedback: 'feedback',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentTrainingEnrollmentScalarFieldEnum = (typeof StudentTrainingEnrollmentScalarFieldEnum)[keyof typeof StudentTrainingEnrollmentScalarFieldEnum]


  export const StudentProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    university: 'university',
    faculty: 'faculty',
    year: 'year',
    gpa: 'gpa',
    bio: 'bio',
    location: 'location',
    phoneNumber: 'phoneNumber',
    linkedinUrl: 'linkedinUrl',
    facebookUrl: 'facebookUrl',
    githubUrl: 'githubUrl',
    portfolioUrl: 'portfolioUrl',
    profileImage: 'profileImage',
    cvPath: 'cvPath',
    attendance: 'attendance',
    totalCredits: 'totalCredits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentProfileScalarFieldEnum = (typeof StudentProfileScalarFieldEnum)[keyof typeof StudentProfileScalarFieldEnum]


  export const StudentSkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    profileId: 'profileId'
  };

  export type StudentSkillScalarFieldEnum = (typeof StudentSkillScalarFieldEnum)[keyof typeof StudentSkillScalarFieldEnum]


  export const StudentBadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    date: 'date',
    profileId: 'profileId'
  };

  export type StudentBadgeScalarFieldEnum = (typeof StudentBadgeScalarFieldEnum)[keyof typeof StudentBadgeScalarFieldEnum]


  export const StudentTrainingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    category: 'category',
    level: 'level',
    instructor: 'instructor',
    hours: 'hours',
    completionDate: 'completionDate',
    startDate: 'startDate',
    status: 'status',
    progress: 'progress',
    certificate: 'certificate',
    profileId: 'profileId'
  };

  export type StudentTrainingScalarFieldEnum = (typeof StudentTrainingScalarFieldEnum)[keyof typeof StudentTrainingScalarFieldEnum]


  export const StudentTestimonialScalarFieldEnum: {
    id: 'id',
    author: 'author',
    role: 'role',
    content: 'content',
    rating: 'rating',
    date: 'date',
    profileId: 'profileId'
  };

  export type StudentTestimonialScalarFieldEnum = (typeof StudentTestimonialScalarFieldEnum)[keyof typeof StudentTestimonialScalarFieldEnum]


  export const StudentSubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    grade: 'grade',
    credits: 'credits',
    semester: 'semester',
    profileId: 'profileId'
  };

  export type StudentSubjectScalarFieldEnum = (typeof StudentSubjectScalarFieldEnum)[keyof typeof StudentSubjectScalarFieldEnum]


  export const TrainingReviewScalarFieldEnum: {
    id: 'id',
    content: 'content',
    rating: 'rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    trainingId: 'trainingId',
    studentProfileId: 'studentProfileId',
    featuredStudentId: 'featuredStudentId'
  };

  export type TrainingReviewScalarFieldEnum = (typeof TrainingReviewScalarFieldEnum)[keyof typeof TrainingReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TrainingType'
   */
  export type EnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType'>
    


  /**
   * Reference to a field of type 'TrainingType[]'
   */
  export type ListEnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType[]'>
    


  /**
   * Reference to a field of type 'JobType'
   */
  export type EnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType'>
    


  /**
   * Reference to a field of type 'JobType[]'
   */
  export type ListEnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType[]'>
    


  /**
   * Reference to a field of type 'TeamMemberRole'
   */
  export type EnumTeamMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamMemberRole'>
    


  /**
   * Reference to a field of type 'TeamMemberRole[]'
   */
  export type ListEnumTeamMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamMemberRole[]'>
    


  /**
   * Reference to a field of type 'CourseType'
   */
  export type EnumCourseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseType'>
    


  /**
   * Reference to a field of type 'CourseType[]'
   */
  export type ListEnumCourseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseType[]'>
    


  /**
   * Reference to a field of type 'TrainingStatus'
   */
  export type EnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus'>
    


  /**
   * Reference to a field of type 'TrainingStatus[]'
   */
  export type ListEnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    surname?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isStudent?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    applications?: ApplicationListRelationFilter
    studentProfile?: XOR<StudentProfileNullableRelationFilter, StudentProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
    applications?: ApplicationOrderByRelationAggregateInput
    studentProfile?: StudentProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    surname?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isStudent?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    applications?: ApplicationListRelationFilter
    studentProfile?: XOR<StudentProfileNullableRelationFilter, StudentProfileWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    surname?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isStudent?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type NewsImageWhereInput = {
    AND?: NewsImageWhereInput | NewsImageWhereInput[]
    OR?: NewsImageWhereInput[]
    NOT?: NewsImageWhereInput | NewsImageWhereInput[]
    id?: IntFilter<"NewsImage"> | number
    url?: StringFilter<"NewsImage"> | string
    socialUrl?: StringNullableFilter<"NewsImage"> | string | null
    mobileSocialUrl?: StringNullableFilter<"NewsImage"> | string | null
    desktopSocialUrl?: StringNullableFilter<"NewsImage"> | string | null
    isMain?: BoolFilter<"NewsImage"> | boolean
    order?: IntFilter<"NewsImage"> | number
    newsId?: IntFilter<"NewsImage"> | number
    createdAt?: DateTimeFilter<"NewsImage"> | Date | string
    news?: XOR<NewsRelationFilter, NewsWhereInput>
  }

  export type NewsImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    socialUrl?: SortOrderInput | SortOrder
    mobileSocialUrl?: SortOrderInput | SortOrder
    desktopSocialUrl?: SortOrderInput | SortOrder
    isMain?: SortOrder
    order?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    news?: NewsOrderByWithRelationInput
  }

  export type NewsImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NewsImageWhereInput | NewsImageWhereInput[]
    OR?: NewsImageWhereInput[]
    NOT?: NewsImageWhereInput | NewsImageWhereInput[]
    url?: StringFilter<"NewsImage"> | string
    socialUrl?: StringNullableFilter<"NewsImage"> | string | null
    mobileSocialUrl?: StringNullableFilter<"NewsImage"> | string | null
    desktopSocialUrl?: StringNullableFilter<"NewsImage"> | string | null
    isMain?: BoolFilter<"NewsImage"> | boolean
    order?: IntFilter<"NewsImage"> | number
    newsId?: IntFilter<"NewsImage"> | number
    createdAt?: DateTimeFilter<"NewsImage"> | Date | string
    news?: XOR<NewsRelationFilter, NewsWhereInput>
  }, "id">

  export type NewsImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    socialUrl?: SortOrderInput | SortOrder
    mobileSocialUrl?: SortOrderInput | SortOrder
    desktopSocialUrl?: SortOrderInput | SortOrder
    isMain?: SortOrder
    order?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    _count?: NewsImageCountOrderByAggregateInput
    _avg?: NewsImageAvgOrderByAggregateInput
    _max?: NewsImageMaxOrderByAggregateInput
    _min?: NewsImageMinOrderByAggregateInput
    _sum?: NewsImageSumOrderByAggregateInput
  }

  export type NewsImageScalarWhereWithAggregatesInput = {
    AND?: NewsImageScalarWhereWithAggregatesInput | NewsImageScalarWhereWithAggregatesInput[]
    OR?: NewsImageScalarWhereWithAggregatesInput[]
    NOT?: NewsImageScalarWhereWithAggregatesInput | NewsImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NewsImage"> | number
    url?: StringWithAggregatesFilter<"NewsImage"> | string
    socialUrl?: StringNullableWithAggregatesFilter<"NewsImage"> | string | null
    mobileSocialUrl?: StringNullableWithAggregatesFilter<"NewsImage"> | string | null
    desktopSocialUrl?: StringNullableWithAggregatesFilter<"NewsImage"> | string | null
    isMain?: BoolWithAggregatesFilter<"NewsImage"> | boolean
    order?: IntWithAggregatesFilter<"NewsImage"> | number
    newsId?: IntWithAggregatesFilter<"NewsImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"NewsImage"> | Date | string
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    id?: IntFilter<"News"> | number
    title?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    imageUrl?: StringNullableFilter<"News"> | string | null
    images?: NewsImageListRelationFilter
  }

  export type NewsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    images?: NewsImageOrderByRelationAggregateInput
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    title?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    imageUrl?: StringNullableFilter<"News"> | string | null
    images?: NewsImageListRelationFilter
  }, "id">

  export type NewsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: NewsCountOrderByAggregateInput
    _avg?: NewsAvgOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
    _sum?: NewsSumOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"News"> | number
    title?: StringWithAggregatesFilter<"News"> | string
    content?: StringWithAggregatesFilter<"News"> | string
    createdAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    imageUrl?: StringNullableWithAggregatesFilter<"News"> | string | null
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: IntFilter<"Application"> | number
    userId?: IntNullableFilter<"Application"> | number | null
    name?: StringFilter<"Application"> | string
    surname?: StringFilter<"Application"> | string
    email?: StringFilter<"Application"> | string
    phoneNumber?: StringNullableFilter<"Application"> | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    type?: EnumTrainingTypeFilter<"Application"> | $Enums.TrainingType
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email_type?: ApplicationEmailTypeCompoundUniqueInput
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    userId?: IntNullableFilter<"Application"> | number | null
    name?: StringFilter<"Application"> | string
    surname?: StringFilter<"Application"> | string
    email?: StringFilter<"Application"> | string
    phoneNumber?: StringNullableFilter<"Application"> | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    type?: EnumTrainingTypeFilter<"Application"> | $Enums.TrainingType
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "email_type">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _avg?: ApplicationAvgOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
    _sum?: ApplicationSumOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Application"> | number
    userId?: IntNullableWithAggregatesFilter<"Application"> | number | null
    name?: StringWithAggregatesFilter<"Application"> | string
    surname?: StringWithAggregatesFilter<"Application"> | string
    email?: StringWithAggregatesFilter<"Application"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Application"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    type?: EnumTrainingTypeWithAggregatesFilter<"Application"> | $Enums.TrainingType
  }

  export type JobListingWhereInput = {
    AND?: JobListingWhereInput | JobListingWhereInput[]
    OR?: JobListingWhereInput[]
    NOT?: JobListingWhereInput | JobListingWhereInput[]
    id?: IntFilter<"JobListing"> | number
    title?: StringFilter<"JobListing"> | string
    company?: StringFilter<"JobListing"> | string
    location?: StringFilter<"JobListing"> | string
    type?: EnumJobTypeFilter<"JobListing"> | $Enums.JobType
    salary?: StringFilter<"JobListing"> | string
    description?: StringFilter<"JobListing"> | string
    requirements?: StringNullableListFilter<"JobListing">
    posted?: DateTimeFilter<"JobListing"> | Date | string
    updatedAt?: DateTimeFilter<"JobListing"> | Date | string
    isActive?: BoolFilter<"JobListing"> | boolean
  }

  export type JobListingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    type?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    posted?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type JobListingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobListingWhereInput | JobListingWhereInput[]
    OR?: JobListingWhereInput[]
    NOT?: JobListingWhereInput | JobListingWhereInput[]
    title?: StringFilter<"JobListing"> | string
    company?: StringFilter<"JobListing"> | string
    location?: StringFilter<"JobListing"> | string
    type?: EnumJobTypeFilter<"JobListing"> | $Enums.JobType
    salary?: StringFilter<"JobListing"> | string
    description?: StringFilter<"JobListing"> | string
    requirements?: StringNullableListFilter<"JobListing">
    posted?: DateTimeFilter<"JobListing"> | Date | string
    updatedAt?: DateTimeFilter<"JobListing"> | Date | string
    isActive?: BoolFilter<"JobListing"> | boolean
  }, "id">

  export type JobListingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    type?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    posted?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: JobListingCountOrderByAggregateInput
    _avg?: JobListingAvgOrderByAggregateInput
    _max?: JobListingMaxOrderByAggregateInput
    _min?: JobListingMinOrderByAggregateInput
    _sum?: JobListingSumOrderByAggregateInput
  }

  export type JobListingScalarWhereWithAggregatesInput = {
    AND?: JobListingScalarWhereWithAggregatesInput | JobListingScalarWhereWithAggregatesInput[]
    OR?: JobListingScalarWhereWithAggregatesInput[]
    NOT?: JobListingScalarWhereWithAggregatesInput | JobListingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobListing"> | number
    title?: StringWithAggregatesFilter<"JobListing"> | string
    company?: StringWithAggregatesFilter<"JobListing"> | string
    location?: StringWithAggregatesFilter<"JobListing"> | string
    type?: EnumJobTypeWithAggregatesFilter<"JobListing"> | $Enums.JobType
    salary?: StringWithAggregatesFilter<"JobListing"> | string
    description?: StringWithAggregatesFilter<"JobListing"> | string
    requirements?: StringNullableListFilter<"JobListing">
    posted?: DateTimeWithAggregatesFilter<"JobListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobListing"> | Date | string
    isActive?: BoolWithAggregatesFilter<"JobListing"> | boolean
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    fullName?: StringFilter<"TeamMember"> | string
    role?: EnumTeamMemberRoleFilter<"TeamMember"> | $Enums.TeamMemberRole
    description?: StringFilter<"TeamMember"> | string
    title?: StringFilter<"TeamMember"> | string
    imagePath?: StringFilter<"TeamMember"> | string
    email?: StringNullableFilter<"TeamMember"> | string | null
    phoneNumber?: StringNullableFilter<"TeamMember"> | string | null
    cvPath?: StringNullableFilter<"TeamMember"> | string | null
    linkedinUrl?: StringNullableFilter<"TeamMember"> | string | null
    twitterUrl?: StringNullableFilter<"TeamMember"> | string | null
    facebookUrl?: StringNullableFilter<"TeamMember"> | string | null
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    description?: SortOrder
    title?: SortOrder
    imagePath?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    cvPath?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    twitterUrl?: SortOrderInput | SortOrder
    facebookUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    fullName?: StringFilter<"TeamMember"> | string
    role?: EnumTeamMemberRoleFilter<"TeamMember"> | $Enums.TeamMemberRole
    description?: StringFilter<"TeamMember"> | string
    title?: StringFilter<"TeamMember"> | string
    imagePath?: StringFilter<"TeamMember"> | string
    email?: StringNullableFilter<"TeamMember"> | string | null
    phoneNumber?: StringNullableFilter<"TeamMember"> | string | null
    cvPath?: StringNullableFilter<"TeamMember"> | string | null
    linkedinUrl?: StringNullableFilter<"TeamMember"> | string | null
    twitterUrl?: StringNullableFilter<"TeamMember"> | string | null
    facebookUrl?: StringNullableFilter<"TeamMember"> | string | null
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
  }, "id">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    description?: SortOrder
    title?: SortOrder
    imagePath?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    cvPath?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    twitterUrl?: SortOrderInput | SortOrder
    facebookUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamMember"> | number
    fullName?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: EnumTeamMemberRoleWithAggregatesFilter<"TeamMember"> | $Enums.TeamMemberRole
    description?: StringWithAggregatesFilter<"TeamMember"> | string
    title?: StringWithAggregatesFilter<"TeamMember"> | string
    imagePath?: StringWithAggregatesFilter<"TeamMember"> | string
    email?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    cvPath?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    twitterUrl?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    facebookUrl?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type FeaturedStudentWhereInput = {
    AND?: FeaturedStudentWhereInput | FeaturedStudentWhereInput[]
    OR?: FeaturedStudentWhereInput[]
    NOT?: FeaturedStudentWhereInput | FeaturedStudentWhereInput[]
    id?: IntFilter<"FeaturedStudent"> | number
    name?: StringFilter<"FeaturedStudent"> | string
    surname?: StringFilter<"FeaturedStudent"> | string
    email?: StringFilter<"FeaturedStudent"> | string
    phoneNumber?: StringNullableFilter<"FeaturedStudent"> | string | null
    courseType?: EnumCourseTypeFilter<"FeaturedStudent"> | $Enums.CourseType
    score?: IntFilter<"FeaturedStudent"> | number
    imagePath?: StringNullableFilter<"FeaturedStudent"> | string | null
    description?: StringFilter<"FeaturedStudent"> | string
    achievements?: StringNullableListFilter<"FeaturedStudent">
    graduationDate?: DateTimeFilter<"FeaturedStudent"> | Date | string
    isActive?: BoolFilter<"FeaturedStudent"> | boolean
    linkedinUrl?: StringNullableFilter<"FeaturedStudent"> | string | null
    testimonial?: StringNullableFilter<"FeaturedStudent"> | string | null
    createdAt?: DateTimeFilter<"FeaturedStudent"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedStudent"> | Date | string
    studentProfileId?: IntNullableFilter<"FeaturedStudent"> | number | null
    studentProfile?: XOR<StudentProfileNullableRelationFilter, StudentProfileWhereInput> | null
    trainingReviews?: TrainingReviewListRelationFilter
  }

  export type FeaturedStudentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    courseType?: SortOrder
    score?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    description?: SortOrder
    achievements?: SortOrder
    graduationDate?: SortOrder
    isActive?: SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    testimonial?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfileId?: SortOrderInput | SortOrder
    studentProfile?: StudentProfileOrderByWithRelationInput
    trainingReviews?: TrainingReviewOrderByRelationAggregateInput
  }

  export type FeaturedStudentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    studentProfileId?: number
    AND?: FeaturedStudentWhereInput | FeaturedStudentWhereInput[]
    OR?: FeaturedStudentWhereInput[]
    NOT?: FeaturedStudentWhereInput | FeaturedStudentWhereInput[]
    name?: StringFilter<"FeaturedStudent"> | string
    surname?: StringFilter<"FeaturedStudent"> | string
    phoneNumber?: StringNullableFilter<"FeaturedStudent"> | string | null
    courseType?: EnumCourseTypeFilter<"FeaturedStudent"> | $Enums.CourseType
    score?: IntFilter<"FeaturedStudent"> | number
    imagePath?: StringNullableFilter<"FeaturedStudent"> | string | null
    description?: StringFilter<"FeaturedStudent"> | string
    achievements?: StringNullableListFilter<"FeaturedStudent">
    graduationDate?: DateTimeFilter<"FeaturedStudent"> | Date | string
    isActive?: BoolFilter<"FeaturedStudent"> | boolean
    linkedinUrl?: StringNullableFilter<"FeaturedStudent"> | string | null
    testimonial?: StringNullableFilter<"FeaturedStudent"> | string | null
    createdAt?: DateTimeFilter<"FeaturedStudent"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedStudent"> | Date | string
    studentProfile?: XOR<StudentProfileNullableRelationFilter, StudentProfileWhereInput> | null
    trainingReviews?: TrainingReviewListRelationFilter
  }, "id" | "email" | "studentProfileId">

  export type FeaturedStudentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    courseType?: SortOrder
    score?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    description?: SortOrder
    achievements?: SortOrder
    graduationDate?: SortOrder
    isActive?: SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    testimonial?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfileId?: SortOrderInput | SortOrder
    _count?: FeaturedStudentCountOrderByAggregateInput
    _avg?: FeaturedStudentAvgOrderByAggregateInput
    _max?: FeaturedStudentMaxOrderByAggregateInput
    _min?: FeaturedStudentMinOrderByAggregateInput
    _sum?: FeaturedStudentSumOrderByAggregateInput
  }

  export type FeaturedStudentScalarWhereWithAggregatesInput = {
    AND?: FeaturedStudentScalarWhereWithAggregatesInput | FeaturedStudentScalarWhereWithAggregatesInput[]
    OR?: FeaturedStudentScalarWhereWithAggregatesInput[]
    NOT?: FeaturedStudentScalarWhereWithAggregatesInput | FeaturedStudentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeaturedStudent"> | number
    name?: StringWithAggregatesFilter<"FeaturedStudent"> | string
    surname?: StringWithAggregatesFilter<"FeaturedStudent"> | string
    email?: StringWithAggregatesFilter<"FeaturedStudent"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"FeaturedStudent"> | string | null
    courseType?: EnumCourseTypeWithAggregatesFilter<"FeaturedStudent"> | $Enums.CourseType
    score?: IntWithAggregatesFilter<"FeaturedStudent"> | number
    imagePath?: StringNullableWithAggregatesFilter<"FeaturedStudent"> | string | null
    description?: StringWithAggregatesFilter<"FeaturedStudent"> | string
    achievements?: StringNullableListFilter<"FeaturedStudent">
    graduationDate?: DateTimeWithAggregatesFilter<"FeaturedStudent"> | Date | string
    isActive?: BoolWithAggregatesFilter<"FeaturedStudent"> | boolean
    linkedinUrl?: StringNullableWithAggregatesFilter<"FeaturedStudent"> | string | null
    testimonial?: StringNullableWithAggregatesFilter<"FeaturedStudent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedStudent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeaturedStudent"> | Date | string
    studentProfileId?: IntNullableWithAggregatesFilter<"FeaturedStudent"> | number | null
  }

  export type TrainingWhereInput = {
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    id?: IntFilter<"Training"> | number
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    category?: StringFilter<"Training"> | string
    level?: StringFilter<"Training"> | string
    instructor?: StringFilter<"Training"> | string
    totalHours?: IntFilter<"Training"> | number
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    isActive?: BoolFilter<"Training"> | boolean
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    enrollments?: StudentTrainingEnrollmentListRelationFilter
    reviews?: TrainingReviewListRelationFilter
  }

  export type TrainingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    totalHours?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollments?: StudentTrainingEnrollmentOrderByRelationAggregateInput
    reviews?: TrainingReviewOrderByRelationAggregateInput
  }

  export type TrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    category?: StringFilter<"Training"> | string
    level?: StringFilter<"Training"> | string
    instructor?: StringFilter<"Training"> | string
    totalHours?: IntFilter<"Training"> | number
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    isActive?: BoolFilter<"Training"> | boolean
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    enrollments?: StudentTrainingEnrollmentListRelationFilter
    reviews?: TrainingReviewListRelationFilter
  }, "id">

  export type TrainingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    totalHours?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingCountOrderByAggregateInput
    _avg?: TrainingAvgOrderByAggregateInput
    _max?: TrainingMaxOrderByAggregateInput
    _min?: TrainingMinOrderByAggregateInput
    _sum?: TrainingSumOrderByAggregateInput
  }

  export type TrainingScalarWhereWithAggregatesInput = {
    AND?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    OR?: TrainingScalarWhereWithAggregatesInput[]
    NOT?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Training"> | number
    title?: StringWithAggregatesFilter<"Training"> | string
    description?: StringNullableWithAggregatesFilter<"Training"> | string | null
    category?: StringWithAggregatesFilter<"Training"> | string
    level?: StringWithAggregatesFilter<"Training"> | string
    instructor?: StringWithAggregatesFilter<"Training"> | string
    totalHours?: IntWithAggregatesFilter<"Training"> | number
    startDate?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    maxParticipants?: IntNullableWithAggregatesFilter<"Training"> | number | null
    isActive?: BoolWithAggregatesFilter<"Training"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Training"> | Date | string
  }

  export type StudentTrainingEnrollmentWhereInput = {
    AND?: StudentTrainingEnrollmentWhereInput | StudentTrainingEnrollmentWhereInput[]
    OR?: StudentTrainingEnrollmentWhereInput[]
    NOT?: StudentTrainingEnrollmentWhereInput | StudentTrainingEnrollmentWhereInput[]
    id?: IntFilter<"StudentTrainingEnrollment"> | number
    trainingId?: IntFilter<"StudentTrainingEnrollment"> | number
    profileId?: IntFilter<"StudentTrainingEnrollment"> | number
    enrollmentDate?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
    status?: EnumTrainingStatusFilter<"StudentTrainingEnrollment"> | $Enums.TrainingStatus
    progress?: IntFilter<"StudentTrainingEnrollment"> | number
    completionDate?: DateTimeNullableFilter<"StudentTrainingEnrollment"> | Date | string | null
    certificateUrl?: StringNullableFilter<"StudentTrainingEnrollment"> | string | null
    attendance?: IntFilter<"StudentTrainingEnrollment"> | number
    grade?: FloatNullableFilter<"StudentTrainingEnrollment"> | number | null
    feedback?: StringNullableFilter<"StudentTrainingEnrollment"> | string | null
    createdAt?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
    training?: XOR<TrainingRelationFilter, TrainingWhereInput>
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }

  export type StudentTrainingEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    profileId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    attendance?: SortOrder
    grade?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    profile?: StudentProfileOrderByWithRelationInput
  }

  export type StudentTrainingEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    trainingId_profileId?: StudentTrainingEnrollmentTrainingIdProfileIdCompoundUniqueInput
    AND?: StudentTrainingEnrollmentWhereInput | StudentTrainingEnrollmentWhereInput[]
    OR?: StudentTrainingEnrollmentWhereInput[]
    NOT?: StudentTrainingEnrollmentWhereInput | StudentTrainingEnrollmentWhereInput[]
    trainingId?: IntFilter<"StudentTrainingEnrollment"> | number
    profileId?: IntFilter<"StudentTrainingEnrollment"> | number
    enrollmentDate?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
    status?: EnumTrainingStatusFilter<"StudentTrainingEnrollment"> | $Enums.TrainingStatus
    progress?: IntFilter<"StudentTrainingEnrollment"> | number
    completionDate?: DateTimeNullableFilter<"StudentTrainingEnrollment"> | Date | string | null
    certificateUrl?: StringNullableFilter<"StudentTrainingEnrollment"> | string | null
    attendance?: IntFilter<"StudentTrainingEnrollment"> | number
    grade?: FloatNullableFilter<"StudentTrainingEnrollment"> | number | null
    feedback?: StringNullableFilter<"StudentTrainingEnrollment"> | string | null
    createdAt?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
    training?: XOR<TrainingRelationFilter, TrainingWhereInput>
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }, "id" | "trainingId_profileId">

  export type StudentTrainingEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    profileId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    attendance?: SortOrder
    grade?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentTrainingEnrollmentCountOrderByAggregateInput
    _avg?: StudentTrainingEnrollmentAvgOrderByAggregateInput
    _max?: StudentTrainingEnrollmentMaxOrderByAggregateInput
    _min?: StudentTrainingEnrollmentMinOrderByAggregateInput
    _sum?: StudentTrainingEnrollmentSumOrderByAggregateInput
  }

  export type StudentTrainingEnrollmentScalarWhereWithAggregatesInput = {
    AND?: StudentTrainingEnrollmentScalarWhereWithAggregatesInput | StudentTrainingEnrollmentScalarWhereWithAggregatesInput[]
    OR?: StudentTrainingEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: StudentTrainingEnrollmentScalarWhereWithAggregatesInput | StudentTrainingEnrollmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentTrainingEnrollment"> | number
    trainingId?: IntWithAggregatesFilter<"StudentTrainingEnrollment"> | number
    profileId?: IntWithAggregatesFilter<"StudentTrainingEnrollment"> | number
    enrollmentDate?: DateTimeWithAggregatesFilter<"StudentTrainingEnrollment"> | Date | string
    status?: EnumTrainingStatusWithAggregatesFilter<"StudentTrainingEnrollment"> | $Enums.TrainingStatus
    progress?: IntWithAggregatesFilter<"StudentTrainingEnrollment"> | number
    completionDate?: DateTimeNullableWithAggregatesFilter<"StudentTrainingEnrollment"> | Date | string | null
    certificateUrl?: StringNullableWithAggregatesFilter<"StudentTrainingEnrollment"> | string | null
    attendance?: IntWithAggregatesFilter<"StudentTrainingEnrollment"> | number
    grade?: FloatNullableWithAggregatesFilter<"StudentTrainingEnrollment"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"StudentTrainingEnrollment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentTrainingEnrollment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentTrainingEnrollment"> | Date | string
  }

  export type StudentProfileWhereInput = {
    AND?: StudentProfileWhereInput | StudentProfileWhereInput[]
    OR?: StudentProfileWhereInput[]
    NOT?: StudentProfileWhereInput | StudentProfileWhereInput[]
    id?: IntFilter<"StudentProfile"> | number
    userId?: IntFilter<"StudentProfile"> | number
    university?: StringNullableFilter<"StudentProfile"> | string | null
    faculty?: StringNullableFilter<"StudentProfile"> | string | null
    year?: StringNullableFilter<"StudentProfile"> | string | null
    gpa?: FloatNullableFilter<"StudentProfile"> | number | null
    bio?: StringNullableFilter<"StudentProfile"> | string | null
    location?: StringNullableFilter<"StudentProfile"> | string | null
    phoneNumber?: StringNullableFilter<"StudentProfile"> | string | null
    linkedinUrl?: StringNullableFilter<"StudentProfile"> | string | null
    facebookUrl?: StringNullableFilter<"StudentProfile"> | string | null
    githubUrl?: StringNullableFilter<"StudentProfile"> | string | null
    portfolioUrl?: StringNullableFilter<"StudentProfile"> | string | null
    profileImage?: StringNullableFilter<"StudentProfile"> | string | null
    cvPath?: StringNullableFilter<"StudentProfile"> | string | null
    attendance?: FloatNullableFilter<"StudentProfile"> | number | null
    totalCredits?: IntNullableFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skills?: StudentSkillListRelationFilter
    badges?: StudentBadgeListRelationFilter
    trainings?: StudentTrainingEnrollmentListRelationFilter
    testimonials?: StudentTestimonialListRelationFilter
    academicSubjects?: StudentSubjectListRelationFilter
    featuredStudent?: XOR<FeaturedStudentNullableRelationFilter, FeaturedStudentWhereInput> | null
    trainingReviews?: TrainingReviewListRelationFilter
    StudentTraining?: StudentTrainingListRelationFilter
  }

  export type StudentProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    university?: SortOrderInput | SortOrder
    faculty?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    gpa?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    facebookUrl?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    portfolioUrl?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    cvPath?: SortOrderInput | SortOrder
    attendance?: SortOrderInput | SortOrder
    totalCredits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    skills?: StudentSkillOrderByRelationAggregateInput
    badges?: StudentBadgeOrderByRelationAggregateInput
    trainings?: StudentTrainingEnrollmentOrderByRelationAggregateInput
    testimonials?: StudentTestimonialOrderByRelationAggregateInput
    academicSubjects?: StudentSubjectOrderByRelationAggregateInput
    featuredStudent?: FeaturedStudentOrderByWithRelationInput
    trainingReviews?: TrainingReviewOrderByRelationAggregateInput
    StudentTraining?: StudentTrainingOrderByRelationAggregateInput
  }

  export type StudentProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: StudentProfileWhereInput | StudentProfileWhereInput[]
    OR?: StudentProfileWhereInput[]
    NOT?: StudentProfileWhereInput | StudentProfileWhereInput[]
    university?: StringNullableFilter<"StudentProfile"> | string | null
    faculty?: StringNullableFilter<"StudentProfile"> | string | null
    year?: StringNullableFilter<"StudentProfile"> | string | null
    gpa?: FloatNullableFilter<"StudentProfile"> | number | null
    bio?: StringNullableFilter<"StudentProfile"> | string | null
    location?: StringNullableFilter<"StudentProfile"> | string | null
    phoneNumber?: StringNullableFilter<"StudentProfile"> | string | null
    linkedinUrl?: StringNullableFilter<"StudentProfile"> | string | null
    facebookUrl?: StringNullableFilter<"StudentProfile"> | string | null
    githubUrl?: StringNullableFilter<"StudentProfile"> | string | null
    portfolioUrl?: StringNullableFilter<"StudentProfile"> | string | null
    profileImage?: StringNullableFilter<"StudentProfile"> | string | null
    cvPath?: StringNullableFilter<"StudentProfile"> | string | null
    attendance?: FloatNullableFilter<"StudentProfile"> | number | null
    totalCredits?: IntNullableFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skills?: StudentSkillListRelationFilter
    badges?: StudentBadgeListRelationFilter
    trainings?: StudentTrainingEnrollmentListRelationFilter
    testimonials?: StudentTestimonialListRelationFilter
    academicSubjects?: StudentSubjectListRelationFilter
    featuredStudent?: XOR<FeaturedStudentNullableRelationFilter, FeaturedStudentWhereInput> | null
    trainingReviews?: TrainingReviewListRelationFilter
    StudentTraining?: StudentTrainingListRelationFilter
  }, "id" | "userId">

  export type StudentProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    university?: SortOrderInput | SortOrder
    faculty?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    gpa?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    facebookUrl?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    portfolioUrl?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    cvPath?: SortOrderInput | SortOrder
    attendance?: SortOrderInput | SortOrder
    totalCredits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentProfileCountOrderByAggregateInput
    _avg?: StudentProfileAvgOrderByAggregateInput
    _max?: StudentProfileMaxOrderByAggregateInput
    _min?: StudentProfileMinOrderByAggregateInput
    _sum?: StudentProfileSumOrderByAggregateInput
  }

  export type StudentProfileScalarWhereWithAggregatesInput = {
    AND?: StudentProfileScalarWhereWithAggregatesInput | StudentProfileScalarWhereWithAggregatesInput[]
    OR?: StudentProfileScalarWhereWithAggregatesInput[]
    NOT?: StudentProfileScalarWhereWithAggregatesInput | StudentProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentProfile"> | number
    userId?: IntWithAggregatesFilter<"StudentProfile"> | number
    university?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    faculty?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    year?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    gpa?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    bio?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    location?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    facebookUrl?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    githubUrl?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    portfolioUrl?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    cvPath?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    attendance?: FloatNullableWithAggregatesFilter<"StudentProfile"> | number | null
    totalCredits?: IntNullableWithAggregatesFilter<"StudentProfile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
  }

  export type StudentSkillWhereInput = {
    AND?: StudentSkillWhereInput | StudentSkillWhereInput[]
    OR?: StudentSkillWhereInput[]
    NOT?: StudentSkillWhereInput | StudentSkillWhereInput[]
    id?: IntFilter<"StudentSkill"> | number
    name?: StringFilter<"StudentSkill"> | string
    level?: IntFilter<"StudentSkill"> | number
    profileId?: IntFilter<"StudentSkill"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }

  export type StudentSkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    profileId?: SortOrder
    profile?: StudentProfileOrderByWithRelationInput
  }

  export type StudentSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentSkillWhereInput | StudentSkillWhereInput[]
    OR?: StudentSkillWhereInput[]
    NOT?: StudentSkillWhereInput | StudentSkillWhereInput[]
    name?: StringFilter<"StudentSkill"> | string
    level?: IntFilter<"StudentSkill"> | number
    profileId?: IntFilter<"StudentSkill"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type StudentSkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    profileId?: SortOrder
    _count?: StudentSkillCountOrderByAggregateInput
    _avg?: StudentSkillAvgOrderByAggregateInput
    _max?: StudentSkillMaxOrderByAggregateInput
    _min?: StudentSkillMinOrderByAggregateInput
    _sum?: StudentSkillSumOrderByAggregateInput
  }

  export type StudentSkillScalarWhereWithAggregatesInput = {
    AND?: StudentSkillScalarWhereWithAggregatesInput | StudentSkillScalarWhereWithAggregatesInput[]
    OR?: StudentSkillScalarWhereWithAggregatesInput[]
    NOT?: StudentSkillScalarWhereWithAggregatesInput | StudentSkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentSkill"> | number
    name?: StringWithAggregatesFilter<"StudentSkill"> | string
    level?: IntWithAggregatesFilter<"StudentSkill"> | number
    profileId?: IntWithAggregatesFilter<"StudentSkill"> | number
  }

  export type StudentBadgeWhereInput = {
    AND?: StudentBadgeWhereInput | StudentBadgeWhereInput[]
    OR?: StudentBadgeWhereInput[]
    NOT?: StudentBadgeWhereInput | StudentBadgeWhereInput[]
    id?: IntFilter<"StudentBadge"> | number
    name?: StringFilter<"StudentBadge"> | string
    type?: StringFilter<"StudentBadge"> | string
    date?: DateTimeFilter<"StudentBadge"> | Date | string
    profileId?: IntFilter<"StudentBadge"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }

  export type StudentBadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
    profile?: StudentProfileOrderByWithRelationInput
  }

  export type StudentBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentBadgeWhereInput | StudentBadgeWhereInput[]
    OR?: StudentBadgeWhereInput[]
    NOT?: StudentBadgeWhereInput | StudentBadgeWhereInput[]
    name?: StringFilter<"StudentBadge"> | string
    type?: StringFilter<"StudentBadge"> | string
    date?: DateTimeFilter<"StudentBadge"> | Date | string
    profileId?: IntFilter<"StudentBadge"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type StudentBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
    _count?: StudentBadgeCountOrderByAggregateInput
    _avg?: StudentBadgeAvgOrderByAggregateInput
    _max?: StudentBadgeMaxOrderByAggregateInput
    _min?: StudentBadgeMinOrderByAggregateInput
    _sum?: StudentBadgeSumOrderByAggregateInput
  }

  export type StudentBadgeScalarWhereWithAggregatesInput = {
    AND?: StudentBadgeScalarWhereWithAggregatesInput | StudentBadgeScalarWhereWithAggregatesInput[]
    OR?: StudentBadgeScalarWhereWithAggregatesInput[]
    NOT?: StudentBadgeScalarWhereWithAggregatesInput | StudentBadgeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentBadge"> | number
    name?: StringWithAggregatesFilter<"StudentBadge"> | string
    type?: StringWithAggregatesFilter<"StudentBadge"> | string
    date?: DateTimeWithAggregatesFilter<"StudentBadge"> | Date | string
    profileId?: IntWithAggregatesFilter<"StudentBadge"> | number
  }

  export type StudentTrainingWhereInput = {
    AND?: StudentTrainingWhereInput | StudentTrainingWhereInput[]
    OR?: StudentTrainingWhereInput[]
    NOT?: StudentTrainingWhereInput | StudentTrainingWhereInput[]
    id?: IntFilter<"StudentTraining"> | number
    title?: StringFilter<"StudentTraining"> | string
    category?: StringFilter<"StudentTraining"> | string
    level?: StringFilter<"StudentTraining"> | string
    instructor?: StringFilter<"StudentTraining"> | string
    hours?: IntNullableFilter<"StudentTraining"> | number | null
    completionDate?: DateTimeNullableFilter<"StudentTraining"> | Date | string | null
    startDate?: DateTimeNullableFilter<"StudentTraining"> | Date | string | null
    status?: StringFilter<"StudentTraining"> | string
    progress?: IntNullableFilter<"StudentTraining"> | number | null
    certificate?: BoolFilter<"StudentTraining"> | boolean
    profileId?: IntFilter<"StudentTraining"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }

  export type StudentTrainingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    hours?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrderInput | SortOrder
    certificate?: SortOrder
    profileId?: SortOrder
    profile?: StudentProfileOrderByWithRelationInput
  }

  export type StudentTrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentTrainingWhereInput | StudentTrainingWhereInput[]
    OR?: StudentTrainingWhereInput[]
    NOT?: StudentTrainingWhereInput | StudentTrainingWhereInput[]
    title?: StringFilter<"StudentTraining"> | string
    category?: StringFilter<"StudentTraining"> | string
    level?: StringFilter<"StudentTraining"> | string
    instructor?: StringFilter<"StudentTraining"> | string
    hours?: IntNullableFilter<"StudentTraining"> | number | null
    completionDate?: DateTimeNullableFilter<"StudentTraining"> | Date | string | null
    startDate?: DateTimeNullableFilter<"StudentTraining"> | Date | string | null
    status?: StringFilter<"StudentTraining"> | string
    progress?: IntNullableFilter<"StudentTraining"> | number | null
    certificate?: BoolFilter<"StudentTraining"> | boolean
    profileId?: IntFilter<"StudentTraining"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type StudentTrainingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    hours?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrderInput | SortOrder
    certificate?: SortOrder
    profileId?: SortOrder
    _count?: StudentTrainingCountOrderByAggregateInput
    _avg?: StudentTrainingAvgOrderByAggregateInput
    _max?: StudentTrainingMaxOrderByAggregateInput
    _min?: StudentTrainingMinOrderByAggregateInput
    _sum?: StudentTrainingSumOrderByAggregateInput
  }

  export type StudentTrainingScalarWhereWithAggregatesInput = {
    AND?: StudentTrainingScalarWhereWithAggregatesInput | StudentTrainingScalarWhereWithAggregatesInput[]
    OR?: StudentTrainingScalarWhereWithAggregatesInput[]
    NOT?: StudentTrainingScalarWhereWithAggregatesInput | StudentTrainingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentTraining"> | number
    title?: StringWithAggregatesFilter<"StudentTraining"> | string
    category?: StringWithAggregatesFilter<"StudentTraining"> | string
    level?: StringWithAggregatesFilter<"StudentTraining"> | string
    instructor?: StringWithAggregatesFilter<"StudentTraining"> | string
    hours?: IntNullableWithAggregatesFilter<"StudentTraining"> | number | null
    completionDate?: DateTimeNullableWithAggregatesFilter<"StudentTraining"> | Date | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"StudentTraining"> | Date | string | null
    status?: StringWithAggregatesFilter<"StudentTraining"> | string
    progress?: IntNullableWithAggregatesFilter<"StudentTraining"> | number | null
    certificate?: BoolWithAggregatesFilter<"StudentTraining"> | boolean
    profileId?: IntWithAggregatesFilter<"StudentTraining"> | number
  }

  export type StudentTestimonialWhereInput = {
    AND?: StudentTestimonialWhereInput | StudentTestimonialWhereInput[]
    OR?: StudentTestimonialWhereInput[]
    NOT?: StudentTestimonialWhereInput | StudentTestimonialWhereInput[]
    id?: IntFilter<"StudentTestimonial"> | number
    author?: StringFilter<"StudentTestimonial"> | string
    role?: StringFilter<"StudentTestimonial"> | string
    content?: StringFilter<"StudentTestimonial"> | string
    rating?: IntFilter<"StudentTestimonial"> | number
    date?: DateTimeFilter<"StudentTestimonial"> | Date | string
    profileId?: IntFilter<"StudentTestimonial"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }

  export type StudentTestimonialOrderByWithRelationInput = {
    id?: SortOrder
    author?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
    profile?: StudentProfileOrderByWithRelationInput
  }

  export type StudentTestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentTestimonialWhereInput | StudentTestimonialWhereInput[]
    OR?: StudentTestimonialWhereInput[]
    NOT?: StudentTestimonialWhereInput | StudentTestimonialWhereInput[]
    author?: StringFilter<"StudentTestimonial"> | string
    role?: StringFilter<"StudentTestimonial"> | string
    content?: StringFilter<"StudentTestimonial"> | string
    rating?: IntFilter<"StudentTestimonial"> | number
    date?: DateTimeFilter<"StudentTestimonial"> | Date | string
    profileId?: IntFilter<"StudentTestimonial"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type StudentTestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    author?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
    _count?: StudentTestimonialCountOrderByAggregateInput
    _avg?: StudentTestimonialAvgOrderByAggregateInput
    _max?: StudentTestimonialMaxOrderByAggregateInput
    _min?: StudentTestimonialMinOrderByAggregateInput
    _sum?: StudentTestimonialSumOrderByAggregateInput
  }

  export type StudentTestimonialScalarWhereWithAggregatesInput = {
    AND?: StudentTestimonialScalarWhereWithAggregatesInput | StudentTestimonialScalarWhereWithAggregatesInput[]
    OR?: StudentTestimonialScalarWhereWithAggregatesInput[]
    NOT?: StudentTestimonialScalarWhereWithAggregatesInput | StudentTestimonialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentTestimonial"> | number
    author?: StringWithAggregatesFilter<"StudentTestimonial"> | string
    role?: StringWithAggregatesFilter<"StudentTestimonial"> | string
    content?: StringWithAggregatesFilter<"StudentTestimonial"> | string
    rating?: IntWithAggregatesFilter<"StudentTestimonial"> | number
    date?: DateTimeWithAggregatesFilter<"StudentTestimonial"> | Date | string
    profileId?: IntWithAggregatesFilter<"StudentTestimonial"> | number
  }

  export type StudentSubjectWhereInput = {
    AND?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    OR?: StudentSubjectWhereInput[]
    NOT?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    id?: IntFilter<"StudentSubject"> | number
    name?: StringFilter<"StudentSubject"> | string
    grade?: StringFilter<"StudentSubject"> | string
    credits?: IntFilter<"StudentSubject"> | number
    semester?: StringFilter<"StudentSubject"> | string
    profileId?: IntFilter<"StudentSubject"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }

  export type StudentSubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    credits?: SortOrder
    semester?: SortOrder
    profileId?: SortOrder
    profile?: StudentProfileOrderByWithRelationInput
  }

  export type StudentSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    OR?: StudentSubjectWhereInput[]
    NOT?: StudentSubjectWhereInput | StudentSubjectWhereInput[]
    name?: StringFilter<"StudentSubject"> | string
    grade?: StringFilter<"StudentSubject"> | string
    credits?: IntFilter<"StudentSubject"> | number
    semester?: StringFilter<"StudentSubject"> | string
    profileId?: IntFilter<"StudentSubject"> | number
    profile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type StudentSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    credits?: SortOrder
    semester?: SortOrder
    profileId?: SortOrder
    _count?: StudentSubjectCountOrderByAggregateInput
    _avg?: StudentSubjectAvgOrderByAggregateInput
    _max?: StudentSubjectMaxOrderByAggregateInput
    _min?: StudentSubjectMinOrderByAggregateInput
    _sum?: StudentSubjectSumOrderByAggregateInput
  }

  export type StudentSubjectScalarWhereWithAggregatesInput = {
    AND?: StudentSubjectScalarWhereWithAggregatesInput | StudentSubjectScalarWhereWithAggregatesInput[]
    OR?: StudentSubjectScalarWhereWithAggregatesInput[]
    NOT?: StudentSubjectScalarWhereWithAggregatesInput | StudentSubjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentSubject"> | number
    name?: StringWithAggregatesFilter<"StudentSubject"> | string
    grade?: StringWithAggregatesFilter<"StudentSubject"> | string
    credits?: IntWithAggregatesFilter<"StudentSubject"> | number
    semester?: StringWithAggregatesFilter<"StudentSubject"> | string
    profileId?: IntWithAggregatesFilter<"StudentSubject"> | number
  }

  export type TrainingReviewWhereInput = {
    AND?: TrainingReviewWhereInput | TrainingReviewWhereInput[]
    OR?: TrainingReviewWhereInput[]
    NOT?: TrainingReviewWhereInput | TrainingReviewWhereInput[]
    id?: IntFilter<"TrainingReview"> | number
    content?: StringFilter<"TrainingReview"> | string
    rating?: IntFilter<"TrainingReview"> | number
    createdAt?: DateTimeFilter<"TrainingReview"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingReview"> | Date | string
    trainingId?: IntFilter<"TrainingReview"> | number
    studentProfileId?: IntFilter<"TrainingReview"> | number
    featuredStudentId?: IntNullableFilter<"TrainingReview"> | number | null
    training?: XOR<TrainingRelationFilter, TrainingWhereInput>
    studentProfile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
    featuredStudent?: XOR<FeaturedStudentNullableRelationFilter, FeaturedStudentWhereInput> | null
  }

  export type TrainingReviewOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrder
    studentProfileId?: SortOrder
    featuredStudentId?: SortOrderInput | SortOrder
    training?: TrainingOrderByWithRelationInput
    studentProfile?: StudentProfileOrderByWithRelationInput
    featuredStudent?: FeaturedStudentOrderByWithRelationInput
  }

  export type TrainingReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    trainingId_studentProfileId?: TrainingReviewTrainingIdStudentProfileIdCompoundUniqueInput
    AND?: TrainingReviewWhereInput | TrainingReviewWhereInput[]
    OR?: TrainingReviewWhereInput[]
    NOT?: TrainingReviewWhereInput | TrainingReviewWhereInput[]
    content?: StringFilter<"TrainingReview"> | string
    rating?: IntFilter<"TrainingReview"> | number
    createdAt?: DateTimeFilter<"TrainingReview"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingReview"> | Date | string
    trainingId?: IntFilter<"TrainingReview"> | number
    studentProfileId?: IntFilter<"TrainingReview"> | number
    featuredStudentId?: IntNullableFilter<"TrainingReview"> | number | null
    training?: XOR<TrainingRelationFilter, TrainingWhereInput>
    studentProfile?: XOR<StudentProfileRelationFilter, StudentProfileWhereInput>
    featuredStudent?: XOR<FeaturedStudentNullableRelationFilter, FeaturedStudentWhereInput> | null
  }, "id" | "trainingId_studentProfileId">

  export type TrainingReviewOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrder
    studentProfileId?: SortOrder
    featuredStudentId?: SortOrderInput | SortOrder
    _count?: TrainingReviewCountOrderByAggregateInput
    _avg?: TrainingReviewAvgOrderByAggregateInput
    _max?: TrainingReviewMaxOrderByAggregateInput
    _min?: TrainingReviewMinOrderByAggregateInput
    _sum?: TrainingReviewSumOrderByAggregateInput
  }

  export type TrainingReviewScalarWhereWithAggregatesInput = {
    AND?: TrainingReviewScalarWhereWithAggregatesInput | TrainingReviewScalarWhereWithAggregatesInput[]
    OR?: TrainingReviewScalarWhereWithAggregatesInput[]
    NOT?: TrainingReviewScalarWhereWithAggregatesInput | TrainingReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TrainingReview"> | number
    content?: StringWithAggregatesFilter<"TrainingReview"> | string
    rating?: IntWithAggregatesFilter<"TrainingReview"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TrainingReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingReview"> | Date | string
    trainingId?: IntWithAggregatesFilter<"TrainingReview"> | number
    studentProfileId?: IntWithAggregatesFilter<"TrainingReview"> | number
    featuredStudentId?: IntNullableWithAggregatesFilter<"TrainingReview"> | number | null
  }

  export type UserCreateInput = {
    name: string
    surname: string
    email: string
    password: string
    role?: $Enums.UserRole
    isStudent?: boolean
    createdAt?: Date | string
    applications?: ApplicationCreateNestedManyWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    surname: string
    email: string
    password: string
    role?: $Enums.UserRole
    isStudent?: boolean
    createdAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUpdateManyWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    surname: string
    email: string
    password: string
    role?: $Enums.UserRole
    isStudent?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsImageCreateInput = {
    url: string
    socialUrl?: string | null
    mobileSocialUrl?: string | null
    desktopSocialUrl?: string | null
    isMain?: boolean
    order?: number
    createdAt?: Date | string
    news: NewsCreateNestedOneWithoutImagesInput
  }

  export type NewsImageUncheckedCreateInput = {
    id?: number
    url: string
    socialUrl?: string | null
    mobileSocialUrl?: string | null
    desktopSocialUrl?: string | null
    isMain?: boolean
    order?: number
    newsId: number
    createdAt?: Date | string
  }

  export type NewsImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    socialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    desktopSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    news?: NewsUpdateOneRequiredWithoutImagesNestedInput
  }

  export type NewsImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    socialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    desktopSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    newsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsImageCreateManyInput = {
    id?: number
    url: string
    socialUrl?: string | null
    mobileSocialUrl?: string | null
    desktopSocialUrl?: string | null
    isMain?: boolean
    order?: number
    newsId: number
    createdAt?: Date | string
  }

  export type NewsImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    socialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    desktopSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    socialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    desktopSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    newsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateInput = {
    title: string
    content: string
    createdAt?: Date | string
    imageUrl?: string | null
    images?: NewsImageCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    imageUrl?: string | null
    images?: NewsImageUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NewsImageUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NewsImageUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsCreateManyInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    imageUrl?: string | null
  }

  export type NewsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationCreateInput = {
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    createdAt?: Date | string
    type: $Enums.TrainingType
    user?: UserCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateInput = {
    id?: number
    userId?: number | null
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    createdAt?: Date | string
    type: $Enums.TrainingType
  }

  export type ApplicationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    user?: UserUpdateOneWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
  }

  export type ApplicationCreateManyInput = {
    id?: number
    userId?: number | null
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    createdAt?: Date | string
    type: $Enums.TrainingType
  }

  export type ApplicationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
  }

  export type ApplicationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
  }

  export type JobListingCreateInput = {
    title: string
    company: string
    location: string
    type: $Enums.JobType
    salary: string
    description: string
    requirements?: JobListingCreaterequirementsInput | string[]
    posted?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type JobListingUncheckedCreateInput = {
    id?: number
    title: string
    company: string
    location: string
    type: $Enums.JobType
    salary: string
    description: string
    requirements?: JobListingCreaterequirementsInput | string[]
    posted?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type JobListingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    salary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: JobListingUpdaterequirementsInput | string[]
    posted?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobListingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    salary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: JobListingUpdaterequirementsInput | string[]
    posted?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobListingCreateManyInput = {
    id?: number
    title: string
    company: string
    location: string
    type: $Enums.JobType
    salary: string
    description: string
    requirements?: JobListingCreaterequirementsInput | string[]
    posted?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type JobListingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    salary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: JobListingUpdaterequirementsInput | string[]
    posted?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobListingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    salary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: JobListingUpdaterequirementsInput | string[]
    posted?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamMemberCreateInput = {
    fullName: string
    role: $Enums.TeamMemberRole
    description: string
    title: string
    imagePath: string
    email?: string | null
    phoneNumber?: string | null
    cvPath?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    facebookUrl?: string | null
    createdAt?: Date | string
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: number
    fullName: string
    role: $Enums.TeamMemberRole
    description: string
    title: string
    imagePath: string
    email?: string | null
    phoneNumber?: string | null
    cvPath?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    facebookUrl?: string | null
    createdAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole
    description?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole
    description?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: number
    fullName: string
    role: $Enums.TeamMemberRole
    description: string
    title: string
    imagePath: string
    email?: string | null
    phoneNumber?: string | null
    cvPath?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    facebookUrl?: string | null
    createdAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole
    description?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole
    description?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedStudentCreateInput = {
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    courseType: $Enums.CourseType
    score: number
    imagePath?: string | null
    description: string
    achievements?: FeaturedStudentCreateachievementsInput | string[]
    graduationDate: Date | string
    isActive?: boolean
    linkedinUrl?: string | null
    testimonial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentProfileCreateNestedOneWithoutFeaturedStudentInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutFeaturedStudentInput
  }

  export type FeaturedStudentUncheckedCreateInput = {
    id?: number
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    courseType: $Enums.CourseType
    score: number
    imagePath?: string | null
    description: string
    achievements?: FeaturedStudentCreateachievementsInput | string[]
    graduationDate: Date | string
    isActive?: boolean
    linkedinUrl?: string | null
    testimonial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfileId?: number | null
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutFeaturedStudentInput
  }

  export type FeaturedStudentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    score?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    achievements?: FeaturedStudentUpdateachievementsInput | string[]
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneWithoutFeaturedStudentNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutFeaturedStudentNestedInput
  }

  export type FeaturedStudentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    score?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    achievements?: FeaturedStudentUpdateachievementsInput | string[]
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutFeaturedStudentNestedInput
  }

  export type FeaturedStudentCreateManyInput = {
    id?: number
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    courseType: $Enums.CourseType
    score: number
    imagePath?: string | null
    description: string
    achievements?: FeaturedStudentCreateachievementsInput | string[]
    graduationDate: Date | string
    isActive?: boolean
    linkedinUrl?: string | null
    testimonial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfileId?: number | null
  }

  export type FeaturedStudentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    score?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    achievements?: FeaturedStudentUpdateachievementsInput | string[]
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedStudentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    score?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    achievements?: FeaturedStudentUpdateachievementsInput | string[]
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TrainingCreateInput = {
    title: string
    description?: string | null
    category: string
    level: string
    instructor: string
    totalHours: number
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: StudentTrainingEnrollmentCreateNestedManyWithoutTrainingInput
    reviews?: TrainingReviewCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    category: string
    level: string
    instructor: string
    totalHours: number
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutTrainingInput
    reviews?: TrainingReviewUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: StudentTrainingEnrollmentUpdateManyWithoutTrainingNestedInput
    reviews?: TrainingReviewUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutTrainingNestedInput
    reviews?: TrainingReviewUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    category: string
    level: string
    instructor: string
    totalHours: number
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTrainingEnrollmentCreateInput = {
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutEnrollmentsInput
    profile: StudentProfileCreateNestedOneWithoutTrainingsInput
  }

  export type StudentTrainingEnrollmentUncheckedCreateInput = {
    id?: number
    trainingId: number
    profileId: number
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTrainingEnrollmentUpdateInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutEnrollmentsNestedInput
    profile?: StudentProfileUpdateOneRequiredWithoutTrainingsNestedInput
  }

  export type StudentTrainingEnrollmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    trainingId?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTrainingEnrollmentCreateManyInput = {
    id?: number
    trainingId: number
    profileId: number
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTrainingEnrollmentUpdateManyMutationInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTrainingEnrollmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trainingId?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileCreateInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUpdateInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileCreateManyInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProfileUpdateManyMutationInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSkillCreateInput = {
    name: string
    level: number
    profile: StudentProfileCreateNestedOneWithoutSkillsInput
  }

  export type StudentSkillUncheckedCreateInput = {
    id?: number
    name: string
    level: number
    profileId: number
  }

  export type StudentSkillUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    profile?: StudentProfileUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type StudentSkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentSkillCreateManyInput = {
    id?: number
    name: string
    level: number
    profileId: number
  }

  export type StudentSkillUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type StudentSkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentBadgeCreateInput = {
    name: string
    type: string
    date: Date | string
    profile: StudentProfileCreateNestedOneWithoutBadgesInput
  }

  export type StudentBadgeUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    date: Date | string
    profileId: number
  }

  export type StudentBadgeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: StudentProfileUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type StudentBadgeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentBadgeCreateManyInput = {
    id?: number
    name: string
    type: string
    date: Date | string
    profileId: number
  }

  export type StudentBadgeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentBadgeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTrainingCreateInput = {
    title: string
    category: string
    level: string
    instructor: string
    hours?: number | null
    completionDate?: Date | string | null
    startDate?: Date | string | null
    status: string
    progress?: number | null
    certificate?: boolean
    profile: StudentProfileCreateNestedOneWithoutStudentTrainingInput
  }

  export type StudentTrainingUncheckedCreateInput = {
    id?: number
    title: string
    category: string
    level: string
    instructor: string
    hours?: number | null
    completionDate?: Date | string | null
    startDate?: Date | string | null
    status: string
    progress?: number | null
    certificate?: boolean
    profileId: number
  }

  export type StudentTrainingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    certificate?: BoolFieldUpdateOperationsInput | boolean
    profile?: StudentProfileUpdateOneRequiredWithoutStudentTrainingNestedInput
  }

  export type StudentTrainingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    certificate?: BoolFieldUpdateOperationsInput | boolean
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTrainingCreateManyInput = {
    id?: number
    title: string
    category: string
    level: string
    instructor: string
    hours?: number | null
    completionDate?: Date | string | null
    startDate?: Date | string | null
    status: string
    progress?: number | null
    certificate?: boolean
    profileId: number
  }

  export type StudentTrainingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    certificate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentTrainingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    certificate?: BoolFieldUpdateOperationsInput | boolean
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTestimonialCreateInput = {
    author: string
    role: string
    content: string
    rating: number
    date?: Date | string
    profile: StudentProfileCreateNestedOneWithoutTestimonialsInput
  }

  export type StudentTestimonialUncheckedCreateInput = {
    id?: number
    author: string
    role: string
    content: string
    rating: number
    date?: Date | string
    profileId: number
  }

  export type StudentTestimonialUpdateInput = {
    author?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: StudentProfileUpdateOneRequiredWithoutTestimonialsNestedInput
  }

  export type StudentTestimonialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTestimonialCreateManyInput = {
    id?: number
    author: string
    role: string
    content: string
    rating: number
    date?: Date | string
    profileId: number
  }

  export type StudentTestimonialUpdateManyMutationInput = {
    author?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTestimonialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentSubjectCreateInput = {
    name: string
    grade: string
    credits: number
    semester: string
    profile: StudentProfileCreateNestedOneWithoutAcademicSubjectsInput
  }

  export type StudentSubjectUncheckedCreateInput = {
    id?: number
    name: string
    grade: string
    credits: number
    semester: string
    profileId: number
  }

  export type StudentSubjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    profile?: StudentProfileUpdateOneRequiredWithoutAcademicSubjectsNestedInput
  }

  export type StudentSubjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentSubjectCreateManyInput = {
    id?: number
    name: string
    grade: string
    credits: number
    semester: string
    profileId: number
  }

  export type StudentSubjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSubjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
  }

  export type TrainingReviewCreateInput = {
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutReviewsInput
    studentProfile: StudentProfileCreateNestedOneWithoutTrainingReviewsInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutTrainingReviewsInput
  }

  export type TrainingReviewUncheckedCreateInput = {
    id?: number
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId: number
    studentProfileId: number
    featuredStudentId?: number | null
  }

  export type TrainingReviewUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutReviewsNestedInput
    studentProfile?: StudentProfileUpdateOneRequiredWithoutTrainingReviewsNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutTrainingReviewsNestedInput
  }

  export type TrainingReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    featuredStudentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TrainingReviewCreateManyInput = {
    id?: number
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId: number
    studentProfileId: number
    featuredStudentId?: number | null
  }

  export type TrainingReviewUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
    featuredStudentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type StudentProfileNullableRelationFilter = {
    is?: StudentProfileWhereInput | null
    isNot?: StudentProfileWhereInput | null
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NewsRelationFilter = {
    is?: NewsWhereInput
    isNot?: NewsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NewsImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    socialUrl?: SortOrder
    mobileSocialUrl?: SortOrder
    desktopSocialUrl?: SortOrder
    isMain?: SortOrder
    order?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsImageAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    newsId?: SortOrder
  }

  export type NewsImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    socialUrl?: SortOrder
    mobileSocialUrl?: SortOrder
    desktopSocialUrl?: SortOrder
    isMain?: SortOrder
    order?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    socialUrl?: SortOrder
    mobileSocialUrl?: SortOrder
    desktopSocialUrl?: SortOrder
    isMain?: SortOrder
    order?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsImageSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    newsId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NewsImageListRelationFilter = {
    every?: NewsImageWhereInput
    some?: NewsImageWhereInput
    none?: NewsImageWhereInput
  }

  export type NewsImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    imageUrl?: SortOrder
  }

  export type NewsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    imageUrl?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    imageUrl?: SortOrder
  }

  export type NewsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTrainingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeFilter<$PrismaModel> | $Enums.TrainingType
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ApplicationEmailTypeCompoundUniqueInput = {
    email: string
    type: $Enums.TrainingType
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type ApplicationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type ApplicationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumTrainingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrainingTypeFilter<$PrismaModel>
  }

  export type EnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type JobListingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    type?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    posted?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type JobListingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JobListingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    type?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    posted?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type JobListingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    type?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    posted?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type JobListingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type EnumTeamMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberRole | EnumTeamMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberRoleFilter<$PrismaModel> | $Enums.TeamMemberRole
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    description?: SortOrder
    title?: SortOrder
    imagePath?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    cvPath?: SortOrder
    linkedinUrl?: SortOrder
    twitterUrl?: SortOrder
    facebookUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    description?: SortOrder
    title?: SortOrder
    imagePath?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    cvPath?: SortOrder
    linkedinUrl?: SortOrder
    twitterUrl?: SortOrder
    facebookUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    description?: SortOrder
    title?: SortOrder
    imagePath?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    cvPath?: SortOrder
    linkedinUrl?: SortOrder
    twitterUrl?: SortOrder
    facebookUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTeamMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberRole | EnumTeamMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamMemberRoleFilter<$PrismaModel>
  }

  export type EnumCourseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeFilter<$PrismaModel> | $Enums.CourseType
  }

  export type TrainingReviewListRelationFilter = {
    every?: TrainingReviewWhereInput
    some?: TrainingReviewWhereInput
    none?: TrainingReviewWhereInput
  }

  export type TrainingReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeaturedStudentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    courseType?: SortOrder
    score?: SortOrder
    imagePath?: SortOrder
    description?: SortOrder
    achievements?: SortOrder
    graduationDate?: SortOrder
    isActive?: SortOrder
    linkedinUrl?: SortOrder
    testimonial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfileId?: SortOrder
  }

  export type FeaturedStudentAvgOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    studentProfileId?: SortOrder
  }

  export type FeaturedStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    courseType?: SortOrder
    score?: SortOrder
    imagePath?: SortOrder
    description?: SortOrder
    graduationDate?: SortOrder
    isActive?: SortOrder
    linkedinUrl?: SortOrder
    testimonial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfileId?: SortOrder
  }

  export type FeaturedStudentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    courseType?: SortOrder
    score?: SortOrder
    imagePath?: SortOrder
    description?: SortOrder
    graduationDate?: SortOrder
    isActive?: SortOrder
    linkedinUrl?: SortOrder
    testimonial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfileId?: SortOrder
  }

  export type FeaturedStudentSumOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    studentProfileId?: SortOrder
  }

  export type EnumCourseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTypeFilter<$PrismaModel>
    _max?: NestedEnumCourseTypeFilter<$PrismaModel>
  }

  export type StudentTrainingEnrollmentListRelationFilter = {
    every?: StudentTrainingEnrollmentWhereInput
    some?: StudentTrainingEnrollmentWhereInput
    none?: StudentTrainingEnrollmentWhereInput
  }

  export type StudentTrainingEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    totalHours?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingAvgOrderByAggregateInput = {
    id?: SortOrder
    totalHours?: SortOrder
    maxParticipants?: SortOrder
  }

  export type TrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    totalHours?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    totalHours?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSumOrderByAggregateInput = {
    id?: SortOrder
    totalHours?: SortOrder
    maxParticipants?: SortOrder
  }

  export type EnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TrainingRelationFilter = {
    is?: TrainingWhereInput
    isNot?: TrainingWhereInput
  }

  export type StudentProfileRelationFilter = {
    is?: StudentProfileWhereInput
    isNot?: StudentProfileWhereInput
  }

  export type StudentTrainingEnrollmentTrainingIdProfileIdCompoundUniqueInput = {
    trainingId: number
    profileId: number
  }

  export type StudentTrainingEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    profileId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completionDate?: SortOrder
    certificateUrl?: SortOrder
    attendance?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTrainingEnrollmentAvgOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    profileId?: SortOrder
    progress?: SortOrder
    attendance?: SortOrder
    grade?: SortOrder
  }

  export type StudentTrainingEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    profileId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completionDate?: SortOrder
    certificateUrl?: SortOrder
    attendance?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTrainingEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    profileId?: SortOrder
    enrollmentDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completionDate?: SortOrder
    certificateUrl?: SortOrder
    attendance?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTrainingEnrollmentSumOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    profileId?: SortOrder
    progress?: SortOrder
    attendance?: SortOrder
    grade?: SortOrder
  }

  export type EnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type StudentSkillListRelationFilter = {
    every?: StudentSkillWhereInput
    some?: StudentSkillWhereInput
    none?: StudentSkillWhereInput
  }

  export type StudentBadgeListRelationFilter = {
    every?: StudentBadgeWhereInput
    some?: StudentBadgeWhereInput
    none?: StudentBadgeWhereInput
  }

  export type StudentTestimonialListRelationFilter = {
    every?: StudentTestimonialWhereInput
    some?: StudentTestimonialWhereInput
    none?: StudentTestimonialWhereInput
  }

  export type StudentSubjectListRelationFilter = {
    every?: StudentSubjectWhereInput
    some?: StudentSubjectWhereInput
    none?: StudentSubjectWhereInput
  }

  export type FeaturedStudentNullableRelationFilter = {
    is?: FeaturedStudentWhereInput | null
    isNot?: FeaturedStudentWhereInput | null
  }

  export type StudentTrainingListRelationFilter = {
    every?: StudentTrainingWhereInput
    some?: StudentTrainingWhereInput
    none?: StudentTrainingWhereInput
  }

  export type StudentSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTestimonialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTrainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    university?: SortOrder
    faculty?: SortOrder
    year?: SortOrder
    gpa?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    linkedinUrl?: SortOrder
    facebookUrl?: SortOrder
    githubUrl?: SortOrder
    portfolioUrl?: SortOrder
    profileImage?: SortOrder
    cvPath?: SortOrder
    attendance?: SortOrder
    totalCredits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gpa?: SortOrder
    attendance?: SortOrder
    totalCredits?: SortOrder
  }

  export type StudentProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    university?: SortOrder
    faculty?: SortOrder
    year?: SortOrder
    gpa?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    linkedinUrl?: SortOrder
    facebookUrl?: SortOrder
    githubUrl?: SortOrder
    portfolioUrl?: SortOrder
    profileImage?: SortOrder
    cvPath?: SortOrder
    attendance?: SortOrder
    totalCredits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    university?: SortOrder
    faculty?: SortOrder
    year?: SortOrder
    gpa?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    linkedinUrl?: SortOrder
    facebookUrl?: SortOrder
    githubUrl?: SortOrder
    portfolioUrl?: SortOrder
    profileImage?: SortOrder
    cvPath?: SortOrder
    attendance?: SortOrder
    totalCredits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gpa?: SortOrder
    attendance?: SortOrder
    totalCredits?: SortOrder
  }

  export type StudentSkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSkillAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSkillSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    profileId?: SortOrder
  }

  export type StudentBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
  }

  export type StudentBadgeAvgOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
  }

  export type StudentBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
  }

  export type StudentBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
  }

  export type StudentBadgeSumOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTrainingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    hours?: SortOrder
    completionDate?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    certificate?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTrainingAvgOrderByAggregateInput = {
    id?: SortOrder
    hours?: SortOrder
    progress?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    hours?: SortOrder
    completionDate?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    certificate?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTrainingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    instructor?: SortOrder
    hours?: SortOrder
    completionDate?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    certificate?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTrainingSumOrderByAggregateInput = {
    id?: SortOrder
    hours?: SortOrder
    progress?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    author?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTestimonialAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    author?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    author?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    date?: SortOrder
    profileId?: SortOrder
  }

  export type StudentTestimonialSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    credits?: SortOrder
    semester?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSubjectAvgOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    credits?: SortOrder
    semester?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    credits?: SortOrder
    semester?: SortOrder
    profileId?: SortOrder
  }

  export type StudentSubjectSumOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
    profileId?: SortOrder
  }

  export type TrainingReviewTrainingIdStudentProfileIdCompoundUniqueInput = {
    trainingId: number
    studentProfileId: number
  }

  export type TrainingReviewCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrder
    studentProfileId?: SortOrder
    featuredStudentId?: SortOrder
  }

  export type TrainingReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    trainingId?: SortOrder
    studentProfileId?: SortOrder
    featuredStudentId?: SortOrder
  }

  export type TrainingReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrder
    studentProfileId?: SortOrder
    featuredStudentId?: SortOrder
  }

  export type TrainingReviewMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrder
    studentProfileId?: SortOrder
    featuredStudentId?: SortOrder
  }

  export type TrainingReviewSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    trainingId?: SortOrder
    studentProfileId?: SortOrder
    featuredStudentId?: SortOrder
  }

  export type ApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput> | ApplicationCreateWithoutUserInput[] | ApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput | ApplicationCreateOrConnectWithoutUserInput[]
    createMany?: ApplicationCreateManyUserInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type StudentProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type ApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput> | ApplicationCreateWithoutUserInput[] | ApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput | ApplicationCreateOrConnectWithoutUserInput[]
    createMany?: ApplicationCreateManyUserInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type StudentProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput> | ApplicationCreateWithoutUserInput[] | ApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput | ApplicationCreateOrConnectWithoutUserInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutUserInput | ApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApplicationCreateManyUserInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutUserInput | ApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutUserInput | ApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StudentProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    upsert?: StudentProfileUpsertWithoutUserInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutUserInput, StudentProfileUpdateWithoutUserInput>, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput> | ApplicationCreateWithoutUserInput[] | ApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutUserInput | ApplicationCreateOrConnectWithoutUserInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutUserInput | ApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApplicationCreateManyUserInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutUserInput | ApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutUserInput | ApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StudentProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    upsert?: StudentProfileUpsertWithoutUserInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutUserInput, StudentProfileUpdateWithoutUserInput>, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type NewsCreateNestedOneWithoutImagesInput = {
    create?: XOR<NewsCreateWithoutImagesInput, NewsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: NewsCreateOrConnectWithoutImagesInput
    connect?: NewsWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NewsUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<NewsCreateWithoutImagesInput, NewsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: NewsCreateOrConnectWithoutImagesInput
    upsert?: NewsUpsertWithoutImagesInput
    connect?: NewsWhereUniqueInput
    update?: XOR<XOR<NewsUpdateToOneWithWhereWithoutImagesInput, NewsUpdateWithoutImagesInput>, NewsUncheckedUpdateWithoutImagesInput>
  }

  export type NewsImageCreateNestedManyWithoutNewsInput = {
    create?: XOR<NewsImageCreateWithoutNewsInput, NewsImageUncheckedCreateWithoutNewsInput> | NewsImageCreateWithoutNewsInput[] | NewsImageUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: NewsImageCreateOrConnectWithoutNewsInput | NewsImageCreateOrConnectWithoutNewsInput[]
    createMany?: NewsImageCreateManyNewsInputEnvelope
    connect?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
  }

  export type NewsImageUncheckedCreateNestedManyWithoutNewsInput = {
    create?: XOR<NewsImageCreateWithoutNewsInput, NewsImageUncheckedCreateWithoutNewsInput> | NewsImageCreateWithoutNewsInput[] | NewsImageUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: NewsImageCreateOrConnectWithoutNewsInput | NewsImageCreateOrConnectWithoutNewsInput[]
    createMany?: NewsImageCreateManyNewsInputEnvelope
    connect?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
  }

  export type NewsImageUpdateManyWithoutNewsNestedInput = {
    create?: XOR<NewsImageCreateWithoutNewsInput, NewsImageUncheckedCreateWithoutNewsInput> | NewsImageCreateWithoutNewsInput[] | NewsImageUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: NewsImageCreateOrConnectWithoutNewsInput | NewsImageCreateOrConnectWithoutNewsInput[]
    upsert?: NewsImageUpsertWithWhereUniqueWithoutNewsInput | NewsImageUpsertWithWhereUniqueWithoutNewsInput[]
    createMany?: NewsImageCreateManyNewsInputEnvelope
    set?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
    disconnect?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
    delete?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
    connect?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
    update?: NewsImageUpdateWithWhereUniqueWithoutNewsInput | NewsImageUpdateWithWhereUniqueWithoutNewsInput[]
    updateMany?: NewsImageUpdateManyWithWhereWithoutNewsInput | NewsImageUpdateManyWithWhereWithoutNewsInput[]
    deleteMany?: NewsImageScalarWhereInput | NewsImageScalarWhereInput[]
  }

  export type NewsImageUncheckedUpdateManyWithoutNewsNestedInput = {
    create?: XOR<NewsImageCreateWithoutNewsInput, NewsImageUncheckedCreateWithoutNewsInput> | NewsImageCreateWithoutNewsInput[] | NewsImageUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: NewsImageCreateOrConnectWithoutNewsInput | NewsImageCreateOrConnectWithoutNewsInput[]
    upsert?: NewsImageUpsertWithWhereUniqueWithoutNewsInput | NewsImageUpsertWithWhereUniqueWithoutNewsInput[]
    createMany?: NewsImageCreateManyNewsInputEnvelope
    set?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
    disconnect?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
    delete?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
    connect?: NewsImageWhereUniqueInput | NewsImageWhereUniqueInput[]
    update?: NewsImageUpdateWithWhereUniqueWithoutNewsInput | NewsImageUpdateWithWhereUniqueWithoutNewsInput[]
    updateMany?: NewsImageUpdateManyWithWhereWithoutNewsInput | NewsImageUpdateManyWithWhereWithoutNewsInput[]
    deleteMany?: NewsImageScalarWhereInput | NewsImageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTrainingTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrainingType
  }

  export type UserUpdateOneWithoutApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    upsert?: UserUpsertWithoutApplicationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicationsInput, UserUpdateWithoutApplicationsInput>, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobListingCreaterequirementsInput = {
    set: string[]
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.JobType
  }

  export type JobListingUpdaterequirementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumTeamMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamMemberRole
  }

  export type FeaturedStudentCreateachievementsInput = {
    set: string[]
  }

  export type StudentProfileCreateNestedOneWithoutFeaturedStudentInput = {
    create?: XOR<StudentProfileCreateWithoutFeaturedStudentInput, StudentProfileUncheckedCreateWithoutFeaturedStudentInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutFeaturedStudentInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type TrainingReviewCreateNestedManyWithoutFeaturedStudentInput = {
    create?: XOR<TrainingReviewCreateWithoutFeaturedStudentInput, TrainingReviewUncheckedCreateWithoutFeaturedStudentInput> | TrainingReviewCreateWithoutFeaturedStudentInput[] | TrainingReviewUncheckedCreateWithoutFeaturedStudentInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutFeaturedStudentInput | TrainingReviewCreateOrConnectWithoutFeaturedStudentInput[]
    createMany?: TrainingReviewCreateManyFeaturedStudentInputEnvelope
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
  }

  export type TrainingReviewUncheckedCreateNestedManyWithoutFeaturedStudentInput = {
    create?: XOR<TrainingReviewCreateWithoutFeaturedStudentInput, TrainingReviewUncheckedCreateWithoutFeaturedStudentInput> | TrainingReviewCreateWithoutFeaturedStudentInput[] | TrainingReviewUncheckedCreateWithoutFeaturedStudentInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutFeaturedStudentInput | TrainingReviewCreateOrConnectWithoutFeaturedStudentInput[]
    createMany?: TrainingReviewCreateManyFeaturedStudentInputEnvelope
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
  }

  export type EnumCourseTypeFieldUpdateOperationsInput = {
    set?: $Enums.CourseType
  }

  export type FeaturedStudentUpdateachievementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StudentProfileUpdateOneWithoutFeaturedStudentNestedInput = {
    create?: XOR<StudentProfileCreateWithoutFeaturedStudentInput, StudentProfileUncheckedCreateWithoutFeaturedStudentInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutFeaturedStudentInput
    upsert?: StudentProfileUpsertWithoutFeaturedStudentInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutFeaturedStudentInput, StudentProfileUpdateWithoutFeaturedStudentInput>, StudentProfileUncheckedUpdateWithoutFeaturedStudentInput>
  }

  export type TrainingReviewUpdateManyWithoutFeaturedStudentNestedInput = {
    create?: XOR<TrainingReviewCreateWithoutFeaturedStudentInput, TrainingReviewUncheckedCreateWithoutFeaturedStudentInput> | TrainingReviewCreateWithoutFeaturedStudentInput[] | TrainingReviewUncheckedCreateWithoutFeaturedStudentInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutFeaturedStudentInput | TrainingReviewCreateOrConnectWithoutFeaturedStudentInput[]
    upsert?: TrainingReviewUpsertWithWhereUniqueWithoutFeaturedStudentInput | TrainingReviewUpsertWithWhereUniqueWithoutFeaturedStudentInput[]
    createMany?: TrainingReviewCreateManyFeaturedStudentInputEnvelope
    set?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    disconnect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    delete?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    update?: TrainingReviewUpdateWithWhereUniqueWithoutFeaturedStudentInput | TrainingReviewUpdateWithWhereUniqueWithoutFeaturedStudentInput[]
    updateMany?: TrainingReviewUpdateManyWithWhereWithoutFeaturedStudentInput | TrainingReviewUpdateManyWithWhereWithoutFeaturedStudentInput[]
    deleteMany?: TrainingReviewScalarWhereInput | TrainingReviewScalarWhereInput[]
  }

  export type TrainingReviewUncheckedUpdateManyWithoutFeaturedStudentNestedInput = {
    create?: XOR<TrainingReviewCreateWithoutFeaturedStudentInput, TrainingReviewUncheckedCreateWithoutFeaturedStudentInput> | TrainingReviewCreateWithoutFeaturedStudentInput[] | TrainingReviewUncheckedCreateWithoutFeaturedStudentInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutFeaturedStudentInput | TrainingReviewCreateOrConnectWithoutFeaturedStudentInput[]
    upsert?: TrainingReviewUpsertWithWhereUniqueWithoutFeaturedStudentInput | TrainingReviewUpsertWithWhereUniqueWithoutFeaturedStudentInput[]
    createMany?: TrainingReviewCreateManyFeaturedStudentInputEnvelope
    set?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    disconnect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    delete?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    update?: TrainingReviewUpdateWithWhereUniqueWithoutFeaturedStudentInput | TrainingReviewUpdateWithWhereUniqueWithoutFeaturedStudentInput[]
    updateMany?: TrainingReviewUpdateManyWithWhereWithoutFeaturedStudentInput | TrainingReviewUpdateManyWithWhereWithoutFeaturedStudentInput[]
    deleteMany?: TrainingReviewScalarWhereInput | TrainingReviewScalarWhereInput[]
  }

  export type StudentTrainingEnrollmentCreateNestedManyWithoutTrainingInput = {
    create?: XOR<StudentTrainingEnrollmentCreateWithoutTrainingInput, StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput> | StudentTrainingEnrollmentCreateWithoutTrainingInput[] | StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput | StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput[]
    createMany?: StudentTrainingEnrollmentCreateManyTrainingInputEnvelope
    connect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
  }

  export type TrainingReviewCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingReviewCreateWithoutTrainingInput, TrainingReviewUncheckedCreateWithoutTrainingInput> | TrainingReviewCreateWithoutTrainingInput[] | TrainingReviewUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutTrainingInput | TrainingReviewCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingReviewCreateManyTrainingInputEnvelope
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
  }

  export type StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<StudentTrainingEnrollmentCreateWithoutTrainingInput, StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput> | StudentTrainingEnrollmentCreateWithoutTrainingInput[] | StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput | StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput[]
    createMany?: StudentTrainingEnrollmentCreateManyTrainingInputEnvelope
    connect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
  }

  export type TrainingReviewUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingReviewCreateWithoutTrainingInput, TrainingReviewUncheckedCreateWithoutTrainingInput> | TrainingReviewCreateWithoutTrainingInput[] | TrainingReviewUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutTrainingInput | TrainingReviewCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingReviewCreateManyTrainingInputEnvelope
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
  }

  export type StudentTrainingEnrollmentUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<StudentTrainingEnrollmentCreateWithoutTrainingInput, StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput> | StudentTrainingEnrollmentCreateWithoutTrainingInput[] | StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput | StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput[]
    upsert?: StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput | StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: StudentTrainingEnrollmentCreateManyTrainingInputEnvelope
    set?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    disconnect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    delete?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    connect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    update?: StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput | StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: StudentTrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput | StudentTrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: StudentTrainingEnrollmentScalarWhereInput | StudentTrainingEnrollmentScalarWhereInput[]
  }

  export type TrainingReviewUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingReviewCreateWithoutTrainingInput, TrainingReviewUncheckedCreateWithoutTrainingInput> | TrainingReviewCreateWithoutTrainingInput[] | TrainingReviewUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutTrainingInput | TrainingReviewCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingReviewUpsertWithWhereUniqueWithoutTrainingInput | TrainingReviewUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingReviewCreateManyTrainingInputEnvelope
    set?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    disconnect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    delete?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    update?: TrainingReviewUpdateWithWhereUniqueWithoutTrainingInput | TrainingReviewUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingReviewUpdateManyWithWhereWithoutTrainingInput | TrainingReviewUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingReviewScalarWhereInput | TrainingReviewScalarWhereInput[]
  }

  export type StudentTrainingEnrollmentUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<StudentTrainingEnrollmentCreateWithoutTrainingInput, StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput> | StudentTrainingEnrollmentCreateWithoutTrainingInput[] | StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput | StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput[]
    upsert?: StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput | StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: StudentTrainingEnrollmentCreateManyTrainingInputEnvelope
    set?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    disconnect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    delete?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    connect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    update?: StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput | StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: StudentTrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput | StudentTrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: StudentTrainingEnrollmentScalarWhereInput | StudentTrainingEnrollmentScalarWhereInput[]
  }

  export type TrainingReviewUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingReviewCreateWithoutTrainingInput, TrainingReviewUncheckedCreateWithoutTrainingInput> | TrainingReviewCreateWithoutTrainingInput[] | TrainingReviewUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutTrainingInput | TrainingReviewCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingReviewUpsertWithWhereUniqueWithoutTrainingInput | TrainingReviewUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingReviewCreateManyTrainingInputEnvelope
    set?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    disconnect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    delete?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    update?: TrainingReviewUpdateWithWhereUniqueWithoutTrainingInput | TrainingReviewUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingReviewUpdateManyWithWhereWithoutTrainingInput | TrainingReviewUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingReviewScalarWhereInput | TrainingReviewScalarWhereInput[]
  }

  export type TrainingCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<TrainingCreateWithoutEnrollmentsInput, TrainingUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutEnrollmentsInput
    connect?: TrainingWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutTrainingsInput = {
    create?: XOR<StudentProfileCreateWithoutTrainingsInput, StudentProfileUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTrainingsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type EnumTrainingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrainingStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TrainingUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<TrainingCreateWithoutEnrollmentsInput, TrainingUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutEnrollmentsInput
    upsert?: TrainingUpsertWithoutEnrollmentsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutEnrollmentsInput, TrainingUpdateWithoutEnrollmentsInput>, TrainingUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentProfileUpdateOneRequiredWithoutTrainingsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutTrainingsInput, StudentProfileUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTrainingsInput
    upsert?: StudentProfileUpsertWithoutTrainingsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutTrainingsInput, StudentProfileUpdateWithoutTrainingsInput>, StudentProfileUncheckedUpdateWithoutTrainingsInput>
  }

  export type UserCreateNestedOneWithoutStudentProfileInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    connect?: UserWhereUniqueInput
  }

  export type StudentSkillCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentSkillCreateWithoutProfileInput, StudentSkillUncheckedCreateWithoutProfileInput> | StudentSkillCreateWithoutProfileInput[] | StudentSkillUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutProfileInput | StudentSkillCreateOrConnectWithoutProfileInput[]
    createMany?: StudentSkillCreateManyProfileInputEnvelope
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
  }

  export type StudentBadgeCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentBadgeCreateWithoutProfileInput, StudentBadgeUncheckedCreateWithoutProfileInput> | StudentBadgeCreateWithoutProfileInput[] | StudentBadgeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentBadgeCreateOrConnectWithoutProfileInput | StudentBadgeCreateOrConnectWithoutProfileInput[]
    createMany?: StudentBadgeCreateManyProfileInputEnvelope
    connect?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
  }

  export type StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentTrainingEnrollmentCreateWithoutProfileInput, StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput> | StudentTrainingEnrollmentCreateWithoutProfileInput[] | StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput | StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput[]
    createMany?: StudentTrainingEnrollmentCreateManyProfileInputEnvelope
    connect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
  }

  export type StudentTestimonialCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentTestimonialCreateWithoutProfileInput, StudentTestimonialUncheckedCreateWithoutProfileInput> | StudentTestimonialCreateWithoutProfileInput[] | StudentTestimonialUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTestimonialCreateOrConnectWithoutProfileInput | StudentTestimonialCreateOrConnectWithoutProfileInput[]
    createMany?: StudentTestimonialCreateManyProfileInputEnvelope
    connect?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
  }

  export type StudentSubjectCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentSubjectCreateWithoutProfileInput, StudentSubjectUncheckedCreateWithoutProfileInput> | StudentSubjectCreateWithoutProfileInput[] | StudentSubjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutProfileInput | StudentSubjectCreateOrConnectWithoutProfileInput[]
    createMany?: StudentSubjectCreateManyProfileInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type FeaturedStudentCreateNestedOneWithoutStudentProfileInput = {
    create?: XOR<FeaturedStudentCreateWithoutStudentProfileInput, FeaturedStudentUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: FeaturedStudentCreateOrConnectWithoutStudentProfileInput
    connect?: FeaturedStudentWhereUniqueInput
  }

  export type TrainingReviewCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<TrainingReviewCreateWithoutStudentProfileInput, TrainingReviewUncheckedCreateWithoutStudentProfileInput> | TrainingReviewCreateWithoutStudentProfileInput[] | TrainingReviewUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutStudentProfileInput | TrainingReviewCreateOrConnectWithoutStudentProfileInput[]
    createMany?: TrainingReviewCreateManyStudentProfileInputEnvelope
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
  }

  export type StudentTrainingCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentTrainingCreateWithoutProfileInput, StudentTrainingUncheckedCreateWithoutProfileInput> | StudentTrainingCreateWithoutProfileInput[] | StudentTrainingUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTrainingCreateOrConnectWithoutProfileInput | StudentTrainingCreateOrConnectWithoutProfileInput[]
    createMany?: StudentTrainingCreateManyProfileInputEnvelope
    connect?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
  }

  export type StudentSkillUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentSkillCreateWithoutProfileInput, StudentSkillUncheckedCreateWithoutProfileInput> | StudentSkillCreateWithoutProfileInput[] | StudentSkillUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutProfileInput | StudentSkillCreateOrConnectWithoutProfileInput[]
    createMany?: StudentSkillCreateManyProfileInputEnvelope
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
  }

  export type StudentBadgeUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentBadgeCreateWithoutProfileInput, StudentBadgeUncheckedCreateWithoutProfileInput> | StudentBadgeCreateWithoutProfileInput[] | StudentBadgeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentBadgeCreateOrConnectWithoutProfileInput | StudentBadgeCreateOrConnectWithoutProfileInput[]
    createMany?: StudentBadgeCreateManyProfileInputEnvelope
    connect?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
  }

  export type StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentTrainingEnrollmentCreateWithoutProfileInput, StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput> | StudentTrainingEnrollmentCreateWithoutProfileInput[] | StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput | StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput[]
    createMany?: StudentTrainingEnrollmentCreateManyProfileInputEnvelope
    connect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
  }

  export type StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentTestimonialCreateWithoutProfileInput, StudentTestimonialUncheckedCreateWithoutProfileInput> | StudentTestimonialCreateWithoutProfileInput[] | StudentTestimonialUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTestimonialCreateOrConnectWithoutProfileInput | StudentTestimonialCreateOrConnectWithoutProfileInput[]
    createMany?: StudentTestimonialCreateManyProfileInputEnvelope
    connect?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
  }

  export type StudentSubjectUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentSubjectCreateWithoutProfileInput, StudentSubjectUncheckedCreateWithoutProfileInput> | StudentSubjectCreateWithoutProfileInput[] | StudentSubjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutProfileInput | StudentSubjectCreateOrConnectWithoutProfileInput[]
    createMany?: StudentSubjectCreateManyProfileInputEnvelope
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
  }

  export type FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput = {
    create?: XOR<FeaturedStudentCreateWithoutStudentProfileInput, FeaturedStudentUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: FeaturedStudentCreateOrConnectWithoutStudentProfileInput
    connect?: FeaturedStudentWhereUniqueInput
  }

  export type TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput = {
    create?: XOR<TrainingReviewCreateWithoutStudentProfileInput, TrainingReviewUncheckedCreateWithoutStudentProfileInput> | TrainingReviewCreateWithoutStudentProfileInput[] | TrainingReviewUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutStudentProfileInput | TrainingReviewCreateOrConnectWithoutStudentProfileInput[]
    createMany?: TrainingReviewCreateManyStudentProfileInputEnvelope
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
  }

  export type StudentTrainingUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<StudentTrainingCreateWithoutProfileInput, StudentTrainingUncheckedCreateWithoutProfileInput> | StudentTrainingCreateWithoutProfileInput[] | StudentTrainingUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTrainingCreateOrConnectWithoutProfileInput | StudentTrainingCreateOrConnectWithoutProfileInput[]
    createMany?: StudentTrainingCreateManyProfileInputEnvelope
    connect?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStudentProfileNestedInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    upsert?: UserUpsertWithoutStudentProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentProfileInput, UserUpdateWithoutStudentProfileInput>, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type StudentSkillUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentSkillCreateWithoutProfileInput, StudentSkillUncheckedCreateWithoutProfileInput> | StudentSkillCreateWithoutProfileInput[] | StudentSkillUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutProfileInput | StudentSkillCreateOrConnectWithoutProfileInput[]
    upsert?: StudentSkillUpsertWithWhereUniqueWithoutProfileInput | StudentSkillUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentSkillCreateManyProfileInputEnvelope
    set?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    disconnect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    delete?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    update?: StudentSkillUpdateWithWhereUniqueWithoutProfileInput | StudentSkillUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentSkillUpdateManyWithWhereWithoutProfileInput | StudentSkillUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
  }

  export type StudentBadgeUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentBadgeCreateWithoutProfileInput, StudentBadgeUncheckedCreateWithoutProfileInput> | StudentBadgeCreateWithoutProfileInput[] | StudentBadgeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentBadgeCreateOrConnectWithoutProfileInput | StudentBadgeCreateOrConnectWithoutProfileInput[]
    upsert?: StudentBadgeUpsertWithWhereUniqueWithoutProfileInput | StudentBadgeUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentBadgeCreateManyProfileInputEnvelope
    set?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
    disconnect?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
    delete?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
    connect?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
    update?: StudentBadgeUpdateWithWhereUniqueWithoutProfileInput | StudentBadgeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentBadgeUpdateManyWithWhereWithoutProfileInput | StudentBadgeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentBadgeScalarWhereInput | StudentBadgeScalarWhereInput[]
  }

  export type StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentTrainingEnrollmentCreateWithoutProfileInput, StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput> | StudentTrainingEnrollmentCreateWithoutProfileInput[] | StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput | StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput[]
    upsert?: StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutProfileInput | StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentTrainingEnrollmentCreateManyProfileInputEnvelope
    set?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    disconnect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    delete?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    connect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    update?: StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutProfileInput | StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentTrainingEnrollmentUpdateManyWithWhereWithoutProfileInput | StudentTrainingEnrollmentUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentTrainingEnrollmentScalarWhereInput | StudentTrainingEnrollmentScalarWhereInput[]
  }

  export type StudentTestimonialUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentTestimonialCreateWithoutProfileInput, StudentTestimonialUncheckedCreateWithoutProfileInput> | StudentTestimonialCreateWithoutProfileInput[] | StudentTestimonialUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTestimonialCreateOrConnectWithoutProfileInput | StudentTestimonialCreateOrConnectWithoutProfileInput[]
    upsert?: StudentTestimonialUpsertWithWhereUniqueWithoutProfileInput | StudentTestimonialUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentTestimonialCreateManyProfileInputEnvelope
    set?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
    disconnect?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
    delete?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
    connect?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
    update?: StudentTestimonialUpdateWithWhereUniqueWithoutProfileInput | StudentTestimonialUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentTestimonialUpdateManyWithWhereWithoutProfileInput | StudentTestimonialUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentTestimonialScalarWhereInput | StudentTestimonialScalarWhereInput[]
  }

  export type StudentSubjectUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutProfileInput, StudentSubjectUncheckedCreateWithoutProfileInput> | StudentSubjectCreateWithoutProfileInput[] | StudentSubjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutProfileInput | StudentSubjectCreateOrConnectWithoutProfileInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutProfileInput | StudentSubjectUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentSubjectCreateManyProfileInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutProfileInput | StudentSubjectUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutProfileInput | StudentSubjectUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type FeaturedStudentUpdateOneWithoutStudentProfileNestedInput = {
    create?: XOR<FeaturedStudentCreateWithoutStudentProfileInput, FeaturedStudentUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: FeaturedStudentCreateOrConnectWithoutStudentProfileInput
    upsert?: FeaturedStudentUpsertWithoutStudentProfileInput
    disconnect?: FeaturedStudentWhereInput | boolean
    delete?: FeaturedStudentWhereInput | boolean
    connect?: FeaturedStudentWhereUniqueInput
    update?: XOR<XOR<FeaturedStudentUpdateToOneWithWhereWithoutStudentProfileInput, FeaturedStudentUpdateWithoutStudentProfileInput>, FeaturedStudentUncheckedUpdateWithoutStudentProfileInput>
  }

  export type TrainingReviewUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<TrainingReviewCreateWithoutStudentProfileInput, TrainingReviewUncheckedCreateWithoutStudentProfileInput> | TrainingReviewCreateWithoutStudentProfileInput[] | TrainingReviewUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutStudentProfileInput | TrainingReviewCreateOrConnectWithoutStudentProfileInput[]
    upsert?: TrainingReviewUpsertWithWhereUniqueWithoutStudentProfileInput | TrainingReviewUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: TrainingReviewCreateManyStudentProfileInputEnvelope
    set?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    disconnect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    delete?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    update?: TrainingReviewUpdateWithWhereUniqueWithoutStudentProfileInput | TrainingReviewUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: TrainingReviewUpdateManyWithWhereWithoutStudentProfileInput | TrainingReviewUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: TrainingReviewScalarWhereInput | TrainingReviewScalarWhereInput[]
  }

  export type StudentTrainingUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentTrainingCreateWithoutProfileInput, StudentTrainingUncheckedCreateWithoutProfileInput> | StudentTrainingCreateWithoutProfileInput[] | StudentTrainingUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTrainingCreateOrConnectWithoutProfileInput | StudentTrainingCreateOrConnectWithoutProfileInput[]
    upsert?: StudentTrainingUpsertWithWhereUniqueWithoutProfileInput | StudentTrainingUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentTrainingCreateManyProfileInputEnvelope
    set?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
    disconnect?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
    delete?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
    connect?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
    update?: StudentTrainingUpdateWithWhereUniqueWithoutProfileInput | StudentTrainingUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentTrainingUpdateManyWithWhereWithoutProfileInput | StudentTrainingUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentTrainingScalarWhereInput | StudentTrainingScalarWhereInput[]
  }

  export type StudentSkillUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentSkillCreateWithoutProfileInput, StudentSkillUncheckedCreateWithoutProfileInput> | StudentSkillCreateWithoutProfileInput[] | StudentSkillUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutProfileInput | StudentSkillCreateOrConnectWithoutProfileInput[]
    upsert?: StudentSkillUpsertWithWhereUniqueWithoutProfileInput | StudentSkillUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentSkillCreateManyProfileInputEnvelope
    set?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    disconnect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    delete?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    update?: StudentSkillUpdateWithWhereUniqueWithoutProfileInput | StudentSkillUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentSkillUpdateManyWithWhereWithoutProfileInput | StudentSkillUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
  }

  export type StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentBadgeCreateWithoutProfileInput, StudentBadgeUncheckedCreateWithoutProfileInput> | StudentBadgeCreateWithoutProfileInput[] | StudentBadgeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentBadgeCreateOrConnectWithoutProfileInput | StudentBadgeCreateOrConnectWithoutProfileInput[]
    upsert?: StudentBadgeUpsertWithWhereUniqueWithoutProfileInput | StudentBadgeUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentBadgeCreateManyProfileInputEnvelope
    set?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
    disconnect?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
    delete?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
    connect?: StudentBadgeWhereUniqueInput | StudentBadgeWhereUniqueInput[]
    update?: StudentBadgeUpdateWithWhereUniqueWithoutProfileInput | StudentBadgeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentBadgeUpdateManyWithWhereWithoutProfileInput | StudentBadgeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentBadgeScalarWhereInput | StudentBadgeScalarWhereInput[]
  }

  export type StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentTrainingEnrollmentCreateWithoutProfileInput, StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput> | StudentTrainingEnrollmentCreateWithoutProfileInput[] | StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput | StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput[]
    upsert?: StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutProfileInput | StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentTrainingEnrollmentCreateManyProfileInputEnvelope
    set?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    disconnect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    delete?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    connect?: StudentTrainingEnrollmentWhereUniqueInput | StudentTrainingEnrollmentWhereUniqueInput[]
    update?: StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutProfileInput | StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentTrainingEnrollmentUpdateManyWithWhereWithoutProfileInput | StudentTrainingEnrollmentUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentTrainingEnrollmentScalarWhereInput | StudentTrainingEnrollmentScalarWhereInput[]
  }

  export type StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentTestimonialCreateWithoutProfileInput, StudentTestimonialUncheckedCreateWithoutProfileInput> | StudentTestimonialCreateWithoutProfileInput[] | StudentTestimonialUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTestimonialCreateOrConnectWithoutProfileInput | StudentTestimonialCreateOrConnectWithoutProfileInput[]
    upsert?: StudentTestimonialUpsertWithWhereUniqueWithoutProfileInput | StudentTestimonialUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentTestimonialCreateManyProfileInputEnvelope
    set?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
    disconnect?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
    delete?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
    connect?: StudentTestimonialWhereUniqueInput | StudentTestimonialWhereUniqueInput[]
    update?: StudentTestimonialUpdateWithWhereUniqueWithoutProfileInput | StudentTestimonialUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentTestimonialUpdateManyWithWhereWithoutProfileInput | StudentTestimonialUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentTestimonialScalarWhereInput | StudentTestimonialScalarWhereInput[]
  }

  export type StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentSubjectCreateWithoutProfileInput, StudentSubjectUncheckedCreateWithoutProfileInput> | StudentSubjectCreateWithoutProfileInput[] | StudentSubjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentSubjectCreateOrConnectWithoutProfileInput | StudentSubjectCreateOrConnectWithoutProfileInput[]
    upsert?: StudentSubjectUpsertWithWhereUniqueWithoutProfileInput | StudentSubjectUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentSubjectCreateManyProfileInputEnvelope
    set?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    disconnect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    delete?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    connect?: StudentSubjectWhereUniqueInput | StudentSubjectWhereUniqueInput[]
    update?: StudentSubjectUpdateWithWhereUniqueWithoutProfileInput | StudentSubjectUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentSubjectUpdateManyWithWhereWithoutProfileInput | StudentSubjectUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
  }

  export type FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput = {
    create?: XOR<FeaturedStudentCreateWithoutStudentProfileInput, FeaturedStudentUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: FeaturedStudentCreateOrConnectWithoutStudentProfileInput
    upsert?: FeaturedStudentUpsertWithoutStudentProfileInput
    disconnect?: FeaturedStudentWhereInput | boolean
    delete?: FeaturedStudentWhereInput | boolean
    connect?: FeaturedStudentWhereUniqueInput
    update?: XOR<XOR<FeaturedStudentUpdateToOneWithWhereWithoutStudentProfileInput, FeaturedStudentUpdateWithoutStudentProfileInput>, FeaturedStudentUncheckedUpdateWithoutStudentProfileInput>
  }

  export type TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput = {
    create?: XOR<TrainingReviewCreateWithoutStudentProfileInput, TrainingReviewUncheckedCreateWithoutStudentProfileInput> | TrainingReviewCreateWithoutStudentProfileInput[] | TrainingReviewUncheckedCreateWithoutStudentProfileInput[]
    connectOrCreate?: TrainingReviewCreateOrConnectWithoutStudentProfileInput | TrainingReviewCreateOrConnectWithoutStudentProfileInput[]
    upsert?: TrainingReviewUpsertWithWhereUniqueWithoutStudentProfileInput | TrainingReviewUpsertWithWhereUniqueWithoutStudentProfileInput[]
    createMany?: TrainingReviewCreateManyStudentProfileInputEnvelope
    set?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    disconnect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    delete?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    connect?: TrainingReviewWhereUniqueInput | TrainingReviewWhereUniqueInput[]
    update?: TrainingReviewUpdateWithWhereUniqueWithoutStudentProfileInput | TrainingReviewUpdateWithWhereUniqueWithoutStudentProfileInput[]
    updateMany?: TrainingReviewUpdateManyWithWhereWithoutStudentProfileInput | TrainingReviewUpdateManyWithWhereWithoutStudentProfileInput[]
    deleteMany?: TrainingReviewScalarWhereInput | TrainingReviewScalarWhereInput[]
  }

  export type StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<StudentTrainingCreateWithoutProfileInput, StudentTrainingUncheckedCreateWithoutProfileInput> | StudentTrainingCreateWithoutProfileInput[] | StudentTrainingUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: StudentTrainingCreateOrConnectWithoutProfileInput | StudentTrainingCreateOrConnectWithoutProfileInput[]
    upsert?: StudentTrainingUpsertWithWhereUniqueWithoutProfileInput | StudentTrainingUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: StudentTrainingCreateManyProfileInputEnvelope
    set?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
    disconnect?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
    delete?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
    connect?: StudentTrainingWhereUniqueInput | StudentTrainingWhereUniqueInput[]
    update?: StudentTrainingUpdateWithWhereUniqueWithoutProfileInput | StudentTrainingUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: StudentTrainingUpdateManyWithWhereWithoutProfileInput | StudentTrainingUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: StudentTrainingScalarWhereInput | StudentTrainingScalarWhereInput[]
  }

  export type StudentProfileCreateNestedOneWithoutSkillsInput = {
    create?: XOR<StudentProfileCreateWithoutSkillsInput, StudentProfileUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutSkillsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type StudentProfileUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutSkillsInput, StudentProfileUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutSkillsInput
    upsert?: StudentProfileUpsertWithoutSkillsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutSkillsInput, StudentProfileUpdateWithoutSkillsInput>, StudentProfileUncheckedUpdateWithoutSkillsInput>
  }

  export type StudentProfileCreateNestedOneWithoutBadgesInput = {
    create?: XOR<StudentProfileCreateWithoutBadgesInput, StudentProfileUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutBadgesInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type StudentProfileUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<StudentProfileCreateWithoutBadgesInput, StudentProfileUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutBadgesInput
    upsert?: StudentProfileUpsertWithoutBadgesInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutBadgesInput, StudentProfileUpdateWithoutBadgesInput>, StudentProfileUncheckedUpdateWithoutBadgesInput>
  }

  export type StudentProfileCreateNestedOneWithoutStudentTrainingInput = {
    create?: XOR<StudentProfileCreateWithoutStudentTrainingInput, StudentProfileUncheckedCreateWithoutStudentTrainingInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutStudentTrainingInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type StudentProfileUpdateOneRequiredWithoutStudentTrainingNestedInput = {
    create?: XOR<StudentProfileCreateWithoutStudentTrainingInput, StudentProfileUncheckedCreateWithoutStudentTrainingInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutStudentTrainingInput
    upsert?: StudentProfileUpsertWithoutStudentTrainingInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutStudentTrainingInput, StudentProfileUpdateWithoutStudentTrainingInput>, StudentProfileUncheckedUpdateWithoutStudentTrainingInput>
  }

  export type StudentProfileCreateNestedOneWithoutTestimonialsInput = {
    create?: XOR<StudentProfileCreateWithoutTestimonialsInput, StudentProfileUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTestimonialsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type StudentProfileUpdateOneRequiredWithoutTestimonialsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutTestimonialsInput, StudentProfileUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTestimonialsInput
    upsert?: StudentProfileUpsertWithoutTestimonialsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutTestimonialsInput, StudentProfileUpdateWithoutTestimonialsInput>, StudentProfileUncheckedUpdateWithoutTestimonialsInput>
  }

  export type StudentProfileCreateNestedOneWithoutAcademicSubjectsInput = {
    create?: XOR<StudentProfileCreateWithoutAcademicSubjectsInput, StudentProfileUncheckedCreateWithoutAcademicSubjectsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutAcademicSubjectsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type StudentProfileUpdateOneRequiredWithoutAcademicSubjectsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutAcademicSubjectsInput, StudentProfileUncheckedCreateWithoutAcademicSubjectsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutAcademicSubjectsInput
    upsert?: StudentProfileUpsertWithoutAcademicSubjectsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutAcademicSubjectsInput, StudentProfileUpdateWithoutAcademicSubjectsInput>, StudentProfileUncheckedUpdateWithoutAcademicSubjectsInput>
  }

  export type TrainingCreateNestedOneWithoutReviewsInput = {
    create?: XOR<TrainingCreateWithoutReviewsInput, TrainingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutReviewsInput
    connect?: TrainingWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutTrainingReviewsInput = {
    create?: XOR<StudentProfileCreateWithoutTrainingReviewsInput, StudentProfileUncheckedCreateWithoutTrainingReviewsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTrainingReviewsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type FeaturedStudentCreateNestedOneWithoutTrainingReviewsInput = {
    create?: XOR<FeaturedStudentCreateWithoutTrainingReviewsInput, FeaturedStudentUncheckedCreateWithoutTrainingReviewsInput>
    connectOrCreate?: FeaturedStudentCreateOrConnectWithoutTrainingReviewsInput
    connect?: FeaturedStudentWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<TrainingCreateWithoutReviewsInput, TrainingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutReviewsInput
    upsert?: TrainingUpsertWithoutReviewsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutReviewsInput, TrainingUpdateWithoutReviewsInput>, TrainingUncheckedUpdateWithoutReviewsInput>
  }

  export type StudentProfileUpdateOneRequiredWithoutTrainingReviewsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutTrainingReviewsInput, StudentProfileUncheckedCreateWithoutTrainingReviewsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTrainingReviewsInput
    upsert?: StudentProfileUpsertWithoutTrainingReviewsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutTrainingReviewsInput, StudentProfileUpdateWithoutTrainingReviewsInput>, StudentProfileUncheckedUpdateWithoutTrainingReviewsInput>
  }

  export type FeaturedStudentUpdateOneWithoutTrainingReviewsNestedInput = {
    create?: XOR<FeaturedStudentCreateWithoutTrainingReviewsInput, FeaturedStudentUncheckedCreateWithoutTrainingReviewsInput>
    connectOrCreate?: FeaturedStudentCreateOrConnectWithoutTrainingReviewsInput
    upsert?: FeaturedStudentUpsertWithoutTrainingReviewsInput
    disconnect?: FeaturedStudentWhereInput | boolean
    delete?: FeaturedStudentWhereInput | boolean
    connect?: FeaturedStudentWhereUniqueInput
    update?: XOR<XOR<FeaturedStudentUpdateToOneWithWhereWithoutTrainingReviewsInput, FeaturedStudentUpdateWithoutTrainingReviewsInput>, FeaturedStudentUncheckedUpdateWithoutTrainingReviewsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTrainingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeFilter<$PrismaModel> | $Enums.TrainingType
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrainingTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type NestedEnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumTeamMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberRole | EnumTeamMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberRoleFilter<$PrismaModel> | $Enums.TeamMemberRole
  }

  export type NestedEnumTeamMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberRole | EnumTeamMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumCourseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeFilter<$PrismaModel> | $Enums.CourseType
  }

  export type NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTypeFilter<$PrismaModel>
    _max?: NestedEnumCourseTypeFilter<$PrismaModel>
  }

  export type NestedEnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ApplicationCreateWithoutUserInput = {
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    createdAt?: Date | string
    type: $Enums.TrainingType
  }

  export type ApplicationUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    createdAt?: Date | string
    type: $Enums.TrainingType
  }

  export type ApplicationCreateOrConnectWithoutUserInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
  }

  export type ApplicationCreateManyUserInputEnvelope = {
    data: ApplicationCreateManyUserInput | ApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentProfileCreateWithoutUserInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutUserInput = {
    id?: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutUserInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
  }

  export type ApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutUserInput, ApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<ApplicationCreateWithoutUserInput, ApplicationUncheckedCreateWithoutUserInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutUserInput, ApplicationUncheckedUpdateWithoutUserInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutUserInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    id?: IntFilter<"Application"> | number
    userId?: IntNullableFilter<"Application"> | number | null
    name?: StringFilter<"Application"> | string
    surname?: StringFilter<"Application"> | string
    email?: StringFilter<"Application"> | string
    phoneNumber?: StringNullableFilter<"Application"> | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    type?: EnumTrainingTypeFilter<"Application"> | $Enums.TrainingType
  }

  export type StudentProfileUpsertWithoutUserInput = {
    update: XOR<StudentProfileUpdateWithoutUserInput, StudentProfileUncheckedUpdateWithoutUserInput>
    create: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutUserInput, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentProfileUpdateWithoutUserInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type NewsCreateWithoutImagesInput = {
    title: string
    content: string
    createdAt?: Date | string
    imageUrl?: string | null
  }

  export type NewsUncheckedCreateWithoutImagesInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    imageUrl?: string | null
  }

  export type NewsCreateOrConnectWithoutImagesInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutImagesInput, NewsUncheckedCreateWithoutImagesInput>
  }

  export type NewsUpsertWithoutImagesInput = {
    update: XOR<NewsUpdateWithoutImagesInput, NewsUncheckedUpdateWithoutImagesInput>
    create: XOR<NewsCreateWithoutImagesInput, NewsUncheckedCreateWithoutImagesInput>
    where?: NewsWhereInput
  }

  export type NewsUpdateToOneWithWhereWithoutImagesInput = {
    where?: NewsWhereInput
    data: XOR<NewsUpdateWithoutImagesInput, NewsUncheckedUpdateWithoutImagesInput>
  }

  export type NewsUpdateWithoutImagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewsUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewsImageCreateWithoutNewsInput = {
    url: string
    socialUrl?: string | null
    mobileSocialUrl?: string | null
    desktopSocialUrl?: string | null
    isMain?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type NewsImageUncheckedCreateWithoutNewsInput = {
    id?: number
    url: string
    socialUrl?: string | null
    mobileSocialUrl?: string | null
    desktopSocialUrl?: string | null
    isMain?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type NewsImageCreateOrConnectWithoutNewsInput = {
    where: NewsImageWhereUniqueInput
    create: XOR<NewsImageCreateWithoutNewsInput, NewsImageUncheckedCreateWithoutNewsInput>
  }

  export type NewsImageCreateManyNewsInputEnvelope = {
    data: NewsImageCreateManyNewsInput | NewsImageCreateManyNewsInput[]
    skipDuplicates?: boolean
  }

  export type NewsImageUpsertWithWhereUniqueWithoutNewsInput = {
    where: NewsImageWhereUniqueInput
    update: XOR<NewsImageUpdateWithoutNewsInput, NewsImageUncheckedUpdateWithoutNewsInput>
    create: XOR<NewsImageCreateWithoutNewsInput, NewsImageUncheckedCreateWithoutNewsInput>
  }

  export type NewsImageUpdateWithWhereUniqueWithoutNewsInput = {
    where: NewsImageWhereUniqueInput
    data: XOR<NewsImageUpdateWithoutNewsInput, NewsImageUncheckedUpdateWithoutNewsInput>
  }

  export type NewsImageUpdateManyWithWhereWithoutNewsInput = {
    where: NewsImageScalarWhereInput
    data: XOR<NewsImageUpdateManyMutationInput, NewsImageUncheckedUpdateManyWithoutNewsInput>
  }

  export type NewsImageScalarWhereInput = {
    AND?: NewsImageScalarWhereInput | NewsImageScalarWhereInput[]
    OR?: NewsImageScalarWhereInput[]
    NOT?: NewsImageScalarWhereInput | NewsImageScalarWhereInput[]
    id?: IntFilter<"NewsImage"> | number
    url?: StringFilter<"NewsImage"> | string
    socialUrl?: StringNullableFilter<"NewsImage"> | string | null
    mobileSocialUrl?: StringNullableFilter<"NewsImage"> | string | null
    desktopSocialUrl?: StringNullableFilter<"NewsImage"> | string | null
    isMain?: BoolFilter<"NewsImage"> | boolean
    order?: IntFilter<"NewsImage"> | number
    newsId?: IntFilter<"NewsImage"> | number
    createdAt?: DateTimeFilter<"NewsImage"> | Date | string
  }

  export type UserCreateWithoutApplicationsInput = {
    name: string
    surname: string
    email: string
    password: string
    role?: $Enums.UserRole
    isStudent?: boolean
    createdAt?: Date | string
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApplicationsInput = {
    id?: number
    name: string
    surname: string
    email: string
    password: string
    role?: $Enums.UserRole
    isStudent?: boolean
    createdAt?: Date | string
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
  }

  export type UserUpsertWithoutApplicationsInput = {
    update: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateWithoutApplicationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type StudentProfileCreateWithoutFeaturedStudentInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutFeaturedStudentInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutFeaturedStudentInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutFeaturedStudentInput, StudentProfileUncheckedCreateWithoutFeaturedStudentInput>
  }

  export type TrainingReviewCreateWithoutFeaturedStudentInput = {
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutReviewsInput
    studentProfile: StudentProfileCreateNestedOneWithoutTrainingReviewsInput
  }

  export type TrainingReviewUncheckedCreateWithoutFeaturedStudentInput = {
    id?: number
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId: number
    studentProfileId: number
  }

  export type TrainingReviewCreateOrConnectWithoutFeaturedStudentInput = {
    where: TrainingReviewWhereUniqueInput
    create: XOR<TrainingReviewCreateWithoutFeaturedStudentInput, TrainingReviewUncheckedCreateWithoutFeaturedStudentInput>
  }

  export type TrainingReviewCreateManyFeaturedStudentInputEnvelope = {
    data: TrainingReviewCreateManyFeaturedStudentInput | TrainingReviewCreateManyFeaturedStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentProfileUpsertWithoutFeaturedStudentInput = {
    update: XOR<StudentProfileUpdateWithoutFeaturedStudentInput, StudentProfileUncheckedUpdateWithoutFeaturedStudentInput>
    create: XOR<StudentProfileCreateWithoutFeaturedStudentInput, StudentProfileUncheckedCreateWithoutFeaturedStudentInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutFeaturedStudentInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutFeaturedStudentInput, StudentProfileUncheckedUpdateWithoutFeaturedStudentInput>
  }

  export type StudentProfileUpdateWithoutFeaturedStudentInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutFeaturedStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type TrainingReviewUpsertWithWhereUniqueWithoutFeaturedStudentInput = {
    where: TrainingReviewWhereUniqueInput
    update: XOR<TrainingReviewUpdateWithoutFeaturedStudentInput, TrainingReviewUncheckedUpdateWithoutFeaturedStudentInput>
    create: XOR<TrainingReviewCreateWithoutFeaturedStudentInput, TrainingReviewUncheckedCreateWithoutFeaturedStudentInput>
  }

  export type TrainingReviewUpdateWithWhereUniqueWithoutFeaturedStudentInput = {
    where: TrainingReviewWhereUniqueInput
    data: XOR<TrainingReviewUpdateWithoutFeaturedStudentInput, TrainingReviewUncheckedUpdateWithoutFeaturedStudentInput>
  }

  export type TrainingReviewUpdateManyWithWhereWithoutFeaturedStudentInput = {
    where: TrainingReviewScalarWhereInput
    data: XOR<TrainingReviewUpdateManyMutationInput, TrainingReviewUncheckedUpdateManyWithoutFeaturedStudentInput>
  }

  export type TrainingReviewScalarWhereInput = {
    AND?: TrainingReviewScalarWhereInput | TrainingReviewScalarWhereInput[]
    OR?: TrainingReviewScalarWhereInput[]
    NOT?: TrainingReviewScalarWhereInput | TrainingReviewScalarWhereInput[]
    id?: IntFilter<"TrainingReview"> | number
    content?: StringFilter<"TrainingReview"> | string
    rating?: IntFilter<"TrainingReview"> | number
    createdAt?: DateTimeFilter<"TrainingReview"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingReview"> | Date | string
    trainingId?: IntFilter<"TrainingReview"> | number
    studentProfileId?: IntFilter<"TrainingReview"> | number
    featuredStudentId?: IntNullableFilter<"TrainingReview"> | number | null
  }

  export type StudentTrainingEnrollmentCreateWithoutTrainingInput = {
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: StudentProfileCreateNestedOneWithoutTrainingsInput
  }

  export type StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput = {
    id?: number
    profileId: number
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTrainingEnrollmentCreateOrConnectWithoutTrainingInput = {
    where: StudentTrainingEnrollmentWhereUniqueInput
    create: XOR<StudentTrainingEnrollmentCreateWithoutTrainingInput, StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput>
  }

  export type StudentTrainingEnrollmentCreateManyTrainingInputEnvelope = {
    data: StudentTrainingEnrollmentCreateManyTrainingInput | StudentTrainingEnrollmentCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingReviewCreateWithoutTrainingInput = {
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile: StudentProfileCreateNestedOneWithoutTrainingReviewsInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutTrainingReviewsInput
  }

  export type TrainingReviewUncheckedCreateWithoutTrainingInput = {
    id?: number
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfileId: number
    featuredStudentId?: number | null
  }

  export type TrainingReviewCreateOrConnectWithoutTrainingInput = {
    where: TrainingReviewWhereUniqueInput
    create: XOR<TrainingReviewCreateWithoutTrainingInput, TrainingReviewUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingReviewCreateManyTrainingInputEnvelope = {
    data: TrainingReviewCreateManyTrainingInput | TrainingReviewCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutTrainingInput = {
    where: StudentTrainingEnrollmentWhereUniqueInput
    update: XOR<StudentTrainingEnrollmentUpdateWithoutTrainingInput, StudentTrainingEnrollmentUncheckedUpdateWithoutTrainingInput>
    create: XOR<StudentTrainingEnrollmentCreateWithoutTrainingInput, StudentTrainingEnrollmentUncheckedCreateWithoutTrainingInput>
  }

  export type StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutTrainingInput = {
    where: StudentTrainingEnrollmentWhereUniqueInput
    data: XOR<StudentTrainingEnrollmentUpdateWithoutTrainingInput, StudentTrainingEnrollmentUncheckedUpdateWithoutTrainingInput>
  }

  export type StudentTrainingEnrollmentUpdateManyWithWhereWithoutTrainingInput = {
    where: StudentTrainingEnrollmentScalarWhereInput
    data: XOR<StudentTrainingEnrollmentUpdateManyMutationInput, StudentTrainingEnrollmentUncheckedUpdateManyWithoutTrainingInput>
  }

  export type StudentTrainingEnrollmentScalarWhereInput = {
    AND?: StudentTrainingEnrollmentScalarWhereInput | StudentTrainingEnrollmentScalarWhereInput[]
    OR?: StudentTrainingEnrollmentScalarWhereInput[]
    NOT?: StudentTrainingEnrollmentScalarWhereInput | StudentTrainingEnrollmentScalarWhereInput[]
    id?: IntFilter<"StudentTrainingEnrollment"> | number
    trainingId?: IntFilter<"StudentTrainingEnrollment"> | number
    profileId?: IntFilter<"StudentTrainingEnrollment"> | number
    enrollmentDate?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
    status?: EnumTrainingStatusFilter<"StudentTrainingEnrollment"> | $Enums.TrainingStatus
    progress?: IntFilter<"StudentTrainingEnrollment"> | number
    completionDate?: DateTimeNullableFilter<"StudentTrainingEnrollment"> | Date | string | null
    certificateUrl?: StringNullableFilter<"StudentTrainingEnrollment"> | string | null
    attendance?: IntFilter<"StudentTrainingEnrollment"> | number
    grade?: FloatNullableFilter<"StudentTrainingEnrollment"> | number | null
    feedback?: StringNullableFilter<"StudentTrainingEnrollment"> | string | null
    createdAt?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTrainingEnrollment"> | Date | string
  }

  export type TrainingReviewUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingReviewWhereUniqueInput
    update: XOR<TrainingReviewUpdateWithoutTrainingInput, TrainingReviewUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingReviewCreateWithoutTrainingInput, TrainingReviewUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingReviewUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingReviewWhereUniqueInput
    data: XOR<TrainingReviewUpdateWithoutTrainingInput, TrainingReviewUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingReviewUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingReviewScalarWhereInput
    data: XOR<TrainingReviewUpdateManyMutationInput, TrainingReviewUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingCreateWithoutEnrollmentsInput = {
    title: string
    description?: string | null
    category: string
    level: string
    instructor: string
    totalHours: number
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: TrainingReviewCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    title: string
    description?: string | null
    category: string
    level: string
    instructor: string
    totalHours: number
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: TrainingReviewUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutEnrollmentsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutEnrollmentsInput, TrainingUncheckedCreateWithoutEnrollmentsInput>
  }

  export type StudentProfileCreateWithoutTrainingsInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutTrainingsInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutTrainingsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutTrainingsInput, StudentProfileUncheckedCreateWithoutTrainingsInput>
  }

  export type TrainingUpsertWithoutEnrollmentsInput = {
    update: XOR<TrainingUpdateWithoutEnrollmentsInput, TrainingUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<TrainingCreateWithoutEnrollmentsInput, TrainingUncheckedCreateWithoutEnrollmentsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutEnrollmentsInput, TrainingUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type TrainingUpdateWithoutEnrollmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: TrainingReviewUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: TrainingReviewUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type StudentProfileUpsertWithoutTrainingsInput = {
    update: XOR<StudentProfileUpdateWithoutTrainingsInput, StudentProfileUncheckedUpdateWithoutTrainingsInput>
    create: XOR<StudentProfileCreateWithoutTrainingsInput, StudentProfileUncheckedCreateWithoutTrainingsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutTrainingsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutTrainingsInput, StudentProfileUncheckedUpdateWithoutTrainingsInput>
  }

  export type StudentProfileUpdateWithoutTrainingsInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutTrainingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserCreateWithoutStudentProfileInput = {
    name: string
    surname: string
    email: string
    password: string
    role?: $Enums.UserRole
    isStudent?: boolean
    createdAt?: Date | string
    applications?: ApplicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    name: string
    surname: string
    email: string
    password: string
    role?: $Enums.UserRole
    isStudent?: boolean
    createdAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
  }

  export type StudentSkillCreateWithoutProfileInput = {
    name: string
    level: number
  }

  export type StudentSkillUncheckedCreateWithoutProfileInput = {
    id?: number
    name: string
    level: number
  }

  export type StudentSkillCreateOrConnectWithoutProfileInput = {
    where: StudentSkillWhereUniqueInput
    create: XOR<StudentSkillCreateWithoutProfileInput, StudentSkillUncheckedCreateWithoutProfileInput>
  }

  export type StudentSkillCreateManyProfileInputEnvelope = {
    data: StudentSkillCreateManyProfileInput | StudentSkillCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type StudentBadgeCreateWithoutProfileInput = {
    name: string
    type: string
    date: Date | string
  }

  export type StudentBadgeUncheckedCreateWithoutProfileInput = {
    id?: number
    name: string
    type: string
    date: Date | string
  }

  export type StudentBadgeCreateOrConnectWithoutProfileInput = {
    where: StudentBadgeWhereUniqueInput
    create: XOR<StudentBadgeCreateWithoutProfileInput, StudentBadgeUncheckedCreateWithoutProfileInput>
  }

  export type StudentBadgeCreateManyProfileInputEnvelope = {
    data: StudentBadgeCreateManyProfileInput | StudentBadgeCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type StudentTrainingEnrollmentCreateWithoutProfileInput = {
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutEnrollmentsInput
  }

  export type StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput = {
    id?: number
    trainingId: number
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTrainingEnrollmentCreateOrConnectWithoutProfileInput = {
    where: StudentTrainingEnrollmentWhereUniqueInput
    create: XOR<StudentTrainingEnrollmentCreateWithoutProfileInput, StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput>
  }

  export type StudentTrainingEnrollmentCreateManyProfileInputEnvelope = {
    data: StudentTrainingEnrollmentCreateManyProfileInput | StudentTrainingEnrollmentCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type StudentTestimonialCreateWithoutProfileInput = {
    author: string
    role: string
    content: string
    rating: number
    date?: Date | string
  }

  export type StudentTestimonialUncheckedCreateWithoutProfileInput = {
    id?: number
    author: string
    role: string
    content: string
    rating: number
    date?: Date | string
  }

  export type StudentTestimonialCreateOrConnectWithoutProfileInput = {
    where: StudentTestimonialWhereUniqueInput
    create: XOR<StudentTestimonialCreateWithoutProfileInput, StudentTestimonialUncheckedCreateWithoutProfileInput>
  }

  export type StudentTestimonialCreateManyProfileInputEnvelope = {
    data: StudentTestimonialCreateManyProfileInput | StudentTestimonialCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type StudentSubjectCreateWithoutProfileInput = {
    name: string
    grade: string
    credits: number
    semester: string
  }

  export type StudentSubjectUncheckedCreateWithoutProfileInput = {
    id?: number
    name: string
    grade: string
    credits: number
    semester: string
  }

  export type StudentSubjectCreateOrConnectWithoutProfileInput = {
    where: StudentSubjectWhereUniqueInput
    create: XOR<StudentSubjectCreateWithoutProfileInput, StudentSubjectUncheckedCreateWithoutProfileInput>
  }

  export type StudentSubjectCreateManyProfileInputEnvelope = {
    data: StudentSubjectCreateManyProfileInput | StudentSubjectCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type FeaturedStudentCreateWithoutStudentProfileInput = {
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    courseType: $Enums.CourseType
    score: number
    imagePath?: string | null
    description: string
    achievements?: FeaturedStudentCreateachievementsInput | string[]
    graduationDate: Date | string
    isActive?: boolean
    linkedinUrl?: string | null
    testimonial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingReviews?: TrainingReviewCreateNestedManyWithoutFeaturedStudentInput
  }

  export type FeaturedStudentUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    courseType: $Enums.CourseType
    score: number
    imagePath?: string | null
    description: string
    achievements?: FeaturedStudentCreateachievementsInput | string[]
    graduationDate: Date | string
    isActive?: boolean
    linkedinUrl?: string | null
    testimonial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutFeaturedStudentInput
  }

  export type FeaturedStudentCreateOrConnectWithoutStudentProfileInput = {
    where: FeaturedStudentWhereUniqueInput
    create: XOR<FeaturedStudentCreateWithoutStudentProfileInput, FeaturedStudentUncheckedCreateWithoutStudentProfileInput>
  }

  export type TrainingReviewCreateWithoutStudentProfileInput = {
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutReviewsInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutTrainingReviewsInput
  }

  export type TrainingReviewUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId: number
    featuredStudentId?: number | null
  }

  export type TrainingReviewCreateOrConnectWithoutStudentProfileInput = {
    where: TrainingReviewWhereUniqueInput
    create: XOR<TrainingReviewCreateWithoutStudentProfileInput, TrainingReviewUncheckedCreateWithoutStudentProfileInput>
  }

  export type TrainingReviewCreateManyStudentProfileInputEnvelope = {
    data: TrainingReviewCreateManyStudentProfileInput | TrainingReviewCreateManyStudentProfileInput[]
    skipDuplicates?: boolean
  }

  export type StudentTrainingCreateWithoutProfileInput = {
    title: string
    category: string
    level: string
    instructor: string
    hours?: number | null
    completionDate?: Date | string | null
    startDate?: Date | string | null
    status: string
    progress?: number | null
    certificate?: boolean
  }

  export type StudentTrainingUncheckedCreateWithoutProfileInput = {
    id?: number
    title: string
    category: string
    level: string
    instructor: string
    hours?: number | null
    completionDate?: Date | string | null
    startDate?: Date | string | null
    status: string
    progress?: number | null
    certificate?: boolean
  }

  export type StudentTrainingCreateOrConnectWithoutProfileInput = {
    where: StudentTrainingWhereUniqueInput
    create: XOR<StudentTrainingCreateWithoutProfileInput, StudentTrainingUncheckedCreateWithoutProfileInput>
  }

  export type StudentTrainingCreateManyProfileInputEnvelope = {
    data: StudentTrainingCreateManyProfileInput | StudentTrainingCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentProfileInput = {
    update: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type UserUpdateWithoutStudentProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentSkillUpsertWithWhereUniqueWithoutProfileInput = {
    where: StudentSkillWhereUniqueInput
    update: XOR<StudentSkillUpdateWithoutProfileInput, StudentSkillUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentSkillCreateWithoutProfileInput, StudentSkillUncheckedCreateWithoutProfileInput>
  }

  export type StudentSkillUpdateWithWhereUniqueWithoutProfileInput = {
    where: StudentSkillWhereUniqueInput
    data: XOR<StudentSkillUpdateWithoutProfileInput, StudentSkillUncheckedUpdateWithoutProfileInput>
  }

  export type StudentSkillUpdateManyWithWhereWithoutProfileInput = {
    where: StudentSkillScalarWhereInput
    data: XOR<StudentSkillUpdateManyMutationInput, StudentSkillUncheckedUpdateManyWithoutProfileInput>
  }

  export type StudentSkillScalarWhereInput = {
    AND?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
    OR?: StudentSkillScalarWhereInput[]
    NOT?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
    id?: IntFilter<"StudentSkill"> | number
    name?: StringFilter<"StudentSkill"> | string
    level?: IntFilter<"StudentSkill"> | number
    profileId?: IntFilter<"StudentSkill"> | number
  }

  export type StudentBadgeUpsertWithWhereUniqueWithoutProfileInput = {
    where: StudentBadgeWhereUniqueInput
    update: XOR<StudentBadgeUpdateWithoutProfileInput, StudentBadgeUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentBadgeCreateWithoutProfileInput, StudentBadgeUncheckedCreateWithoutProfileInput>
  }

  export type StudentBadgeUpdateWithWhereUniqueWithoutProfileInput = {
    where: StudentBadgeWhereUniqueInput
    data: XOR<StudentBadgeUpdateWithoutProfileInput, StudentBadgeUncheckedUpdateWithoutProfileInput>
  }

  export type StudentBadgeUpdateManyWithWhereWithoutProfileInput = {
    where: StudentBadgeScalarWhereInput
    data: XOR<StudentBadgeUpdateManyMutationInput, StudentBadgeUncheckedUpdateManyWithoutProfileInput>
  }

  export type StudentBadgeScalarWhereInput = {
    AND?: StudentBadgeScalarWhereInput | StudentBadgeScalarWhereInput[]
    OR?: StudentBadgeScalarWhereInput[]
    NOT?: StudentBadgeScalarWhereInput | StudentBadgeScalarWhereInput[]
    id?: IntFilter<"StudentBadge"> | number
    name?: StringFilter<"StudentBadge"> | string
    type?: StringFilter<"StudentBadge"> | string
    date?: DateTimeFilter<"StudentBadge"> | Date | string
    profileId?: IntFilter<"StudentBadge"> | number
  }

  export type StudentTrainingEnrollmentUpsertWithWhereUniqueWithoutProfileInput = {
    where: StudentTrainingEnrollmentWhereUniqueInput
    update: XOR<StudentTrainingEnrollmentUpdateWithoutProfileInput, StudentTrainingEnrollmentUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentTrainingEnrollmentCreateWithoutProfileInput, StudentTrainingEnrollmentUncheckedCreateWithoutProfileInput>
  }

  export type StudentTrainingEnrollmentUpdateWithWhereUniqueWithoutProfileInput = {
    where: StudentTrainingEnrollmentWhereUniqueInput
    data: XOR<StudentTrainingEnrollmentUpdateWithoutProfileInput, StudentTrainingEnrollmentUncheckedUpdateWithoutProfileInput>
  }

  export type StudentTrainingEnrollmentUpdateManyWithWhereWithoutProfileInput = {
    where: StudentTrainingEnrollmentScalarWhereInput
    data: XOR<StudentTrainingEnrollmentUpdateManyMutationInput, StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileInput>
  }

  export type StudentTestimonialUpsertWithWhereUniqueWithoutProfileInput = {
    where: StudentTestimonialWhereUniqueInput
    update: XOR<StudentTestimonialUpdateWithoutProfileInput, StudentTestimonialUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentTestimonialCreateWithoutProfileInput, StudentTestimonialUncheckedCreateWithoutProfileInput>
  }

  export type StudentTestimonialUpdateWithWhereUniqueWithoutProfileInput = {
    where: StudentTestimonialWhereUniqueInput
    data: XOR<StudentTestimonialUpdateWithoutProfileInput, StudentTestimonialUncheckedUpdateWithoutProfileInput>
  }

  export type StudentTestimonialUpdateManyWithWhereWithoutProfileInput = {
    where: StudentTestimonialScalarWhereInput
    data: XOR<StudentTestimonialUpdateManyMutationInput, StudentTestimonialUncheckedUpdateManyWithoutProfileInput>
  }

  export type StudentTestimonialScalarWhereInput = {
    AND?: StudentTestimonialScalarWhereInput | StudentTestimonialScalarWhereInput[]
    OR?: StudentTestimonialScalarWhereInput[]
    NOT?: StudentTestimonialScalarWhereInput | StudentTestimonialScalarWhereInput[]
    id?: IntFilter<"StudentTestimonial"> | number
    author?: StringFilter<"StudentTestimonial"> | string
    role?: StringFilter<"StudentTestimonial"> | string
    content?: StringFilter<"StudentTestimonial"> | string
    rating?: IntFilter<"StudentTestimonial"> | number
    date?: DateTimeFilter<"StudentTestimonial"> | Date | string
    profileId?: IntFilter<"StudentTestimonial"> | number
  }

  export type StudentSubjectUpsertWithWhereUniqueWithoutProfileInput = {
    where: StudentSubjectWhereUniqueInput
    update: XOR<StudentSubjectUpdateWithoutProfileInput, StudentSubjectUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentSubjectCreateWithoutProfileInput, StudentSubjectUncheckedCreateWithoutProfileInput>
  }

  export type StudentSubjectUpdateWithWhereUniqueWithoutProfileInput = {
    where: StudentSubjectWhereUniqueInput
    data: XOR<StudentSubjectUpdateWithoutProfileInput, StudentSubjectUncheckedUpdateWithoutProfileInput>
  }

  export type StudentSubjectUpdateManyWithWhereWithoutProfileInput = {
    where: StudentSubjectScalarWhereInput
    data: XOR<StudentSubjectUpdateManyMutationInput, StudentSubjectUncheckedUpdateManyWithoutProfileInput>
  }

  export type StudentSubjectScalarWhereInput = {
    AND?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
    OR?: StudentSubjectScalarWhereInput[]
    NOT?: StudentSubjectScalarWhereInput | StudentSubjectScalarWhereInput[]
    id?: IntFilter<"StudentSubject"> | number
    name?: StringFilter<"StudentSubject"> | string
    grade?: StringFilter<"StudentSubject"> | string
    credits?: IntFilter<"StudentSubject"> | number
    semester?: StringFilter<"StudentSubject"> | string
    profileId?: IntFilter<"StudentSubject"> | number
  }

  export type FeaturedStudentUpsertWithoutStudentProfileInput = {
    update: XOR<FeaturedStudentUpdateWithoutStudentProfileInput, FeaturedStudentUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<FeaturedStudentCreateWithoutStudentProfileInput, FeaturedStudentUncheckedCreateWithoutStudentProfileInput>
    where?: FeaturedStudentWhereInput
  }

  export type FeaturedStudentUpdateToOneWithWhereWithoutStudentProfileInput = {
    where?: FeaturedStudentWhereInput
    data: XOR<FeaturedStudentUpdateWithoutStudentProfileInput, FeaturedStudentUncheckedUpdateWithoutStudentProfileInput>
  }

  export type FeaturedStudentUpdateWithoutStudentProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    score?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    achievements?: FeaturedStudentUpdateachievementsInput | string[]
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingReviews?: TrainingReviewUpdateManyWithoutFeaturedStudentNestedInput
  }

  export type FeaturedStudentUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    score?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    achievements?: FeaturedStudentUpdateachievementsInput | string[]
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutFeaturedStudentNestedInput
  }

  export type TrainingReviewUpsertWithWhereUniqueWithoutStudentProfileInput = {
    where: TrainingReviewWhereUniqueInput
    update: XOR<TrainingReviewUpdateWithoutStudentProfileInput, TrainingReviewUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<TrainingReviewCreateWithoutStudentProfileInput, TrainingReviewUncheckedCreateWithoutStudentProfileInput>
  }

  export type TrainingReviewUpdateWithWhereUniqueWithoutStudentProfileInput = {
    where: TrainingReviewWhereUniqueInput
    data: XOR<TrainingReviewUpdateWithoutStudentProfileInput, TrainingReviewUncheckedUpdateWithoutStudentProfileInput>
  }

  export type TrainingReviewUpdateManyWithWhereWithoutStudentProfileInput = {
    where: TrainingReviewScalarWhereInput
    data: XOR<TrainingReviewUpdateManyMutationInput, TrainingReviewUncheckedUpdateManyWithoutStudentProfileInput>
  }

  export type StudentTrainingUpsertWithWhereUniqueWithoutProfileInput = {
    where: StudentTrainingWhereUniqueInput
    update: XOR<StudentTrainingUpdateWithoutProfileInput, StudentTrainingUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentTrainingCreateWithoutProfileInput, StudentTrainingUncheckedCreateWithoutProfileInput>
  }

  export type StudentTrainingUpdateWithWhereUniqueWithoutProfileInput = {
    where: StudentTrainingWhereUniqueInput
    data: XOR<StudentTrainingUpdateWithoutProfileInput, StudentTrainingUncheckedUpdateWithoutProfileInput>
  }

  export type StudentTrainingUpdateManyWithWhereWithoutProfileInput = {
    where: StudentTrainingScalarWhereInput
    data: XOR<StudentTrainingUpdateManyMutationInput, StudentTrainingUncheckedUpdateManyWithoutProfileInput>
  }

  export type StudentTrainingScalarWhereInput = {
    AND?: StudentTrainingScalarWhereInput | StudentTrainingScalarWhereInput[]
    OR?: StudentTrainingScalarWhereInput[]
    NOT?: StudentTrainingScalarWhereInput | StudentTrainingScalarWhereInput[]
    id?: IntFilter<"StudentTraining"> | number
    title?: StringFilter<"StudentTraining"> | string
    category?: StringFilter<"StudentTraining"> | string
    level?: StringFilter<"StudentTraining"> | string
    instructor?: StringFilter<"StudentTraining"> | string
    hours?: IntNullableFilter<"StudentTraining"> | number | null
    completionDate?: DateTimeNullableFilter<"StudentTraining"> | Date | string | null
    startDate?: DateTimeNullableFilter<"StudentTraining"> | Date | string | null
    status?: StringFilter<"StudentTraining"> | string
    progress?: IntNullableFilter<"StudentTraining"> | number | null
    certificate?: BoolFilter<"StudentTraining"> | boolean
    profileId?: IntFilter<"StudentTraining"> | number
  }

  export type StudentProfileCreateWithoutSkillsInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutSkillsInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutSkillsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutSkillsInput, StudentProfileUncheckedCreateWithoutSkillsInput>
  }

  export type StudentProfileUpsertWithoutSkillsInput = {
    update: XOR<StudentProfileUpdateWithoutSkillsInput, StudentProfileUncheckedUpdateWithoutSkillsInput>
    create: XOR<StudentProfileCreateWithoutSkillsInput, StudentProfileUncheckedCreateWithoutSkillsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutSkillsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutSkillsInput, StudentProfileUncheckedUpdateWithoutSkillsInput>
  }

  export type StudentProfileUpdateWithoutSkillsInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileCreateWithoutBadgesInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutBadgesInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutBadgesInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutBadgesInput, StudentProfileUncheckedCreateWithoutBadgesInput>
  }

  export type StudentProfileUpsertWithoutBadgesInput = {
    update: XOR<StudentProfileUpdateWithoutBadgesInput, StudentProfileUncheckedUpdateWithoutBadgesInput>
    create: XOR<StudentProfileCreateWithoutBadgesInput, StudentProfileUncheckedCreateWithoutBadgesInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutBadgesInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutBadgesInput, StudentProfileUncheckedUpdateWithoutBadgesInput>
  }

  export type StudentProfileUpdateWithoutBadgesInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutBadgesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileCreateWithoutStudentTrainingInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutStudentTrainingInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutStudentTrainingInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutStudentTrainingInput, StudentProfileUncheckedCreateWithoutStudentTrainingInput>
  }

  export type StudentProfileUpsertWithoutStudentTrainingInput = {
    update: XOR<StudentProfileUpdateWithoutStudentTrainingInput, StudentProfileUncheckedUpdateWithoutStudentTrainingInput>
    create: XOR<StudentProfileCreateWithoutStudentTrainingInput, StudentProfileUncheckedCreateWithoutStudentTrainingInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutStudentTrainingInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutStudentTrainingInput, StudentProfileUncheckedUpdateWithoutStudentTrainingInput>
  }

  export type StudentProfileUpdateWithoutStudentTrainingInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutStudentTrainingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
  }

  export type StudentProfileCreateWithoutTestimonialsInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutTestimonialsInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutTestimonialsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutTestimonialsInput, StudentProfileUncheckedCreateWithoutTestimonialsInput>
  }

  export type StudentProfileUpsertWithoutTestimonialsInput = {
    update: XOR<StudentProfileUpdateWithoutTestimonialsInput, StudentProfileUncheckedUpdateWithoutTestimonialsInput>
    create: XOR<StudentProfileCreateWithoutTestimonialsInput, StudentProfileUncheckedCreateWithoutTestimonialsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutTestimonialsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutTestimonialsInput, StudentProfileUncheckedUpdateWithoutTestimonialsInput>
  }

  export type StudentProfileUpdateWithoutTestimonialsInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutTestimonialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileCreateWithoutAcademicSubjectsInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutAcademicSubjectsInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    trainingReviews?: TrainingReviewUncheckedCreateNestedManyWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutAcademicSubjectsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutAcademicSubjectsInput, StudentProfileUncheckedCreateWithoutAcademicSubjectsInput>
  }

  export type StudentProfileUpsertWithoutAcademicSubjectsInput = {
    update: XOR<StudentProfileUpdateWithoutAcademicSubjectsInput, StudentProfileUncheckedUpdateWithoutAcademicSubjectsInput>
    create: XOR<StudentProfileCreateWithoutAcademicSubjectsInput, StudentProfileUncheckedCreateWithoutAcademicSubjectsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutAcademicSubjectsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutAcademicSubjectsInput, StudentProfileUncheckedUpdateWithoutAcademicSubjectsInput>
  }

  export type StudentProfileUpdateWithoutAcademicSubjectsInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutAcademicSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    trainingReviews?: TrainingReviewUncheckedUpdateManyWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type TrainingCreateWithoutReviewsInput = {
    title: string
    description?: string | null
    category: string
    level: string
    instructor: string
    totalHours: number
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: StudentTrainingEnrollmentCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutReviewsInput = {
    id?: number
    title: string
    description?: string | null
    category: string
    level: string
    instructor: string
    totalHours: number
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutReviewsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutReviewsInput, TrainingUncheckedCreateWithoutReviewsInput>
  }

  export type StudentProfileCreateWithoutTrainingReviewsInput = {
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentProfileInput
    skills?: StudentSkillCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentCreateNestedOneWithoutStudentProfileInput
    StudentTraining?: StudentTrainingCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileUncheckedCreateWithoutTrainingReviewsInput = {
    id?: number
    userId: number
    university?: string | null
    faculty?: string | null
    year?: string | null
    gpa?: number | null
    bio?: string | null
    location?: string | null
    phoneNumber?: string | null
    linkedinUrl?: string | null
    facebookUrl?: string | null
    githubUrl?: string | null
    portfolioUrl?: string | null
    profileImage?: string | null
    cvPath?: string | null
    attendance?: number | null
    totalCredits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: StudentSkillUncheckedCreateNestedManyWithoutProfileInput
    badges?: StudentBadgeUncheckedCreateNestedManyWithoutProfileInput
    trainings?: StudentTrainingEnrollmentUncheckedCreateNestedManyWithoutProfileInput
    testimonials?: StudentTestimonialUncheckedCreateNestedManyWithoutProfileInput
    academicSubjects?: StudentSubjectUncheckedCreateNestedManyWithoutProfileInput
    featuredStudent?: FeaturedStudentUncheckedCreateNestedOneWithoutStudentProfileInput
    StudentTraining?: StudentTrainingUncheckedCreateNestedManyWithoutProfileInput
  }

  export type StudentProfileCreateOrConnectWithoutTrainingReviewsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutTrainingReviewsInput, StudentProfileUncheckedCreateWithoutTrainingReviewsInput>
  }

  export type FeaturedStudentCreateWithoutTrainingReviewsInput = {
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    courseType: $Enums.CourseType
    score: number
    imagePath?: string | null
    description: string
    achievements?: FeaturedStudentCreateachievementsInput | string[]
    graduationDate: Date | string
    isActive?: boolean
    linkedinUrl?: string | null
    testimonial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentProfileCreateNestedOneWithoutFeaturedStudentInput
  }

  export type FeaturedStudentUncheckedCreateWithoutTrainingReviewsInput = {
    id?: number
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    courseType: $Enums.CourseType
    score: number
    imagePath?: string | null
    description: string
    achievements?: FeaturedStudentCreateachievementsInput | string[]
    graduationDate: Date | string
    isActive?: boolean
    linkedinUrl?: string | null
    testimonial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfileId?: number | null
  }

  export type FeaturedStudentCreateOrConnectWithoutTrainingReviewsInput = {
    where: FeaturedStudentWhereUniqueInput
    create: XOR<FeaturedStudentCreateWithoutTrainingReviewsInput, FeaturedStudentUncheckedCreateWithoutTrainingReviewsInput>
  }

  export type TrainingUpsertWithoutReviewsInput = {
    update: XOR<TrainingUpdateWithoutReviewsInput, TrainingUncheckedUpdateWithoutReviewsInput>
    create: XOR<TrainingCreateWithoutReviewsInput, TrainingUncheckedCreateWithoutReviewsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutReviewsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutReviewsInput, TrainingUncheckedUpdateWithoutReviewsInput>
  }

  export type TrainingUpdateWithoutReviewsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: StudentTrainingEnrollmentUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type StudentProfileUpsertWithoutTrainingReviewsInput = {
    update: XOR<StudentProfileUpdateWithoutTrainingReviewsInput, StudentProfileUncheckedUpdateWithoutTrainingReviewsInput>
    create: XOR<StudentProfileCreateWithoutTrainingReviewsInput, StudentProfileUncheckedCreateWithoutTrainingReviewsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutTrainingReviewsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutTrainingReviewsInput, StudentProfileUncheckedUpdateWithoutTrainingReviewsInput>
  }

  export type StudentProfileUpdateWithoutTrainingReviewsInput = {
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentProfileNestedInput
    skills?: StudentSkillUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUpdateManyWithoutProfileNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutTrainingReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    university?: NullableStringFieldUpdateOperationsInput | string | null
    faculty?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    portfolioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    cvPath?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCredits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: StudentSkillUncheckedUpdateManyWithoutProfileNestedInput
    badges?: StudentBadgeUncheckedUpdateManyWithoutProfileNestedInput
    trainings?: StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileNestedInput
    testimonials?: StudentTestimonialUncheckedUpdateManyWithoutProfileNestedInput
    academicSubjects?: StudentSubjectUncheckedUpdateManyWithoutProfileNestedInput
    featuredStudent?: FeaturedStudentUncheckedUpdateOneWithoutStudentProfileNestedInput
    StudentTraining?: StudentTrainingUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type FeaturedStudentUpsertWithoutTrainingReviewsInput = {
    update: XOR<FeaturedStudentUpdateWithoutTrainingReviewsInput, FeaturedStudentUncheckedUpdateWithoutTrainingReviewsInput>
    create: XOR<FeaturedStudentCreateWithoutTrainingReviewsInput, FeaturedStudentUncheckedCreateWithoutTrainingReviewsInput>
    where?: FeaturedStudentWhereInput
  }

  export type FeaturedStudentUpdateToOneWithWhereWithoutTrainingReviewsInput = {
    where?: FeaturedStudentWhereInput
    data: XOR<FeaturedStudentUpdateWithoutTrainingReviewsInput, FeaturedStudentUncheckedUpdateWithoutTrainingReviewsInput>
  }

  export type FeaturedStudentUpdateWithoutTrainingReviewsInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    score?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    achievements?: FeaturedStudentUpdateachievementsInput | string[]
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneWithoutFeaturedStudentNestedInput
  }

  export type FeaturedStudentUncheckedUpdateWithoutTrainingReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    score?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    achievements?: FeaturedStudentUpdateachievementsInput | string[]
    graduationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApplicationCreateManyUserInput = {
    id?: number
    name: string
    surname: string
    email: string
    phoneNumber?: string | null
    createdAt?: Date | string
    type: $Enums.TrainingType
  }

  export type ApplicationUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
  }

  export type ApplicationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
  }

  export type ApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
  }

  export type NewsImageCreateManyNewsInput = {
    id?: number
    url: string
    socialUrl?: string | null
    mobileSocialUrl?: string | null
    desktopSocialUrl?: string | null
    isMain?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type NewsImageUpdateWithoutNewsInput = {
    url?: StringFieldUpdateOperationsInput | string
    socialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    desktopSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsImageUncheckedUpdateWithoutNewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    socialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    desktopSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsImageUncheckedUpdateManyWithoutNewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    socialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    desktopSocialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingReviewCreateManyFeaturedStudentInput = {
    id?: number
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId: number
    studentProfileId: number
  }

  export type TrainingReviewUpdateWithoutFeaturedStudentInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutReviewsNestedInput
    studentProfile?: StudentProfileUpdateOneRequiredWithoutTrainingReviewsNestedInput
  }

  export type TrainingReviewUncheckedUpdateWithoutFeaturedStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
  }

  export type TrainingReviewUncheckedUpdateManyWithoutFeaturedStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: IntFieldUpdateOperationsInput | number
    studentProfileId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTrainingEnrollmentCreateManyTrainingInput = {
    id?: number
    profileId: number
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingReviewCreateManyTrainingInput = {
    id?: number
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfileId: number
    featuredStudentId?: number | null
  }

  export type StudentTrainingEnrollmentUpdateWithoutTrainingInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: StudentProfileUpdateOneRequiredWithoutTrainingsNestedInput
  }

  export type StudentTrainingEnrollmentUncheckedUpdateWithoutTrainingInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTrainingEnrollmentUncheckedUpdateManyWithoutTrainingInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingReviewUpdateWithoutTrainingInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentProfileUpdateOneRequiredWithoutTrainingReviewsNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutTrainingReviewsNestedInput
  }

  export type TrainingReviewUncheckedUpdateWithoutTrainingInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfileId?: IntFieldUpdateOperationsInput | number
    featuredStudentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TrainingReviewUncheckedUpdateManyWithoutTrainingInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfileId?: IntFieldUpdateOperationsInput | number
    featuredStudentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentSkillCreateManyProfileInput = {
    id?: number
    name: string
    level: number
  }

  export type StudentBadgeCreateManyProfileInput = {
    id?: number
    name: string
    type: string
    date: Date | string
  }

  export type StudentTrainingEnrollmentCreateManyProfileInput = {
    id?: number
    trainingId: number
    enrollmentDate?: Date | string
    status: $Enums.TrainingStatus
    progress?: number
    completionDate?: Date | string | null
    certificateUrl?: string | null
    attendance?: number
    grade?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTestimonialCreateManyProfileInput = {
    id?: number
    author: string
    role: string
    content: string
    rating: number
    date?: Date | string
  }

  export type StudentSubjectCreateManyProfileInput = {
    id?: number
    name: string
    grade: string
    credits: number
    semester: string
  }

  export type TrainingReviewCreateManyStudentProfileInput = {
    id?: number
    content: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId: number
    featuredStudentId?: number | null
  }

  export type StudentTrainingCreateManyProfileInput = {
    id?: number
    title: string
    category: string
    level: string
    instructor: string
    hours?: number | null
    completionDate?: Date | string | null
    startDate?: Date | string | null
    status: string
    progress?: number | null
    certificate?: boolean
  }

  export type StudentSkillUpdateWithoutProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type StudentSkillUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type StudentSkillUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type StudentBadgeUpdateWithoutProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentBadgeUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentBadgeUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTrainingEnrollmentUpdateWithoutProfileInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type StudentTrainingEnrollmentUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    trainingId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTrainingEnrollmentUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    trainingId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    progress?: IntFieldUpdateOperationsInput | number
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: IntFieldUpdateOperationsInput | number
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTestimonialUpdateWithoutProfileInput = {
    author?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTestimonialUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTestimonialUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSubjectUpdateWithoutProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSubjectUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSubjectUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingReviewUpdateWithoutStudentProfileInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutReviewsNestedInput
    featuredStudent?: FeaturedStudentUpdateOneWithoutTrainingReviewsNestedInput
  }

  export type TrainingReviewUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: IntFieldUpdateOperationsInput | number
    featuredStudentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TrainingReviewUncheckedUpdateManyWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: IntFieldUpdateOperationsInput | number
    featuredStudentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentTrainingUpdateWithoutProfileInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    certificate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentTrainingUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    certificate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentTrainingUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    instructor?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    certificate?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsCountOutputTypeDefaultArgs instead
     */
    export type NewsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeaturedStudentCountOutputTypeDefaultArgs instead
     */
    export type FeaturedStudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeaturedStudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingCountOutputTypeDefaultArgs instead
     */
    export type TrainingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentProfileCountOutputTypeDefaultArgs instead
     */
    export type StudentProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsImageDefaultArgs instead
     */
    export type NewsImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsDefaultArgs instead
     */
    export type NewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationDefaultArgs instead
     */
    export type ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobListingDefaultArgs instead
     */
    export type JobListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobListingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamMemberDefaultArgs instead
     */
    export type TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeaturedStudentDefaultArgs instead
     */
    export type FeaturedStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeaturedStudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingDefaultArgs instead
     */
    export type TrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentTrainingEnrollmentDefaultArgs instead
     */
    export type StudentTrainingEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentTrainingEnrollmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentProfileDefaultArgs instead
     */
    export type StudentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSkillDefaultArgs instead
     */
    export type StudentSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentBadgeDefaultArgs instead
     */
    export type StudentBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentTrainingDefaultArgs instead
     */
    export type StudentTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentTrainingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentTestimonialDefaultArgs instead
     */
    export type StudentTestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentTestimonialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSubjectDefaultArgs instead
     */
    export type StudentSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentSubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingReviewDefaultArgs instead
     */
    export type TrainingReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingReviewDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}